1
00:00:00,600 --> 00:00:05,630

I'd like to get started today we're

2
00:00:05,630 --> 00:00:05,640
I'd like to get started today we're
 

3
00:00:05,640 --> 00:00:09,379
I'd like to get started today we're
gonna talk about GFS the Google file

4
00:00:09,379 --> 00:00:09,389
gonna talk about GFS the Google file
 

5
00:00:09,389 --> 00:00:10,970
gonna talk about GFS the Google file
system paper we read for today

6
00:00:10,970 --> 00:00:10,980
system paper we read for today
 

7
00:00:10,980 --> 00:00:12,650
system paper we read for today
and this will be the first of a number

8
00:00:12,650 --> 00:00:12,660
and this will be the first of a number
 

9
00:00:12,660 --> 00:00:15,530
and this will be the first of a number
of different sort of case studies we'll

10
00:00:15,530 --> 00:00:15,540
of different sort of case studies we'll
 

11
00:00:15,540 --> 00:00:17,150
of different sort of case studies we'll
talk about in this course about how to

12
00:00:17,150 --> 00:00:17,160
talk about in this course about how to
 

13
00:00:17,160 --> 00:00:19,400
talk about in this course about how to
be build big storage systems so the

14
00:00:19,400 --> 00:00:19,410
be build big storage systems so the
 

15
00:00:19,410 --> 00:00:29,300
be build big storage systems so the
larger topic is big storage the reason

16
00:00:29,300 --> 00:00:29,310
larger topic is big storage the reason
 

17
00:00:29,310 --> 00:00:31,400
larger topic is big storage the reason
is the storage is turned out to be a key

18
00:00:31,400 --> 00:00:31,410
is the storage is turned out to be a key
 

19
00:00:31,410 --> 00:00:34,250
is the storage is turned out to be a key
abstraction you might you know if you

20
00:00:34,250 --> 00:00:34,260
abstraction you might you know if you
 

21
00:00:34,260 --> 00:00:35,840
abstraction you might you know if you
didn't know already you might imagine

22
00:00:35,840 --> 00:00:35,850
didn't know already you might imagine
 

23
00:00:35,850 --> 00:00:37,220
didn't know already you might imagine
that there could be all kinds of

24
00:00:37,220 --> 00:00:37,230
that there could be all kinds of
 

25
00:00:37,230 --> 00:00:40,040
that there could be all kinds of
different you know important

26
00:00:40,040 --> 00:00:40,050
different you know important
 

27
00:00:40,050 --> 00:00:42,020
different you know important
abstractions you might want to use for

28
00:00:42,020 --> 00:00:42,030
abstractions you might want to use for
 

29
00:00:42,030 --> 00:00:43,640
abstractions you might want to use for
distributed systems but it's turned out

30
00:00:43,640 --> 00:00:43,650
distributed systems but it's turned out
 

31
00:00:43,650 --> 00:00:47,720
distributed systems but it's turned out
that a simple storage interface is just

32
00:00:47,720 --> 00:00:47,730
that a simple storage interface is just
 

33
00:00:47,730 --> 00:00:50,000
that a simple storage interface is just
incredibly useful and extremely general

34
00:00:50,000 --> 00:00:50,010
incredibly useful and extremely general
 

35
00:00:50,010 --> 00:00:51,470
incredibly useful and extremely general
and so a lot of the thought that's gone

36
00:00:51,470 --> 00:00:51,480
and so a lot of the thought that's gone
 

37
00:00:51,480 --> 00:00:53,270
and so a lot of the thought that's gone
into building distributed systems has

38
00:00:53,270 --> 00:00:53,280
into building distributed systems has
 

39
00:00:53,280 --> 00:00:55,160
into building distributed systems has
either gone into designing storage

40
00:00:55,160 --> 00:00:55,170
either gone into designing storage
 

41
00:00:55,170 --> 00:00:57,620
either gone into designing storage
systems or designing other systems that

42
00:00:57,620 --> 00:00:57,630
systems or designing other systems that
 

43
00:00:57,630 --> 00:01:00,170
systems or designing other systems that
assume underneath them some sort of

44
00:01:00,170 --> 00:01:00,180
assume underneath them some sort of
 

45
00:01:00,180 --> 00:01:02,979
assume underneath them some sort of
reasonably well behaved big just

46
00:01:02,979 --> 00:01:02,989
reasonably well behaved big just
 

47
00:01:02,989 --> 00:01:05,509
reasonably well behaved big just
distributed storage system so we're

48
00:01:05,509 --> 00:01:05,519
distributed storage system so we're
 

49
00:01:05,519 --> 00:01:07,490
distributed storage system so we're
going to care a lot about how the you

50
00:01:07,490 --> 00:01:07,500
going to care a lot about how the you
 

51
00:01:07,500 --> 00:01:09,350
going to care a lot about how the you
know how to design a good interface to a

52
00:01:09,350 --> 00:01:09,360
know how to design a good interface to a
 

53
00:01:09,360 --> 00:01:12,410
know how to design a good interface to a
big storage system and how to design the

54
00:01:12,410 --> 00:01:12,420
big storage system and how to design the
 

55
00:01:12,420 --> 00:01:14,149
big storage system and how to design the
innards of the storage system so it has

56
00:01:14,149 --> 00:01:14,159
innards of the storage system so it has
 

57
00:01:14,159 --> 00:01:18,020
innards of the storage system so it has
good behavior you know of course that's

58
00:01:18,020 --> 00:01:18,030
good behavior you know of course that's
 

59
00:01:18,030 --> 00:01:19,219
good behavior you know of course that's
why we're reading this paper just to get

60
00:01:19,219 --> 00:01:19,229
why we're reading this paper just to get
 

61
00:01:19,229 --> 00:01:20,840
why we're reading this paper just to get
a start on that the this paper also

62
00:01:20,840 --> 00:01:20,850
a start on that the this paper also
 

63
00:01:20,850 --> 00:01:22,520
a start on that the this paper also
touches on a lot of themes that will

64
00:01:22,520 --> 00:01:22,530
touches on a lot of themes that will
 

65
00:01:22,530 --> 00:01:24,890
touches on a lot of themes that will
come up a lot in a tube for parallel

66
00:01:24,890 --> 00:01:24,900
come up a lot in a tube for parallel
 

67
00:01:24,900 --> 00:01:27,050
come up a lot in a tube for parallel
performance fault tolerance replication

68
00:01:27,050 --> 00:01:27,060
performance fault tolerance replication
 

69
00:01:27,060 --> 00:01:31,730
performance fault tolerance replication
and consistency and this paper is as

70
00:01:31,730 --> 00:01:31,740
and consistency and this paper is as
 

71
00:01:31,740 --> 00:01:34,130
and consistency and this paper is as
such things go reasonably

72
00:01:34,130 --> 00:01:34,140
such things go reasonably
 

73
00:01:34,140 --> 00:01:36,380
such things go reasonably
straightforward and easy to understand

74
00:01:36,380 --> 00:01:36,390
straightforward and easy to understand
 

75
00:01:36,390 --> 00:01:38,660
straightforward and easy to understand
it's also a good systems paper it sort

76
00:01:38,660 --> 00:01:38,670
it's also a good systems paper it sort
 

77
00:01:38,670 --> 00:01:40,550
it's also a good systems paper it sort
of talks about issues all the way from

78
00:01:40,550 --> 00:01:40,560
of talks about issues all the way from
 

79
00:01:40,560 --> 00:01:43,219
of talks about issues all the way from
the hardware to the software that

80
00:01:43,219 --> 00:01:43,229
the hardware to the software that
 

81
00:01:43,229 --> 00:01:45,950
the hardware to the software that
ultimately uses the system and it's a

82
00:01:45,950 --> 00:01:45,960
ultimately uses the system and it's a
 

83
00:01:45,960 --> 00:01:49,310
ultimately uses the system and it's a
successful real world design so it says

84
00:01:49,310 --> 00:01:49,320
successful real world design so it says
 

85
00:01:49,320 --> 00:01:51,020
successful real world design so it says
you know academic paper published in an

86
00:01:51,020 --> 00:01:51,030
you know academic paper published in an
 

87
00:01:51,030 --> 00:01:53,179
you know academic paper published in an
academic conference but it describes

88
00:01:53,179 --> 00:01:53,189
academic conference but it describes
 

89
00:01:53,189 --> 00:01:54,880
academic conference but it describes
something that really was successful and

90
00:01:54,880 --> 00:01:54,890
something that really was successful and
 

91
00:01:54,890 --> 00:01:57,020
something that really was successful and
used for a long time in the real world

92
00:01:57,020 --> 00:01:57,030
used for a long time in the real world
 

93
00:01:57,030 --> 00:01:58,640
used for a long time in the real world
so we sort of know that we're talking

94
00:01:58,640 --> 00:01:58,650
so we sort of know that we're talking
 

95
00:01:58,650 --> 00:02:02,330
so we sort of know that we're talking
about something that is it's a good a

96
00:02:02,330 --> 00:02:02,340
about something that is it's a good a
 

97
00:02:02,340 --> 00:02:07,100
about something that is it's a good a
good useful design okay so before I'm

98
00:02:07,100 --> 00:02:07,110
good useful design okay so before I'm
 

99
00:02:07,110 --> 00:02:09,139
good useful design okay so before I'm
gonna talk about GFS I want to sort of

100
00:02:09,139 --> 00:02:09,149
gonna talk about GFS I want to sort of
 

101
00:02:09,149 --> 00:02:11,269
gonna talk about GFS I want to sort of
talk about the space of distributed

102
00:02:11,269 --> 00:02:11,279
talk about the space of distributed
 

103
00:02:11,279 --> 00:02:13,020
talk about the space of distributed
storage systems a little bit

104
00:02:13,020 --> 00:02:13,030
storage systems a little bit
 

105
00:02:13,030 --> 00:02:19,910
storage systems a little bit
set the scene so first why is it hard

106
00:02:19,910 --> 00:02:19,920

 

107
00:02:19,920 --> 00:02:23,550

it's actually a lot to get right but for

108
00:02:23,550 --> 00:02:23,560
it's actually a lot to get right but for
 

109
00:02:23,560 --> 00:02:25,890
it's actually a lot to get right but for
a 2/4 there's a particular sort of

110
00:02:25,890 --> 00:02:25,900
a 2/4 there's a particular sort of
 

111
00:02:25,900 --> 00:02:28,320
a 2/4 there's a particular sort of
narrative that's gonna come up quite a

112
00:02:28,320 --> 00:02:28,330
narrative that's gonna come up quite a
 

113
00:02:28,330 --> 00:02:32,130
narrative that's gonna come up quite a
lot for many systems often the starting

114
00:02:32,130 --> 00:02:32,140
lot for many systems often the starting
 

115
00:02:32,140 --> 00:02:34,170
lot for many systems often the starting
point for people designing these sort of

116
00:02:34,170 --> 00:02:34,180
point for people designing these sort of
 

117
00:02:34,180 --> 00:02:35,880
point for people designing these sort of
big distributed systems or big storage

118
00:02:35,880 --> 00:02:35,890
big distributed systems or big storage
 

119
00:02:35,890 --> 00:02:37,320
big distributed systems or big storage
systems is they want to get huge

120
00:02:37,320 --> 00:02:37,330
systems is they want to get huge
 

121
00:02:37,330 --> 00:02:39,330
systems is they want to get huge
aggregate performance be able to harness

122
00:02:39,330 --> 00:02:39,340
aggregate performance be able to harness
 

123
00:02:39,340 --> 00:02:43,080
aggregate performance be able to harness
the resources of hundreds of machines in

124
00:02:43,080 --> 00:02:43,090
the resources of hundreds of machines in
 

125
00:02:43,090 --> 00:02:44,610
the resources of hundreds of machines in
order to get a huge amount of work done

126
00:02:44,610 --> 00:02:44,620
order to get a huge amount of work done
 

127
00:02:44,620 --> 00:02:47,990
order to get a huge amount of work done
so the sort of starting point is often

128
00:02:47,990 --> 00:02:48,000
so the sort of starting point is often
 

129
00:02:48,000 --> 00:02:54,420
so the sort of starting point is often
performance and you know if you start

130
00:02:54,420 --> 00:02:54,430
performance and you know if you start
 

131
00:02:54,430 --> 00:02:57,000
performance and you know if you start
there a natural next thought is well

132
00:02:57,000 --> 00:02:57,010
there a natural next thought is well
 

133
00:02:57,010 --> 00:02:59,009
there a natural next thought is well
we're gonna split our data over a huge

134
00:02:59,009 --> 00:02:59,019
we're gonna split our data over a huge
 

135
00:02:59,019 --> 00:03:00,630
we're gonna split our data over a huge
number of servers in order to be able to

136
00:03:00,630 --> 00:03:00,640
number of servers in order to be able to
 

137
00:03:00,640 --> 00:03:04,410
number of servers in order to be able to
read many servers in parallel so we're

138
00:03:04,410 --> 00:03:04,420
read many servers in parallel so we're
 

139
00:03:04,420 --> 00:03:05,759
read many servers in parallel so we're
gonna get and that's often called

140
00:03:05,759 --> 00:03:05,769
gonna get and that's often called
 

141
00:03:05,769 --> 00:03:11,150
gonna get and that's often called
sharding if you shard over many servers

142
00:03:11,150 --> 00:03:11,160
sharding if you shard over many servers
 

143
00:03:11,160 --> 00:03:13,590
sharding if you shard over many servers
hundreds or thousands of servers you're

144
00:03:13,590 --> 00:03:13,600
hundreds or thousands of servers you're
 

145
00:03:13,600 --> 00:03:15,960
hundreds or thousands of servers you're
just gonna see constant faults right if

146
00:03:15,960 --> 00:03:15,970
just gonna see constant faults right if
 

147
00:03:15,970 --> 00:03:17,130
just gonna see constant faults right if
you have thousands of servers there's

148
00:03:17,130 --> 00:03:17,140
you have thousands of servers there's
 

149
00:03:17,140 --> 00:03:20,670
you have thousands of servers there's
just always gonna be one down so we

150
00:03:20,670 --> 00:03:20,680
just always gonna be one down so we
 

151
00:03:20,680 --> 00:03:25,530
just always gonna be one down so we
defaults are just every day every hour

152
00:03:25,530 --> 00:03:25,540
defaults are just every day every hour
 

153
00:03:25,540 --> 00:03:27,240
defaults are just every day every hour
occurrences and we need automatic

154
00:03:27,240 --> 00:03:27,250
occurrences and we need automatic
 

155
00:03:27,250 --> 00:03:29,340
occurrences and we need automatic
weekend of humans involved and fixing

156
00:03:29,340 --> 00:03:29,350
weekend of humans involved and fixing
 

157
00:03:29,350 --> 00:03:31,880
weekend of humans involved and fixing
this fault we need automatic

158
00:03:31,880 --> 00:03:31,890
this fault we need automatic
 

159
00:03:31,890 --> 00:03:38,280
this fault we need automatic
fault-tolerant systems so that leads to

160
00:03:38,280 --> 00:03:38,290
fault-tolerant systems so that leads to
 

161
00:03:38,290 --> 00:03:43,080
fault-tolerant systems so that leads to
fault tolerance the among the most

162
00:03:43,080 --> 00:03:43,090
fault tolerance the among the most
 

163
00:03:43,090 --> 00:03:44,910
fault tolerance the among the most
powerful ways to get fault tolerance is

164
00:03:44,910 --> 00:03:44,920
powerful ways to get fault tolerance is
 

165
00:03:44,920 --> 00:03:46,620
powerful ways to get fault tolerance is
with replication just keep two or three

166
00:03:46,620 --> 00:03:46,630
with replication just keep two or three
 

167
00:03:46,630 --> 00:03:48,180
with replication just keep two or three
or whatever copies of data one of them

168
00:03:48,180 --> 00:03:48,190
or whatever copies of data one of them
 

169
00:03:48,190 --> 00:03:52,380
or whatever copies of data one of them
fails you can use another one so we want

170
00:03:52,380 --> 00:03:52,390
fails you can use another one so we want
 

171
00:03:52,390 --> 00:03:56,000
fails you can use another one so we want
to have tolerance that leads to

172
00:03:56,000 --> 00:03:56,010
to have tolerance that leads to
 

173
00:03:56,010 --> 00:04:03,090
to have tolerance that leads to
replication if you have replication two

174
00:04:03,090 --> 00:04:03,100
replication if you have replication two
 

175
00:04:03,100 --> 00:04:05,460
replication if you have replication two
copies the data then you know for sure

176
00:04:05,460 --> 00:04:05,470
copies the data then you know for sure
 

177
00:04:05,470 --> 00:04:07,319
copies the data then you know for sure
if you're not careful they're gonna get

178
00:04:07,319 --> 00:04:07,329
if you're not careful they're gonna get
 

179
00:04:07,329 --> 00:04:09,000
if you're not careful they're gonna get
out of sync and so what you thought was

180
00:04:09,000 --> 00:04:09,010
out of sync and so what you thought was
 

181
00:04:09,010 --> 00:04:10,740
out of sync and so what you thought was
two replicas of the data where you could

182
00:04:10,740 --> 00:04:10,750
two replicas of the data where you could
 

183
00:04:10,750 --> 00:04:12,539
two replicas of the data where you could
use either one interchangeably to

184
00:04:12,539 --> 00:04:12,549
use either one interchangeably to
 

185
00:04:12,549 --> 00:04:14,160
use either one interchangeably to
tolerate faults if you're not careful

186
00:04:14,160 --> 00:04:14,170
tolerate faults if you're not careful
 

187
00:04:14,170 --> 00:04:15,660
tolerate faults if you're not careful
what you end up with is two almost

188
00:04:15,660 --> 00:04:15,670
what you end up with is two almost
 

189
00:04:15,670 --> 00:04:18,630
what you end up with is two almost
identical replicas of the data that's

190
00:04:18,630 --> 00:04:18,640
identical replicas of the data that's
 

191
00:04:18,640 --> 00:04:20,279
identical replicas of the data that's
like not exactly replicas at all and

192
00:04:20,279 --> 00:04:20,289
like not exactly replicas at all and
 

193
00:04:20,289 --> 00:04:22,170
like not exactly replicas at all and
what you get back depends on which one

194
00:04:22,170 --> 00:04:22,180
what you get back depends on which one
 

195
00:04:22,180 --> 00:04:24,029
what you get back depends on which one
you talk to so that's starting to maybe

196
00:04:24,029 --> 00:04:24,039
you talk to so that's starting to maybe
 

197
00:04:24,039 --> 00:04:25,230
you talk to so that's starting to maybe
look a little bit

198
00:04:25,230 --> 00:04:25,240
look a little bit
 

199
00:04:25,240 --> 00:04:28,410
look a little bit
tricky for applications to use so if we

200
00:04:28,410 --> 00:04:28,420
tricky for applications to use so if we
 

201
00:04:28,420 --> 00:04:34,320
tricky for applications to use so if we
have replication we risk weird

202
00:04:34,320 --> 00:04:34,330
have replication we risk weird
 

203
00:04:34,330 --> 00:04:41,790
have replication we risk weird
inconsistencies of course clever design

204
00:04:41,790 --> 00:04:41,800
inconsistencies of course clever design
 

205
00:04:41,800 --> 00:04:45,390
inconsistencies of course clever design
you can get rid of inconsistency and

206
00:04:45,390 --> 00:04:45,400
you can get rid of inconsistency and
 

207
00:04:45,400 --> 00:04:47,670
you can get rid of inconsistency and
make the data look very well-behaved but

208
00:04:47,670 --> 00:04:47,680
make the data look very well-behaved but
 

209
00:04:47,680 --> 00:04:49,440
make the data look very well-behaved but
if you do that it almost always requires

210
00:04:49,440 --> 00:04:49,450
if you do that it almost always requires
 

211
00:04:49,450 --> 00:04:51,200
if you do that it almost always requires
extra work and extra sort of chitchat

212
00:04:51,200 --> 00:04:51,210
extra work and extra sort of chitchat
 

213
00:04:51,210 --> 00:04:53,130
extra work and extra sort of chitchat
between all the different servers and

214
00:04:53,130 --> 00:04:53,140
between all the different servers and
 

215
00:04:53,140 --> 00:04:54,600
between all the different servers and
clients in the network that reduces

216
00:04:54,600 --> 00:04:54,610
clients in the network that reduces
 

217
00:04:54,610 --> 00:04:59,540
clients in the network that reduces
performance so if you want consistency

218
00:04:59,540 --> 00:04:59,550

 

219
00:04:59,550 --> 00:05:09,180

you pay for with low performance I which

220
00:05:09,180 --> 00:05:09,190
you pay for with low performance I which
 

221
00:05:09,190 --> 00:05:11,730
you pay for with low performance I which
is of course not what we originally

222
00:05:11,730 --> 00:05:11,740
is of course not what we originally
 

223
00:05:11,740 --> 00:05:13,410
is of course not what we originally
hoping for of course this is an absolute

224
00:05:13,410 --> 00:05:13,420
hoping for of course this is an absolute
 

225
00:05:13,420 --> 00:05:14,640
hoping for of course this is an absolute
you can build very high performance

226
00:05:14,640 --> 00:05:14,650
you can build very high performance
 

227
00:05:14,650 --> 00:05:16,980
you can build very high performance
systems but nevertheless there's this

228
00:05:16,980 --> 00:05:16,990
systems but nevertheless there's this
 

229
00:05:16,990 --> 00:05:19,470
systems but nevertheless there's this
sort of inevitable way that the design

230
00:05:19,470 --> 00:05:19,480
sort of inevitable way that the design
 

231
00:05:19,480 --> 00:05:21,360
sort of inevitable way that the design
of these systems play out and it results

232
00:05:21,360 --> 00:05:21,370
of these systems play out and it results
 

233
00:05:21,370 --> 00:05:24,660
of these systems play out and it results
in a tension between the original goals

234
00:05:24,660 --> 00:05:24,670
in a tension between the original goals
 

235
00:05:24,670 --> 00:05:26,910
in a tension between the original goals
of performance and the sort of

236
00:05:26,910 --> 00:05:26,920
of performance and the sort of
 

237
00:05:26,920 --> 00:05:29,010
of performance and the sort of
realization that if you want good

238
00:05:29,010 --> 00:05:29,020
realization that if you want good
 

239
00:05:29,020 --> 00:05:31,710
realization that if you want good
consistency you're gonna pay for it and

240
00:05:31,710 --> 00:05:31,720
consistency you're gonna pay for it and
 

241
00:05:31,720 --> 00:05:33,720
consistency you're gonna pay for it and
if you don't want to pay for it then you

242
00:05:33,720 --> 00:05:33,730
if you don't want to pay for it then you
 

243
00:05:33,730 --> 00:05:35,820
if you don't want to pay for it then you
have to suffer with sort of anomalous

244
00:05:35,820 --> 00:05:35,830
have to suffer with sort of anomalous
 

245
00:05:35,830 --> 00:05:37,920
have to suffer with sort of anomalous
behavior sometimes I'm putting this up

246
00:05:37,920 --> 00:05:37,930
behavior sometimes I'm putting this up
 

247
00:05:37,930 --> 00:05:39,830
behavior sometimes I'm putting this up
because we're gonna see this this loop

248
00:05:39,830 --> 00:05:39,840
because we're gonna see this this loop
 

249
00:05:39,840 --> 00:05:42,300
because we're gonna see this this loop
many times for many of the systems we

250
00:05:42,300 --> 00:05:42,310
many times for many of the systems we
 

251
00:05:42,310 --> 00:05:45,570
many times for many of the systems we
look we look at people are we're rarely

252
00:05:45,570 --> 00:05:45,580
look we look at people are we're rarely
 

253
00:05:45,580 --> 00:05:48,060
look we look at people are we're rarely
willing to or happy about paying the

254
00:05:48,060 --> 00:05:48,070
willing to or happy about paying the
 

255
00:05:48,070 --> 00:05:52,920
willing to or happy about paying the
full cost of very good consistency ok so

256
00:05:52,920 --> 00:05:52,930
full cost of very good consistency ok so
 

257
00:05:52,930 --> 00:05:57,510
full cost of very good consistency ok so
you know with brought a consistency I'll

258
00:05:57,510 --> 00:05:57,520
you know with brought a consistency I'll
 

259
00:05:57,520 --> 00:06:02,040
you know with brought a consistency I'll
talk more later in the course about more

260
00:06:02,040 --> 00:06:02,050
talk more later in the course about more
 

261
00:06:02,050 --> 00:06:03,990
talk more later in the course about more
exactly what I mean by good consistency

262
00:06:03,990 --> 00:06:04,000
exactly what I mean by good consistency
 

263
00:06:04,000 --> 00:06:06,990
exactly what I mean by good consistency
but you can think of strong consistency

264
00:06:06,990 --> 00:06:07,000
but you can think of strong consistency
 

265
00:06:07,000 --> 00:06:09,270
but you can think of strong consistency
or good consistency as being we want to

266
00:06:09,270 --> 00:06:09,280
or good consistency as being we want to
 

267
00:06:09,280 --> 00:06:11,400
or good consistency as being we want to
build a system whose behavior to

268
00:06:11,400 --> 00:06:11,410
build a system whose behavior to
 

269
00:06:11,410 --> 00:06:13,920
build a system whose behavior to
applications or clients looks just like

270
00:06:13,920 --> 00:06:13,930
applications or clients looks just like
 

271
00:06:13,930 --> 00:06:15,600
applications or clients looks just like
you'd expect from talking to a single

272
00:06:15,600 --> 00:06:15,610
you'd expect from talking to a single
 

273
00:06:15,610 --> 00:06:18,750
you'd expect from talking to a single
server all right we're gonna build you

274
00:06:18,750 --> 00:06:18,760
server all right we're gonna build you
 

275
00:06:18,760 --> 00:06:20,250
server all right we're gonna build you
know systems out of hundreds of machines

276
00:06:20,250 --> 00:06:20,260
know systems out of hundreds of machines
 

277
00:06:20,260 --> 00:06:23,160
know systems out of hundreds of machines
but a kind of ideal strong consistency

278
00:06:23,160 --> 00:06:23,170
but a kind of ideal strong consistency
 

279
00:06:23,170 --> 00:06:24,990
but a kind of ideal strong consistency
model would be what you'd get if there

280
00:06:24,990 --> 00:06:25,000
model would be what you'd get if there
 

281
00:06:25,000 --> 00:06:26,550
model would be what you'd get if there
was just one server with one copy of the

282
00:06:26,550 --> 00:06:26,560
was just one server with one copy of the
 

283
00:06:26,560 --> 00:06:31,800
was just one server with one copy of the
data doing one thing at a time so this

284
00:06:31,800 --> 00:06:31,810
data doing one thing at a time so this
 

285
00:06:31,810 --> 00:06:34,339
data doing one thing at a time so this
is kind of a strong

286
00:06:34,339 --> 00:06:34,349
is kind of a strong
 

287
00:06:34,349 --> 00:06:41,159
is kind of a strong
consistency kind of intuitive way to

288
00:06:41,159 --> 00:06:41,169
consistency kind of intuitive way to
 

289
00:06:41,169 --> 00:06:42,779
consistency kind of intuitive way to
think about strong consistency so you

290
00:06:42,779 --> 00:06:42,789
think about strong consistency so you
 

291
00:06:42,789 --> 00:06:45,480
think about strong consistency so you
might think you have one server we'll

292
00:06:45,480 --> 00:06:45,490
might think you have one server we'll
 

293
00:06:45,490 --> 00:06:47,010
might think you have one server we'll
assume that's a single-threaded server

294
00:06:47,010 --> 00:06:47,020
assume that's a single-threaded server
 

295
00:06:47,020 --> 00:06:49,200
assume that's a single-threaded server
and that it processes requests from

296
00:06:49,200 --> 00:06:49,210
and that it processes requests from
 

297
00:06:49,210 --> 00:06:50,909
and that it processes requests from
clients one at a time and that's

298
00:06:50,909 --> 00:06:50,919
clients one at a time and that's
 

299
00:06:50,919 --> 00:06:52,559
clients one at a time and that's
important because there may be lots of

300
00:06:52,559 --> 00:06:52,569
important because there may be lots of
 

301
00:06:52,569 --> 00:06:55,499
important because there may be lots of
clients sending concurrently requests

302
00:06:55,499 --> 00:06:55,509
clients sending concurrently requests
 

303
00:06:55,509 --> 00:06:57,360
clients sending concurrently requests
into the server and see some current

304
00:06:57,360 --> 00:06:57,370
into the server and see some current
 

305
00:06:57,370 --> 00:06:59,010
into the server and see some current
requests it picks one or the other to go

306
00:06:59,010 --> 00:06:59,020
requests it picks one or the other to go
 

307
00:06:59,020 --> 00:07:00,719
requests it picks one or the other to go
first and excuse that request to

308
00:07:00,719 --> 00:07:00,729
first and excuse that request to
 

309
00:07:00,729 --> 00:07:04,080
first and excuse that request to
completion then excuse the nets so for

310
00:07:04,080 --> 00:07:04,090
completion then excuse the nets so for
 

311
00:07:04,090 --> 00:07:06,089
completion then excuse the nets so for
storage servers or you know the server's

312
00:07:06,089 --> 00:07:06,099
storage servers or you know the server's
 

313
00:07:06,099 --> 00:07:07,619
storage servers or you know the server's
got a disk on it and what it means to

314
00:07:07,619 --> 00:07:07,629
got a disk on it and what it means to
 

315
00:07:07,629 --> 00:07:10,050
got a disk on it and what it means to
process a request is it's a write

316
00:07:10,050 --> 00:07:10,060
process a request is it's a write
 

317
00:07:10,060 --> 00:07:12,600
process a request is it's a write
request you know which might be writing

318
00:07:12,600 --> 00:07:12,610
request you know which might be writing
 

319
00:07:12,610 --> 00:07:14,700
request you know which might be writing
an item or may be increment and I mean

320
00:07:14,700 --> 00:07:14,710
an item or may be increment and I mean
 

321
00:07:14,710 --> 00:07:17,969
an item or may be increment and I mean
incrementing an item if it's a mutation

322
00:07:17,969 --> 00:07:17,979
incrementing an item if it's a mutation
 

323
00:07:17,979 --> 00:07:21,059
incrementing an item if it's a mutation
then we're gonna go and we have some

324
00:07:21,059 --> 00:07:21,069
then we're gonna go and we have some
 

325
00:07:21,069 --> 00:07:23,670
then we're gonna go and we have some
table of data and you know maybe index

326
00:07:23,670 --> 00:07:23,680
table of data and you know maybe index
 

327
00:07:23,680 --> 00:07:25,230
table of data and you know maybe index
by keys and values and we're gonna

328
00:07:25,230 --> 00:07:25,240
by keys and values and we're gonna
 

329
00:07:25,240 --> 00:07:27,029
by keys and values and we're gonna
update this table and if the request

330
00:07:27,029 --> 00:07:27,039
update this table and if the request
 

331
00:07:27,039 --> 00:07:28,230
update this table and if the request
comes in and to read we're just gonna

332
00:07:28,230 --> 00:07:28,240
comes in and to read we're just gonna
 

333
00:07:28,240 --> 00:07:30,089
comes in and to read we're just gonna
you know pull the write data out of the

334
00:07:30,089 --> 00:07:30,099
you know pull the write data out of the
 

335
00:07:30,099 --> 00:07:36,749
you know pull the write data out of the
table one of the rules here that sort of

336
00:07:36,749 --> 00:07:36,759
table one of the rules here that sort of
 

337
00:07:36,759 --> 00:07:39,570
table one of the rules here that sort of
makes this well-behaved is that each is

338
00:07:39,570 --> 00:07:39,580
makes this well-behaved is that each is
 

339
00:07:39,580 --> 00:07:41,730
makes this well-behaved is that each is
that the server really does execute in

340
00:07:41,730 --> 00:07:41,740
that the server really does execute in
 

341
00:07:41,740 --> 00:07:44,700
that the server really does execute in
our simplified model excuse to request

342
00:07:44,700 --> 00:07:44,710
our simplified model excuse to request
 

343
00:07:44,710 --> 00:07:48,119
our simplified model excuse to request
one at a time and that requests see data

344
00:07:48,119 --> 00:07:48,129
one at a time and that requests see data
 

345
00:07:48,129 --> 00:07:49,980
one at a time and that requests see data
that reflects all the previous

346
00:07:49,980 --> 00:07:49,990
that reflects all the previous
 

347
00:07:49,990 --> 00:07:51,809
that reflects all the previous
operations in order so if a sequence of

348
00:07:51,809 --> 00:07:51,819
operations in order so if a sequence of
 

349
00:07:51,819 --> 00:07:53,550
operations in order so if a sequence of
writes come in and the server process

350
00:07:53,550 --> 00:07:53,560
writes come in and the server process
 

351
00:07:53,560 --> 00:07:55,350
writes come in and the server process
them in some order then when you read

352
00:07:55,350 --> 00:07:55,360
them in some order then when you read
 

353
00:07:55,360 --> 00:07:58,050
them in some order then when you read
you see the sort of you know value you

354
00:07:58,050 --> 00:07:58,060
you see the sort of you know value you
 

355
00:07:58,060 --> 00:07:59,999
you see the sort of you know value you
would expect if those writes that

356
00:07:59,999 --> 00:08:00,009
would expect if those writes that
 

357
00:08:00,009 --> 00:08:05,159
would expect if those writes that
occurred one at a time the behavior this

358
00:08:05,159 --> 00:08:05,169
occurred one at a time the behavior this
 

359
00:08:05,169 --> 00:08:07,019
occurred one at a time the behavior this
is still not completely straightforward

360
00:08:07,019 --> 00:08:07,029
is still not completely straightforward
 

361
00:08:07,029 --> 00:08:09,649
is still not completely straightforward
there's some you know there's some

362
00:08:09,649 --> 00:08:09,659
there's some you know there's some
 

363
00:08:09,659 --> 00:08:11,909
there's some you know there's some
things that you have to spend at least a

364
00:08:11,909 --> 00:08:11,919
things that you have to spend at least a
 

365
00:08:11,919 --> 00:08:13,619
things that you have to spend at least a
second thinking about so for example if

366
00:08:13,619 --> 00:08:13,629
second thinking about so for example if
 

367
00:08:13,629 --> 00:08:19,529
second thinking about so for example if
we have a bunch of clients and client

368
00:08:19,529 --> 00:08:19,539
we have a bunch of clients and client
 

369
00:08:19,539 --> 00:08:25,170
we have a bunch of clients and client
one issues a write of value X and wants

370
00:08:25,170 --> 00:08:25,180
one issues a write of value X and wants
 

371
00:08:25,180 --> 00:08:27,450
one issues a write of value X and wants
it to set it to one and at the same time

372
00:08:27,450 --> 00:08:27,460
it to set it to one and at the same time
 

373
00:08:27,460 --> 00:08:30,450
it to set it to one and at the same time
client two issues the right of the same

374
00:08:30,450 --> 00:08:30,460
client two issues the right of the same
 

375
00:08:30,460 --> 00:08:32,149
client two issues the right of the same
value but wants to set it to a different

376
00:08:32,149 --> 00:08:32,159
value but wants to set it to a different
 

377
00:08:32,159 --> 00:08:34,350
value but wants to set it to a different
the same key but wants to set it to a

378
00:08:34,350 --> 00:08:34,360
the same key but wants to set it to a
 

379
00:08:34,360 --> 00:08:35,850
the same key but wants to set it to a
different value right

380
00:08:35,850 --> 00:08:35,860
different value right
 

381
00:08:35,860 --> 00:08:38,399
different value right
something happens let's say client three

382
00:08:38,399 --> 00:08:38,409
something happens let's say client three
 

383
00:08:38,409 --> 00:08:42,480
something happens let's say client three
reads and get some result or client

384
00:08:42,480 --> 00:08:42,490
reads and get some result or client
 

385
00:08:42,490 --> 00:08:44,010
reads and get some result or client
three after these writes complete reads

386
00:08:44,010 --> 00:08:44,020
three after these writes complete reads
 

387
00:08:44,020 --> 00:08:47,210
three after these writes complete reads
get some result client four

388
00:08:47,210 --> 00:08:47,220
get some result client four
 

389
00:08:47,220 --> 00:08:50,280
get some result client four
reads X and get some also gets a result

390
00:08:50,280 --> 00:08:50,290
reads X and get some also gets a result
 

391
00:08:50,290 --> 00:08:51,989
reads X and get some also gets a result
so what results should the two clients

392
00:08:51,989 --> 00:08:51,999
so what results should the two clients
 

393
00:08:51,999 --> 00:09:04,690
so what results should the two clients
see yeah

394
00:09:04,690 --> 00:09:04,700

 

395
00:09:04,700 --> 00:09:07,190

well that's a good question so these

396
00:09:07,190 --> 00:09:07,200
well that's a good question so these
 

397
00:09:07,200 --> 00:09:09,050
well that's a good question so these
what I'm assuming here is that client

398
00:09:09,050 --> 00:09:09,060
what I'm assuming here is that client
 

399
00:09:09,060 --> 00:09:10,760
what I'm assuming here is that client
one inclined to launch these requests at

400
00:09:10,760 --> 00:09:10,770
one inclined to launch these requests at
 

401
00:09:10,770 --> 00:09:12,710
one inclined to launch these requests at
the same time so if we were monitoring

402
00:09:12,710 --> 00:09:12,720
the same time so if we were monitoring
 

403
00:09:12,720 --> 00:09:14,180
the same time so if we were monitoring
the network we'd see two requests

404
00:09:14,180 --> 00:09:14,190
the network we'd see two requests
 

405
00:09:14,190 --> 00:09:16,490
the network we'd see two requests
heading to the server at the same time

406
00:09:16,490 --> 00:09:16,500
heading to the server at the same time
 

407
00:09:16,500 --> 00:09:19,700
heading to the server at the same time
and then sometime later the server would

408
00:09:19,700 --> 00:09:19,710
and then sometime later the server would
 

409
00:09:19,710 --> 00:09:20,510
and then sometime later the server would
respond to them

410
00:09:20,510 --> 00:09:20,520
respond to them
 

411
00:09:20,520 --> 00:09:23,780
respond to them
so there's actually not enough here to

412
00:09:23,780 --> 00:09:23,790
so there's actually not enough here to
 

413
00:09:23,790 --> 00:09:26,060
so there's actually not enough here to
be able to say whether the client would

414
00:09:26,060 --> 00:09:26,070
be able to say whether the client would
 

415
00:09:26,070 --> 00:09:28,520
be able to say whether the client would
receipt would process the first request

416
00:09:28,520 --> 00:09:28,530
receipt would process the first request
 

417
00:09:28,530 --> 00:09:30,770
receipt would process the first request
first which order there's not enough

418
00:09:30,770 --> 00:09:30,780
first which order there's not enough
 

419
00:09:30,780 --> 00:09:32,870
first which order there's not enough
here to tell which order the server

420
00:09:32,870 --> 00:09:32,880
here to tell which order the server
 

421
00:09:32,880 --> 00:09:35,450
here to tell which order the server
processes them in and of course if it

422
00:09:35,450 --> 00:09:35,460
processes them in and of course if it
 

423
00:09:35,460 --> 00:09:38,570
processes them in and of course if it
processes this request first then that

424
00:09:38,570 --> 00:09:38,580
processes this request first then that
 

425
00:09:38,580 --> 00:09:41,750
processes this request first then that
means or it processes the right with

426
00:09:41,750 --> 00:09:41,760
means or it processes the right with
 

427
00:09:41,760 --> 00:09:43,790
means or it processes the right with
value to second and that means that

428
00:09:43,790 --> 00:09:43,800
value to second and that means that
 

429
00:09:43,800 --> 00:09:46,340
value to second and that means that
subsequent reads have to see to where is

430
00:09:46,340 --> 00:09:46,350
subsequent reads have to see to where is
 

431
00:09:46,350 --> 00:09:48,020
subsequent reads have to see to where is
it the server happened to process this

432
00:09:48,020 --> 00:09:48,030
it the server happened to process this
 

433
00:09:48,030 --> 00:09:50,240
it the server happened to process this
request first and this one's second that

434
00:09:50,240 --> 00:09:50,250
request first and this one's second that
 

435
00:09:50,250 --> 00:09:52,010
request first and this one's second that
means the resulting value better be one

436
00:09:52,010 --> 00:09:52,020
means the resulting value better be one
 

437
00:09:52,020 --> 00:09:53,750
means the resulting value better be one
and these these two requests and see

438
00:09:53,750 --> 00:09:53,760
and these these two requests and see
 

439
00:09:53,760 --> 00:09:56,660
and these these two requests and see
what so I'm just putting this up to sort

440
00:09:56,660 --> 00:09:56,670
what so I'm just putting this up to sort
 

441
00:09:56,670 --> 00:09:58,940
what so I'm just putting this up to sort
of illustrate that even in a simple

442
00:09:58,940 --> 00:09:58,950
of illustrate that even in a simple
 

443
00:09:58,950 --> 00:10:01,220
of illustrate that even in a simple
system there's ambiguity you can't

444
00:10:01,220 --> 00:10:01,230
system there's ambiguity you can't
 

445
00:10:01,230 --> 00:10:04,010
system there's ambiguity you can't
necessarily tell from trace of what went

446
00:10:04,010 --> 00:10:04,020
necessarily tell from trace of what went
 

447
00:10:04,020 --> 00:10:05,180
necessarily tell from trace of what went
into the server or what should come out

448
00:10:05,180 --> 00:10:05,190
into the server or what should come out
 

449
00:10:05,190 --> 00:10:08,810
into the server or what should come out
all of you can tell is that some set of

450
00:10:08,810 --> 00:10:08,820
all of you can tell is that some set of
 

451
00:10:08,820 --> 00:10:11,240
all of you can tell is that some set of
results is consistent or not consistent

452
00:10:11,240 --> 00:10:11,250
results is consistent or not consistent
 

453
00:10:11,250 --> 00:10:13,460
results is consistent or not consistent
with a possible execution so certainly

454
00:10:13,460 --> 00:10:13,470
with a possible execution so certainly
 

455
00:10:13,470 --> 00:10:17,840
with a possible execution so certainly
there's some completely wrong results we

456
00:10:17,840 --> 00:10:17,850
there's some completely wrong results we
 

457
00:10:17,850 --> 00:10:21,050
there's some completely wrong results we
can see go by it you know if client 3

458
00:10:21,050 --> 00:10:21,060
can see go by it you know if client 3
 

459
00:10:21,060 --> 00:10:24,020
can see go by it you know if client 3
sees a 2 then client 4 I bet had better

460
00:10:24,020 --> 00:10:24,030
sees a 2 then client 4 I bet had better
 

461
00:10:24,030 --> 00:10:27,200
sees a 2 then client 4 I bet had better
see it too also because our model is

462
00:10:27,200 --> 00:10:27,210
see it too also because our model is
 

463
00:10:27,210 --> 00:10:29,030
see it too also because our model is
well after the second right you know

464
00:10:29,030 --> 00:10:29,040
well after the second right you know
 

465
00:10:29,040 --> 00:10:30,740
well after the second right you know
climb trees these are two that means

466
00:10:30,740 --> 00:10:30,750
climb trees these are two that means
 

467
00:10:30,750 --> 00:10:33,860
climb trees these are two that means
this right must have been second and it

468
00:10:33,860 --> 00:10:33,870
this right must have been second and it
 

469
00:10:33,870 --> 00:10:35,690
this right must have been second and it
still had better be it still has to have

470
00:10:35,690 --> 00:10:35,700
still had better be it still has to have
 

471
00:10:35,700 --> 00:10:37,610
still had better be it still has to have
been the second right one client 4 goes

472
00:10:37,610 --> 00:10:37,620
been the second right one client 4 goes
 

473
00:10:37,620 --> 00:10:41,210
been the second right one client 4 goes
to the date so hopefully all this is

474
00:10:41,210 --> 00:10:41,220
to the date so hopefully all this is
 

475
00:10:41,220 --> 00:10:43,400
to the date so hopefully all this is
just completely straightforward and just

476
00:10:43,400 --> 00:10:43,410
just completely straightforward and just
 

477
00:10:43,410 --> 00:10:47,780
just completely straightforward and just
as expected because it's it's supposed

478
00:10:47,780 --> 00:10:47,790
as expected because it's it's supposed
 

479
00:10:47,790 --> 00:10:49,190
as expected because it's it's supposed
to be the intuitive model of strong

480
00:10:49,190 --> 00:10:49,200
to be the intuitive model of strong
 

481
00:10:49,200 --> 00:10:53,180
to be the intuitive model of strong
consistency ok and so the problem with

482
00:10:53,180 --> 00:10:53,190
consistency ok and so the problem with
 

483
00:10:53,190 --> 00:10:54,290
consistency ok and so the problem with
this of course is that a single server

484
00:10:54,290 --> 00:10:54,300
this of course is that a single server
 

485
00:10:54,300 --> 00:10:56,360
this of course is that a single server
has poor fault tolerance right if it

486
00:10:56,360 --> 00:10:56,370
has poor fault tolerance right if it
 

487
00:10:56,370 --> 00:10:57,830
has poor fault tolerance right if it
crashes or it's disk dies or something

488
00:10:57,830 --> 00:10:57,840
crashes or it's disk dies or something
 

489
00:10:57,840 --> 00:11:00,860
crashes or it's disk dies or something
we're left with nothing and so in the

490
00:11:00,860 --> 00:11:00,870
we're left with nothing and so in the
 

491
00:11:00,870 --> 00:11:02,510
we're left with nothing and so in the
real world of distributed systems we

492
00:11:02,510 --> 00:11:02,520
real world of distributed systems we
 

493
00:11:02,520 --> 00:11:05,420
real world of distributed systems we
actually build replicated systems so and

494
00:11:05,420 --> 00:11:05,430
actually build replicated systems so and
 

495
00:11:05,430 --> 00:11:06,920
actually build replicated systems so and
that's where all the problems start

496
00:11:06,920 --> 00:11:06,930
that's where all the problems start
 

497
00:11:06,930 --> 00:11:08,210
that's where all the problems start
leaking in is when we have a second

498
00:11:08,210 --> 00:11:08,220
leaking in is when we have a second
 

499
00:11:08,220 --> 00:11:12,050
leaking in is when we have a second
copying data so here is what must be

500
00:11:12,050 --> 00:11:12,060
copying data so here is what must be
 

501
00:11:12,060 --> 00:11:16,170
copying data so here is what must be
close to the worst replication design

502
00:11:16,170 --> 00:11:16,180
close to the worst replication design
 

503
00:11:16,180 --> 00:11:19,210
close to the worst replication design
and I'm doing this to warn you of the

504
00:11:19,210 --> 00:11:19,220
and I'm doing this to warn you of the
 

505
00:11:19,220 --> 00:11:20,800
and I'm doing this to warn you of the
problems that we will then be looking

506
00:11:20,800 --> 00:11:20,810
problems that we will then be looking
 

507
00:11:20,810 --> 00:11:23,950
problems that we will then be looking
for in GFS all right so here's a bad

508
00:11:23,950 --> 00:11:23,960
for in GFS all right so here's a bad
 

509
00:11:23,960 --> 00:11:30,370
for in GFS all right so here's a bad
replication design we're gonna have two

510
00:11:30,370 --> 00:11:30,380
replication design we're gonna have two
 

511
00:11:30,380 --> 00:11:32,620
replication design we're gonna have two
servers now each with a complete copy of

512
00:11:32,620 --> 00:11:32,630
servers now each with a complete copy of
 

513
00:11:32,630 --> 00:11:38,500
servers now each with a complete copy of
the data and so on disks that are both

514
00:11:38,500 --> 00:11:38,510
the data and so on disks that are both
 

515
00:11:38,510 --> 00:11:40,720
the data and so on disks that are both
gonna have this this table of keys and

516
00:11:40,720 --> 00:11:40,730
gonna have this this table of keys and
 

517
00:11:40,730 --> 00:11:44,800
gonna have this this table of keys and
values the intuition of course is that

518
00:11:44,800 --> 00:11:44,810
values the intuition of course is that
 

519
00:11:44,810 --> 00:11:47,080
values the intuition of course is that
we want to keep these tables we hope to

520
00:11:47,080 --> 00:11:47,090
we want to keep these tables we hope to
 

521
00:11:47,090 --> 00:11:49,870
we want to keep these tables we hope to
keep these tables identical so that if

522
00:11:49,870 --> 00:11:49,880
keep these tables identical so that if
 

523
00:11:49,880 --> 00:11:51,640
keep these tables identical so that if
one server fails we can read or write

524
00:11:51,640 --> 00:11:51,650
one server fails we can read or write
 

525
00:11:51,650 --> 00:11:53,710
one server fails we can read or write
from the other server and so that means

526
00:11:53,710 --> 00:11:53,720
from the other server and so that means
 

527
00:11:53,720 --> 00:11:55,480
from the other server and so that means
that somehow every write must be

528
00:11:55,480 --> 00:11:55,490
that somehow every write must be
 

529
00:11:55,490 --> 00:11:59,200
that somehow every write must be
processed by both servers and reads have

530
00:11:59,200 --> 00:11:59,210
processed by both servers and reads have
 

531
00:11:59,210 --> 00:12:00,880
processed by both servers and reads have
to be able to be processed by a single

532
00:12:00,880 --> 00:12:00,890
to be able to be processed by a single
 

533
00:12:00,890 --> 00:12:02,560
to be able to be processed by a single
server otherwise it's not fault tolerant

534
00:12:02,560 --> 00:12:02,570
server otherwise it's not fault tolerant
 

535
00:12:02,570 --> 00:12:04,270
server otherwise it's not fault tolerant
all right if reads have to consult both

536
00:12:04,270 --> 00:12:04,280
all right if reads have to consult both
 

537
00:12:04,280 --> 00:12:07,930
all right if reads have to consult both
and we can't survive the loss of one of

538
00:12:07,930 --> 00:12:07,940
and we can't survive the loss of one of
 

539
00:12:07,940 --> 00:12:13,150
and we can't survive the loss of one of
the servers okay so the problem is gonna

540
00:12:13,150 --> 00:12:13,160
the servers okay so the problem is gonna
 

541
00:12:13,160 --> 00:12:17,020
the servers okay so the problem is gonna
come up well I suppose we have client 1

542
00:12:17,020 --> 00:12:17,030
come up well I suppose we have client 1
 

543
00:12:17,030 --> 00:12:19,180
come up well I suppose we have client 1
and client 2 and they both want to do

544
00:12:19,180 --> 00:12:19,190
and client 2 and they both want to do
 

545
00:12:19,190 --> 00:12:20,560
and client 2 and they both want to do
these right say one of them gonna write

546
00:12:20,560 --> 00:12:20,570
these right say one of them gonna write
 

547
00:12:20,570 --> 00:12:22,240
these right say one of them gonna write
one and the other is going to write two

548
00:12:22,240 --> 00:12:22,250
one and the other is going to write two
 

549
00:12:22,250 --> 00:12:25,780
one and the other is going to write two
so client 1 is gonna launch it's right

550
00:12:25,780 --> 00:12:25,790
so client 1 is gonna launch it's right
 

551
00:12:25,790 --> 00:12:29,260
so client 1 is gonna launch it's right
x1 2 both because we want to update both

552
00:12:29,260 --> 00:12:29,270
x1 2 both because we want to update both
 

553
00:12:29,270 --> 00:12:32,590
x1 2 both because we want to update both
of them and climb 2 is gonna launch it's

554
00:12:32,590 --> 00:12:32,600
of them and climb 2 is gonna launch it's
 

555
00:12:32,600 --> 00:12:41,790
of them and climb 2 is gonna launch it's
write X so what's gonna go wrong here

556
00:12:41,790 --> 00:12:41,800
write X so what's gonna go wrong here
 

557
00:12:41,800 --> 00:12:46,270
write X so what's gonna go wrong here
yeah yeah we haven't done anything here

558
00:12:46,270 --> 00:12:46,280
yeah yeah we haven't done anything here
 

559
00:12:46,280 --> 00:12:48,400
yeah yeah we haven't done anything here
to ensure that the two servers process

560
00:12:48,400 --> 00:12:48,410
to ensure that the two servers process
 

561
00:12:48,410 --> 00:12:51,580
to ensure that the two servers process
the two requests in the same order right

562
00:12:51,580 --> 00:12:51,590
the two requests in the same order right
 

563
00:12:51,590 --> 00:12:53,920
the two requests in the same order right
that's a bad design

564
00:12:53,920 --> 00:12:53,930
that's a bad design
 

565
00:12:53,930 --> 00:12:57,790
that's a bad design
so if server 1 processes client ones

566
00:12:57,790 --> 00:12:57,800
so if server 1 processes client ones
 

567
00:12:57,800 --> 00:13:01,090
so if server 1 processes client ones
request first it'll end up it'll start

568
00:13:01,090 --> 00:13:01,100
request first it'll end up it'll start
 

569
00:13:01,100 --> 00:13:02,590
request first it'll end up it'll start
with a value of 1 and then it'll see

570
00:13:02,590 --> 00:13:02,600
with a value of 1 and then it'll see
 

571
00:13:02,600 --> 00:13:04,600
with a value of 1 and then it'll see
client twos request and overwrite that

572
00:13:04,600 --> 00:13:04,610
client twos request and overwrite that
 

573
00:13:04,610 --> 00:13:07,600
client twos request and overwrite that
with 2 if server 2 just happens to

574
00:13:07,600 --> 00:13:07,610
with 2 if server 2 just happens to
 

575
00:13:07,610 --> 00:13:09,340
with 2 if server 2 just happens to
receive the packets over the network in

576
00:13:09,340 --> 00:13:09,350
receive the packets over the network in
 

577
00:13:09,350 --> 00:13:11,010
receive the packets over the network in
a different order it's going to execute

578
00:13:11,010 --> 00:13:11,020
a different order it's going to execute
 

579
00:13:11,020 --> 00:13:13,300
a different order it's going to execute
client 2's requests and set the value to

580
00:13:13,300 --> 00:13:13,310
client 2's requests and set the value to
 

581
00:13:13,310 --> 00:13:15,340
client 2's requests and set the value to
2 and then then it will see client ones

582
00:13:15,340 --> 00:13:15,350
2 and then then it will see client ones
 

583
00:13:15,350 --> 00:13:18,130
2 and then then it will see client ones
request set the value to 1 and now what

584
00:13:18,130 --> 00:13:18,140
request set the value to 1 and now what
 

585
00:13:18,140 --> 00:13:20,440
request set the value to 1 and now what
a client a later reading client sees you

586
00:13:20,440 --> 00:13:20,450
a client a later reading client sees you
 

587
00:13:20,450 --> 00:13:22,750
a client a later reading client sees you
know if client 3 happens to reach from

588
00:13:22,750 --> 00:13:22,760
know if client 3 happens to reach from
 

589
00:13:22,760 --> 00:13:25,510
know if client 3 happens to reach from
this server and client for happens to

590
00:13:25,510 --> 00:13:25,520
this server and client for happens to
 

591
00:13:25,520 --> 00:13:26,710
this server and client for happens to
reach from the other server then we get

592
00:13:26,710 --> 00:13:26,720
reach from the other server then we get
 

593
00:13:26,720 --> 00:13:28,600
reach from the other server then we get
into this terrible situation where

594
00:13:28,600 --> 00:13:28,610
into this terrible situation where
 

595
00:13:28,610 --> 00:13:30,310
into this terrible situation where
they're gonna read different values even

596
00:13:30,310 --> 00:13:30,320
they're gonna read different values even
 

597
00:13:30,320 --> 00:13:33,400
they're gonna read different values even
though our intuitive model of a correct

598
00:13:33,400 --> 00:13:33,410
though our intuitive model of a correct
 

599
00:13:33,410 --> 00:13:35,980
though our intuitive model of a correct
service says they both subsequent reads

600
00:13:35,980 --> 00:13:35,990
service says they both subsequent reads
 

601
00:13:35,990 --> 00:13:39,579
service says they both subsequent reads
hefty you're the same value and this can

602
00:13:39,579 --> 00:13:39,589
hefty you're the same value and this can
 

603
00:13:39,589 --> 00:13:41,920
hefty you're the same value and this can
arise in other ways you know suppose we

604
00:13:41,920 --> 00:13:41,930
arise in other ways you know suppose we
 

605
00:13:41,930 --> 00:13:43,569
arise in other ways you know suppose we
try to fix this by making the clients

606
00:13:43,569 --> 00:13:43,579
try to fix this by making the clients
 

607
00:13:43,579 --> 00:13:45,910
try to fix this by making the clients
always read from server one if it's up

608
00:13:45,910 --> 00:13:45,920
always read from server one if it's up
 

609
00:13:45,920 --> 00:13:48,819
always read from server one if it's up
and otherwise server two if we do that

610
00:13:48,819 --> 00:13:48,829
and otherwise server two if we do that
 

611
00:13:48,829 --> 00:13:51,340
and otherwise server two if we do that
then if this situation happened and four

612
00:13:51,340 --> 00:13:51,350
then if this situation happened and four
 

613
00:13:51,350 --> 00:13:53,079
then if this situation happened and four
why oh yeah both everybody reads might

614
00:13:53,079 --> 00:13:53,089
why oh yeah both everybody reads might
 

615
00:13:53,089 --> 00:13:55,269
why oh yeah both everybody reads might
see client might see value too but a

616
00:13:55,269 --> 00:13:55,279
see client might see value too but a
 

617
00:13:55,279 --> 00:13:57,639
see client might see value too but a
server one suddenly fails then even

618
00:13:57,639 --> 00:13:57,649
server one suddenly fails then even
 

619
00:13:57,649 --> 00:14:00,280
server one suddenly fails then even
though there was no right suddenly the

620
00:14:00,280 --> 00:14:00,290
though there was no right suddenly the
 

621
00:14:00,290 --> 00:14:02,040
though there was no right suddenly the
value for X we'll switch from 2 to 1

622
00:14:02,040 --> 00:14:02,050
value for X we'll switch from 2 to 1
 

623
00:14:02,050 --> 00:14:04,840
value for X we'll switch from 2 to 1
because if server 1 died it's all the

624
00:14:04,840 --> 00:14:04,850
because if server 1 died it's all the
 

625
00:14:04,850 --> 00:14:07,120
because if server 1 died it's all the
clients assistant server 2 no but just

626
00:14:07,120 --> 00:14:07,130
clients assistant server 2 no but just
 

627
00:14:07,130 --> 00:14:09,069
clients assistant server 2 no but just
this mysterious change in the data that

628
00:14:09,069 --> 00:14:09,079
this mysterious change in the data that
 

629
00:14:09,079 --> 00:14:11,560
this mysterious change in the data that
doesn't correspond to any right which is

630
00:14:11,560 --> 00:14:11,570
doesn't correspond to any right which is
 

631
00:14:11,570 --> 00:14:13,180
doesn't correspond to any right which is
also totally not something that could

632
00:14:13,180 --> 00:14:13,190
also totally not something that could
 

633
00:14:13,190 --> 00:14:15,670
also totally not something that could
have happened in this service simple

634
00:14:15,670 --> 00:14:15,680
have happened in this service simple
 

635
00:14:15,680 --> 00:14:23,319
have happened in this service simple
server model all right so of course this

636
00:14:23,319 --> 00:14:23,329
server model all right so of course this
 

637
00:14:23,329 --> 00:14:25,930
server model all right so of course this
can be fixed the fix requires more

638
00:14:25,930 --> 00:14:25,940
can be fixed the fix requires more
 

639
00:14:25,940 --> 00:14:28,210
can be fixed the fix requires more
communication usually between the

640
00:14:28,210 --> 00:14:28,220
communication usually between the
 

641
00:14:28,220 --> 00:14:33,519
communication usually between the
servers or somewhere more complexity and

642
00:14:33,519 --> 00:14:33,529
servers or somewhere more complexity and
 

643
00:14:33,529 --> 00:14:36,639
servers or somewhere more complexity and
because of the cost of inevitable cost

644
00:14:36,639 --> 00:14:36,649
because of the cost of inevitable cost
 

645
00:14:36,649 --> 00:14:37,810
because of the cost of inevitable cost
to the complexity to get strong

646
00:14:37,810 --> 00:14:37,820
to the complexity to get strong
 

647
00:14:37,820 --> 00:14:41,170
to the complexity to get strong
consistency there's a whole range of

648
00:14:41,170 --> 00:14:41,180
consistency there's a whole range of
 

649
00:14:41,180 --> 00:14:43,600
consistency there's a whole range of
different solutions to get better

650
00:14:43,600 --> 00:14:43,610
different solutions to get better
 

651
00:14:43,610 --> 00:14:45,759
different solutions to get better
consistency and a whole range of what

652
00:14:45,759 --> 00:14:45,769
consistency and a whole range of what
 

653
00:14:45,769 --> 00:14:48,340
consistency and a whole range of what
people feel is an acceptable level of

654
00:14:48,340 --> 00:14:48,350
people feel is an acceptable level of
 

655
00:14:48,350 --> 00:14:52,240
people feel is an acceptable level of
consistency in an acceptable sort of a

656
00:14:52,240 --> 00:14:52,250
consistency in an acceptable sort of a
 

657
00:14:52,250 --> 00:14:54,880
consistency in an acceptable sort of a
set of anomalous behaviors that might be

658
00:14:54,880 --> 00:14:54,890
set of anomalous behaviors that might be
 

659
00:14:54,890 --> 00:14:57,550
set of anomalous behaviors that might be
revealed all right any questions about

660
00:14:57,550 --> 00:14:57,560
revealed all right any questions about
 

661
00:14:57,560 --> 00:15:04,639
revealed all right any questions about
this disastrous model here

662
00:15:04,639 --> 00:15:04,649

 

663
00:15:04,649 --> 00:15:07,769

okay that's what you're talking about

664
00:15:07,769 --> 00:15:07,779
okay that's what you're talking about
 

665
00:15:07,779 --> 00:15:13,199
okay that's what you're talking about
GFS a lot of thought about doing GFS was

666
00:15:13,199 --> 00:15:13,209
GFS a lot of thought about doing GFS was
 

667
00:15:13,209 --> 00:15:17,069
GFS a lot of thought about doing GFS was
doing is fixing this they had better but

668
00:15:17,069 --> 00:15:17,079
doing is fixing this they had better but
 

669
00:15:17,079 --> 00:15:21,780
doing is fixing this they had better but
not perfect behavior okay so where GFS

670
00:15:21,780 --> 00:15:21,790
not perfect behavior okay so where GFS
 

671
00:15:21,790 --> 00:15:24,169
not perfect behavior okay so where GFS
came from in 2003 quite a while ago

672
00:15:24,169 --> 00:15:24,179
came from in 2003 quite a while ago
 

673
00:15:24,179 --> 00:15:27,720
came from in 2003 quite a while ago
actually at that time the the web you

674
00:15:27,720 --> 00:15:27,730
actually at that time the the web you
 

675
00:15:27,730 --> 00:15:29,369
actually at that time the the web you
know was certainly starting to be a very

676
00:15:29,369 --> 00:15:29,379
know was certainly starting to be a very
 

677
00:15:29,379 --> 00:15:31,559
know was certainly starting to be a very
big deal and people are building big

678
00:15:31,559 --> 00:15:31,569
big deal and people are building big
 

679
00:15:31,569 --> 00:15:35,429
big deal and people are building big
websites in addition there had been

680
00:15:35,429 --> 00:15:35,439
websites in addition there had been
 

681
00:15:35,439 --> 00:15:37,530
websites in addition there had been
decades of research into distributed

682
00:15:37,530 --> 00:15:37,540
decades of research into distributed
 

683
00:15:37,540 --> 00:15:38,999
decades of research into distributed
systems and people sort of knew at least

684
00:15:38,999 --> 00:15:39,009
systems and people sort of knew at least
 

685
00:15:39,009 --> 00:15:40,499
systems and people sort of knew at least
at the academic level how to build all

686
00:15:40,499 --> 00:15:40,509
at the academic level how to build all
 

687
00:15:40,509 --> 00:15:43,109
at the academic level how to build all
kinds of highly parallel fault tolerant

688
00:15:43,109 --> 00:15:43,119
kinds of highly parallel fault tolerant
 

689
00:15:43,119 --> 00:15:44,729
kinds of highly parallel fault tolerant
whatever systems but there been very

690
00:15:44,729 --> 00:15:44,739
whatever systems but there been very
 

691
00:15:44,739 --> 00:15:49,579
whatever systems but there been very
little use of academic ideas in industry

692
00:15:49,579 --> 00:15:49,589
little use of academic ideas in industry
 

693
00:15:49,589 --> 00:15:52,229
little use of academic ideas in industry
but starting at around the time this

694
00:15:52,229 --> 00:15:52,239
but starting at around the time this
 

695
00:15:52,239 --> 00:15:54,749
but starting at around the time this
paper was published big websites like

696
00:15:54,749 --> 00:15:54,759
paper was published big websites like
 

697
00:15:54,759 --> 00:15:57,389
paper was published big websites like
Google started to actually build serious

698
00:15:57,389 --> 00:15:57,399
Google started to actually build serious
 

699
00:15:57,399 --> 00:16:01,559
Google started to actually build serious
distributed systems and it was like very

700
00:16:01,559 --> 00:16:01,569
distributed systems and it was like very
 

701
00:16:01,569 --> 00:16:03,689
distributed systems and it was like very
exciting for people like me who were I'm

702
00:16:03,689 --> 00:16:03,699
exciting for people like me who were I'm
 

703
00:16:03,699 --> 00:16:06,869
exciting for people like me who were I'm
a kid I'm excited this to see see real

704
00:16:06,869 --> 00:16:06,879
a kid I'm excited this to see see real
 

705
00:16:06,879 --> 00:16:10,109
a kid I'm excited this to see see real
uses of these ideas where Google was

706
00:16:10,109 --> 00:16:10,119
uses of these ideas where Google was
 

707
00:16:10,119 --> 00:16:11,759
uses of these ideas where Google was
coming from was you know they had some

708
00:16:11,759 --> 00:16:11,769
coming from was you know they had some
 

709
00:16:11,769 --> 00:16:14,460
coming from was you know they had some
vast vast data sets far larger than

710
00:16:14,460 --> 00:16:14,470
vast vast data sets far larger than
 

711
00:16:14,470 --> 00:16:16,350
vast vast data sets far larger than
could be stored in a single disk like an

712
00:16:16,350 --> 00:16:16,360
could be stored in a single disk like an
 

713
00:16:16,360 --> 00:16:20,759
could be stored in a single disk like an
entire crawl copy of the web or a little

714
00:16:20,759 --> 00:16:20,769
entire crawl copy of the web or a little
 

715
00:16:20,769 --> 00:16:22,109
entire crawl copy of the web or a little
bit after this paper they had giant

716
00:16:22,109 --> 00:16:22,119
bit after this paper they had giant
 

717
00:16:22,119 --> 00:16:25,470
bit after this paper they had giant
YouTube videos they had things like the

718
00:16:25,470 --> 00:16:25,480
YouTube videos they had things like the
 

719
00:16:25,480 --> 00:16:27,659
YouTube videos they had things like the
intermedia files for building a search

720
00:16:27,659 --> 00:16:27,669
intermedia files for building a search
 

721
00:16:27,669 --> 00:16:28,289
intermedia files for building a search
index

722
00:16:28,289 --> 00:16:28,299
index
 

723
00:16:28,299 --> 00:16:30,780
index
they also apparently kept enormous log

724
00:16:30,780 --> 00:16:30,790
they also apparently kept enormous log
 

725
00:16:30,790 --> 00:16:32,669
they also apparently kept enormous log
files from all their web servers so they

726
00:16:32,669 --> 00:16:32,679
files from all their web servers so they
 

727
00:16:32,679 --> 00:16:34,019
files from all their web servers so they
could later analyze them so they had

728
00:16:34,019 --> 00:16:34,029
could later analyze them so they had
 

729
00:16:34,029 --> 00:16:36,900
could later analyze them so they had
some big big data sets they used both to

730
00:16:36,900 --> 00:16:36,910
some big big data sets they used both to
 

731
00:16:36,910 --> 00:16:39,329
some big big data sets they used both to
store them and many many disks to store

732
00:16:39,329 --> 00:16:39,339
store them and many many disks to store
 

733
00:16:39,339 --> 00:16:41,129
store them and many many disks to store
them and they needed to be able to

734
00:16:41,129 --> 00:16:41,139
them and they needed to be able to
 

735
00:16:41,139 --> 00:16:42,389
them and they needed to be able to
process them quickly with things like

736
00:16:42,389 --> 00:16:42,399
process them quickly with things like
 

737
00:16:42,399 --> 00:16:44,699
process them quickly with things like
MapReduce so they needed high speed

738
00:16:44,699 --> 00:16:44,709
MapReduce so they needed high speed
 

739
00:16:44,709 --> 00:16:47,519
MapReduce so they needed high speed
parallel access to these vast amounts of

740
00:16:47,519 --> 00:16:47,529
parallel access to these vast amounts of
 

741
00:16:47,529 --> 00:16:51,809
parallel access to these vast amounts of
data okay so what they were looking for

742
00:16:51,809 --> 00:16:51,819
data okay so what they were looking for
 

743
00:16:51,819 --> 00:16:53,659
data okay so what they were looking for
one goal was just that the thing be big

744
00:16:53,659 --> 00:16:53,669
one goal was just that the thing be big
 

745
00:16:53,669 --> 00:16:59,999
one goal was just that the thing be big
and fast they also wanted a file system

746
00:16:59,999 --> 00:17:00,009
and fast they also wanted a file system
 

747
00:17:00,009 --> 00:17:02,460
and fast they also wanted a file system
that was sort of global in the sense

748
00:17:02,460 --> 00:17:02,470
that was sort of global in the sense
 

749
00:17:02,470 --> 00:17:04,139
that was sort of global in the sense
that many different applications could

750
00:17:04,139 --> 00:17:04,149
that many different applications could
 

751
00:17:04,149 --> 00:17:06,480
that many different applications could
get at it one way to build a big storage

752
00:17:06,480 --> 00:17:06,490
get at it one way to build a big storage
 

753
00:17:06,490 --> 00:17:07,980
get at it one way to build a big storage
system is to you know you have some

754
00:17:07,980 --> 00:17:07,990
system is to you know you have some
 

755
00:17:07,990 --> 00:17:09,389
system is to you know you have some
particular application or mining you

756
00:17:09,389 --> 00:17:09,399
particular application or mining you
 

757
00:17:09,399 --> 00:17:11,250
particular application or mining you
build storage sort of dedicated and

758
00:17:11,250 --> 00:17:11,260
build storage sort of dedicated and
 

759
00:17:11,260 --> 00:17:13,110
build storage sort of dedicated and
tailored to that application and if

760
00:17:13,110 --> 00:17:13,120
tailored to that application and if
 

761
00:17:13,120 --> 00:17:14,819
tailored to that application and if
somebody else in the next office needs

762
00:17:14,819 --> 00:17:14,829
somebody else in the next office needs
 

763
00:17:14,829 --> 00:17:17,069
somebody else in the next office needs
big storage well they can build their

764
00:17:17,069 --> 00:17:17,079
big storage well they can build their
 

765
00:17:17,079 --> 00:17:17,670
big storage well they can build their
own thing

766
00:17:17,670 --> 00:17:17,680
own thing
 

767
00:17:17,680 --> 00:17:21,090
own thing
right but if you have a universal or

768
00:17:21,090 --> 00:17:21,100
right but if you have a universal or
 

769
00:17:21,100 --> 00:17:25,290
right but if you have a universal or
kind of global reusable storage system

770
00:17:25,290 --> 00:17:25,300
kind of global reusable storage system
 

771
00:17:25,300 --> 00:17:28,020
kind of global reusable storage system
and that means that if I store a huge

772
00:17:28,020 --> 00:17:28,030
and that means that if I store a huge
 

773
00:17:28,030 --> 00:17:29,700
and that means that if I store a huge
amount of data si you know I'm crawling

774
00:17:29,700 --> 00:17:29,710
amount of data si you know I'm crawling
 

775
00:17:29,710 --> 00:17:31,590
amount of data si you know I'm crawling
the web and you want to look at my

776
00:17:31,590 --> 00:17:31,600
the web and you want to look at my
 

777
00:17:31,600 --> 00:17:35,280
the web and you want to look at my
crawled web web pages because we're all

778
00:17:35,280 --> 00:17:35,290
crawled web web pages because we're all
 

779
00:17:35,290 --> 00:17:36,570
crawled web web pages because we're all
using we're all playing in the same

780
00:17:36,570 --> 00:17:36,580
using we're all playing in the same
 

781
00:17:36,580 --> 00:17:38,730
using we're all playing in the same
sandbox we're all using the same storage

782
00:17:38,730 --> 00:17:38,740
sandbox we're all using the same storage
 

783
00:17:38,740 --> 00:17:40,740
sandbox we're all using the same storage
system you can just read my files you

784
00:17:40,740 --> 00:17:40,750
system you can just read my files you
 

785
00:17:40,750 --> 00:17:43,470
system you can just read my files you
know maybe access controls permitting so

786
00:17:43,470 --> 00:17:43,480
know maybe access controls permitting so
 

787
00:17:43,480 --> 00:17:45,180
know maybe access controls permitting so
the idea was to build a sort of file

788
00:17:45,180 --> 00:17:45,190
the idea was to build a sort of file
 

789
00:17:45,190 --> 00:17:47,100
the idea was to build a sort of file
system where anybody you know anybody

790
00:17:47,100 --> 00:17:47,110
system where anybody you know anybody
 

791
00:17:47,110 --> 00:17:50,070
system where anybody you know anybody
inside Google could name and read any of

792
00:17:50,070 --> 00:17:50,080
inside Google could name and read any of
 

793
00:17:50,080 --> 00:17:57,000
inside Google could name and read any of
the files to allow sharing in order to

794
00:17:57,000 --> 00:17:57,010
the files to allow sharing in order to
 

795
00:17:57,010 --> 00:17:58,530
the files to allow sharing in order to
get a in order to get bigness and

796
00:17:58,530 --> 00:17:58,540
get a in order to get bigness and
 

797
00:17:58,540 --> 00:18:00,290
get a in order to get bigness and
fastness they need to split the data

798
00:18:00,290 --> 00:18:00,300
fastness they need to split the data
 

799
00:18:00,300 --> 00:18:04,980
fastness they need to split the data
through every file will be automatically

800
00:18:04,980 --> 00:18:04,990
through every file will be automatically
 

801
00:18:04,990 --> 00:18:07,890
through every file will be automatically
split by GFS over many servers so that

802
00:18:07,890 --> 00:18:07,900
split by GFS over many servers so that
 

803
00:18:07,900 --> 00:18:08,940
split by GFS over many servers so that
writes and reads would just

804
00:18:08,940 --> 00:18:08,950
writes and reads would just
 

805
00:18:08,950 --> 00:18:10,770
writes and reads would just
automatically be fast as long as you

806
00:18:10,770 --> 00:18:10,780
automatically be fast as long as you
 

807
00:18:10,780 --> 00:18:12,720
automatically be fast as long as you
were reading from lots and lots of

808
00:18:12,720 --> 00:18:12,730
were reading from lots and lots of
 

809
00:18:12,730 --> 00:18:14,760
were reading from lots and lots of
reading a file from lots of clients you

810
00:18:14,760 --> 00:18:14,770
reading a file from lots of clients you
 

811
00:18:14,770 --> 00:18:17,850
reading a file from lots of clients you
get high aggregate throughput and also

812
00:18:17,850 --> 00:18:17,860
get high aggregate throughput and also
 

813
00:18:17,860 --> 00:18:20,220
get high aggregate throughput and also
be able to for a single file be able to

814
00:18:20,220 --> 00:18:20,230
be able to for a single file be able to
 

815
00:18:20,230 --> 00:18:21,660
be able to for a single file be able to
have single files that were bigger than

816
00:18:21,660 --> 00:18:21,670
have single files that were bigger than
 

817
00:18:21,670 --> 00:18:24,720
have single files that were bigger than
any single disk because we're building

818
00:18:24,720 --> 00:18:24,730
any single disk because we're building
 

819
00:18:24,730 --> 00:18:26,160
any single disk because we're building
something out of hundreds of servers we

820
00:18:26,160 --> 00:18:26,170
something out of hundreds of servers we
 

821
00:18:26,170 --> 00:18:36,420
something out of hundreds of servers we
want automatic feel your recovery we

822
00:18:36,420 --> 00:18:36,430
want automatic feel your recovery we
 

823
00:18:36,430 --> 00:18:37,470
want automatic feel your recovery we
don't want to build a system where every

824
00:18:37,470 --> 00:18:37,480
don't want to build a system where every
 

825
00:18:37,480 --> 00:18:38,850
don't want to build a system where every
time one of our hundreds of servers a

826
00:18:38,850 --> 00:18:38,860
time one of our hundreds of servers a
 

827
00:18:38,860 --> 00:18:40,530
time one of our hundreds of servers a
fail some human being has to go to the

828
00:18:40,530 --> 00:18:40,540
fail some human being has to go to the
 

829
00:18:40,540 --> 00:18:42,480
fail some human being has to go to the
machine room and do something with the

830
00:18:42,480 --> 00:18:42,490
machine room and do something with the
 

831
00:18:42,490 --> 00:18:44,820
machine room and do something with the
server or to get it up and running or

832
00:18:44,820 --> 00:18:44,830
server or to get it up and running or
 

833
00:18:44,830 --> 00:18:46,860
server or to get it up and running or
transfers data or something well this

834
00:18:46,860 --> 00:18:46,870
transfers data or something well this
 

835
00:18:46,870 --> 00:18:50,120
transfers data or something well this
isn't just fix itself um there were some

836
00:18:50,120 --> 00:18:50,130
isn't just fix itself um there were some
 

837
00:18:50,130 --> 00:18:54,360
isn't just fix itself um there were some
sort of non goals like one is that GFS

838
00:18:54,360 --> 00:18:54,370
sort of non goals like one is that GFS
 

839
00:18:54,370 --> 00:18:55,920
sort of non goals like one is that GFS
was designed to run in a single data

840
00:18:55,920 --> 00:18:55,930
was designed to run in a single data
 

841
00:18:55,930 --> 00:18:57,330
was designed to run in a single data
center so we're not talking about

842
00:18:57,330 --> 00:18:57,340
center so we're not talking about
 

843
00:18:57,340 --> 00:18:59,940
center so we're not talking about
placing replicas all over the world a

844
00:18:59,940 --> 00:18:59,950
placing replicas all over the world a
 

845
00:18:59,950 --> 00:19:02,400
placing replicas all over the world a
single GFS installation just lived in

846
00:19:02,400 --> 00:19:02,410
single GFS installation just lived in
 

847
00:19:02,410 --> 00:19:05,190
single GFS installation just lived in
one one data center one big machine run

848
00:19:05,190 --> 00:19:05,200
one one data center one big machine run
 

849
00:19:05,200 --> 00:19:12,180
one one data center one big machine run
so getting this style system to work

850
00:19:12,180 --> 00:19:12,190
so getting this style system to work
 

851
00:19:12,190 --> 00:19:14,850
so getting this style system to work
where the replicas are far distant from

852
00:19:14,850 --> 00:19:14,860
where the replicas are far distant from
 

853
00:19:14,860 --> 00:19:17,540
where the replicas are far distant from
each other is a valuable goal but

854
00:19:17,540 --> 00:19:17,550
each other is a valuable goal but
 

855
00:19:17,550 --> 00:19:22,710
each other is a valuable goal but
difficult so single data centers this is

856
00:19:22,710 --> 00:19:22,720
difficult so single data centers this is
 

857
00:19:22,720 --> 00:19:25,530
difficult so single data centers this is
not a service to customers GFS was for

858
00:19:25,530 --> 00:19:25,540
not a service to customers GFS was for
 

859
00:19:25,540 --> 00:19:27,910
not a service to customers GFS was for
internal use by

860
00:19:27,910 --> 00:19:27,920
internal use by
 

861
00:19:27,920 --> 00:19:30,200
internal use by
applications written by Google engineers

862
00:19:30,200 --> 00:19:30,210
applications written by Google engineers
 

863
00:19:30,210 --> 00:19:32,390
applications written by Google engineers
so it wasn't they weren't directly

864
00:19:32,390 --> 00:19:32,400
so it wasn't they weren't directly
 

865
00:19:32,400 --> 00:19:33,800
so it wasn't they weren't directly
selling this they might be selling

866
00:19:33,800 --> 00:19:33,810
selling this they might be selling
 

867
00:19:33,810 --> 00:19:37,160
selling this they might be selling
services they used GFS internally but

868
00:19:37,160 --> 00:19:37,170
services they used GFS internally but
 

869
00:19:37,170 --> 00:19:38,510
services they used GFS internally but
they weren't selling it directly so it's

870
00:19:38,510 --> 00:19:38,520
they weren't selling it directly so it's
 

871
00:19:38,520 --> 00:19:45,650
they weren't selling it directly so it's
just for internal use and it was

872
00:19:45,650 --> 00:19:45,660
just for internal use and it was
 

873
00:19:45,660 --> 00:19:48,620
just for internal use and it was
tailored in a number of ways for big

874
00:19:48,620 --> 00:19:48,630
tailored in a number of ways for big
 

875
00:19:48,630 --> 00:19:51,170
tailored in a number of ways for big
sequential file reads and writes there's

876
00:19:51,170 --> 00:19:51,180
sequential file reads and writes there's
 

877
00:19:51,180 --> 00:19:54,170
sequential file reads and writes there's
a whole nother domain like a system of

878
00:19:54,170 --> 00:19:54,180
a whole nother domain like a system of
 

879
00:19:54,180 --> 00:19:56,480
a whole nother domain like a system of
storage systems that are optimized for

880
00:19:56,480 --> 00:19:56,490
storage systems that are optimized for
 

881
00:19:56,490 --> 00:19:58,580
storage systems that are optimized for
small pieces of data like a bank that's

882
00:19:58,580 --> 00:19:58,590
small pieces of data like a bank that's
 

883
00:19:58,590 --> 00:20:00,080
small pieces of data like a bank that's
holding bank balances probably wants a

884
00:20:00,080 --> 00:20:00,090
holding bank balances probably wants a
 

885
00:20:00,090 --> 00:20:02,090
holding bank balances probably wants a
database that can read and write an

886
00:20:02,090 --> 00:20:02,100
database that can read and write an
 

887
00:20:02,100 --> 00:20:04,370
database that can read and write an
update you know 100 byte records that

888
00:20:04,370 --> 00:20:04,380
update you know 100 byte records that
 

889
00:20:04,380 --> 00:20:07,220
update you know 100 byte records that
hold people's bank balances but GFS is

890
00:20:07,220 --> 00:20:07,230
hold people's bank balances but GFS is
 

891
00:20:07,230 --> 00:20:10,220
hold people's bank balances but GFS is
not that system so it's really for big

892
00:20:10,220 --> 00:20:10,230
not that system so it's really for big
 

893
00:20:10,230 --> 00:20:12,590
not that system so it's really for big
or big is you know terabytes gigabytes

894
00:20:12,590 --> 00:20:12,600
or big is you know terabytes gigabytes
 

895
00:20:12,600 --> 00:20:22,630
or big is you know terabytes gigabytes
some big sequential not random access

896
00:20:22,630 --> 00:20:22,640

 

897
00:20:22,640 --> 00:20:24,680

it's also that has a certain batch

898
00:20:24,680 --> 00:20:24,690
it's also that has a certain batch
 

899
00:20:24,690 --> 00:20:26,330
it's also that has a certain batch
flavor there's not a huge amount of

900
00:20:26,330 --> 00:20:26,340
flavor there's not a huge amount of
 

901
00:20:26,340 --> 00:20:27,830
flavor there's not a huge amount of
effort to make access be very low

902
00:20:27,830 --> 00:20:27,840
effort to make access be very low
 

903
00:20:27,840 --> 00:20:29,990
effort to make access be very low
latency the focus is really on

904
00:20:29,990 --> 00:20:30,000
latency the focus is really on
 

905
00:20:30,000 --> 00:20:32,870
latency the focus is really on
throughput of big you know multi

906
00:20:32,870 --> 00:20:32,880
throughput of big you know multi
 

907
00:20:32,880 --> 00:20:36,770
throughput of big you know multi
megabyte operations this paper was

908
00:20:36,770 --> 00:20:36,780
megabyte operations this paper was
 

909
00:20:36,780 --> 00:20:39,550
megabyte operations this paper was
published at s OSP in 2003 the top

910
00:20:39,550 --> 00:20:39,560
published at s OSP in 2003 the top
 

911
00:20:39,560 --> 00:20:46,850
published at s OSP in 2003 the top
systems academic conference yeah usually

912
00:20:46,850 --> 00:20:46,860
systems academic conference yeah usually
 

913
00:20:46,860 --> 00:20:49,070
systems academic conference yeah usually
the standard for papers such conferences

914
00:20:49,070 --> 00:20:49,080
the standard for papers such conferences
 

915
00:20:49,080 --> 00:20:51,250
the standard for papers such conferences
they have you know a lot of very novel

916
00:20:51,250 --> 00:20:51,260
they have you know a lot of very novel
 

917
00:20:51,260 --> 00:20:54,050
they have you know a lot of very novel
research this paper was not necessarily

918
00:20:54,050 --> 00:20:54,060
research this paper was not necessarily
 

919
00:20:54,060 --> 00:20:55,910
research this paper was not necessarily
in that class the specific ideas in this

920
00:20:55,910 --> 00:20:55,920
in that class the specific ideas in this
 

921
00:20:55,920 --> 00:20:57,740
in that class the specific ideas in this
paper none of them are particularly new

922
00:20:57,740 --> 00:20:57,750
paper none of them are particularly new
 

923
00:20:57,750 --> 00:21:00,980
paper none of them are particularly new
at the time and things like distribution

924
00:21:00,980 --> 00:21:00,990
at the time and things like distribution
 

925
00:21:00,990 --> 00:21:02,500
at the time and things like distribution
and sharding and fault tolerance were

926
00:21:02,500 --> 00:21:02,510
and sharding and fault tolerance were
 

927
00:21:02,510 --> 00:21:05,330
and sharding and fault tolerance were
you know well understood had to had to

928
00:21:05,330 --> 00:21:05,340
you know well understood had to had to
 

929
00:21:05,340 --> 00:21:07,610
you know well understood had to had to
deliver those but this paper described a

930
00:21:07,610 --> 00:21:07,620
deliver those but this paper described a
 

931
00:21:07,620 --> 00:21:09,470
deliver those but this paper described a
system that was really operating in in

932
00:21:09,470 --> 00:21:09,480
system that was really operating in in
 

933
00:21:09,480 --> 00:21:11,960
system that was really operating in in
use at a far far larger scale hundreds

934
00:21:11,960 --> 00:21:11,970
use at a far far larger scale hundreds
 

935
00:21:11,970 --> 00:21:13,670
use at a far far larger scale hundreds
of thousands of machines much bigger

936
00:21:13,670 --> 00:21:13,680
of thousands of machines much bigger
 

937
00:21:13,680 --> 00:21:16,390
of thousands of machines much bigger
than any you know academics ever built

938
00:21:16,390 --> 00:21:16,400
than any you know academics ever built
 

939
00:21:16,400 --> 00:21:18,950
than any you know academics ever built
the fact that it was used in industry

940
00:21:18,950 --> 00:21:18,960
the fact that it was used in industry
 

941
00:21:18,960 --> 00:21:21,440
the fact that it was used in industry
and reflected real world experience of

942
00:21:21,440 --> 00:21:21,450
and reflected real world experience of
 

943
00:21:21,450 --> 00:21:23,360
and reflected real world experience of
like what actually didn't didn't work

944
00:21:23,360 --> 00:21:23,370
like what actually didn't didn't work
 

945
00:21:23,370 --> 00:21:25,480
like what actually didn't didn't work
for deployed systems that had to work

946
00:21:25,480 --> 00:21:25,490
for deployed systems that had to work
 

947
00:21:25,490 --> 00:21:28,940
for deployed systems that had to work
and had to be cost effective also like

948
00:21:28,940 --> 00:21:28,950
and had to be cost effective also like
 

949
00:21:28,950 --> 00:21:34,070
and had to be cost effective also like
extremely valuable the paper sort of

950
00:21:34,070 --> 00:21:34,080
extremely valuable the paper sort of
 

951
00:21:34,080 --> 00:21:39,080
extremely valuable the paper sort of
proposed a fairly heretical view that it

952
00:21:39,080 --> 00:21:39,090
proposed a fairly heretical view that it
 

953
00:21:39,090 --> 00:21:40,790
proposed a fairly heretical view that it
was okay for the storage system to have

954
00:21:40,790 --> 00:21:40,800
was okay for the storage system to have
 

955
00:21:40,800 --> 00:21:41,260
was okay for the storage system to have
pretty

956
00:21:41,260 --> 00:21:41,270
pretty
 

957
00:21:41,270 --> 00:21:45,430
pretty
consistency we the academic mindset at

958
00:21:45,430 --> 00:21:45,440
consistency we the academic mindset at
 

959
00:21:45,440 --> 00:21:46,540
consistency we the academic mindset at
that time was the you know the storage

960
00:21:46,540 --> 00:21:46,550
that time was the you know the storage
 

961
00:21:46,550 --> 00:21:47,770
that time was the you know the storage
system really should have good behavior

962
00:21:47,770 --> 00:21:47,780
system really should have good behavior
 

963
00:21:47,780 --> 00:21:48,820
system really should have good behavior
like what's the point of building

964
00:21:48,820 --> 00:21:48,830
like what's the point of building
 

965
00:21:48,830 --> 00:21:50,770
like what's the point of building
systems that sort of return the wrong

966
00:21:50,770 --> 00:21:50,780
systems that sort of return the wrong
 

967
00:21:50,780 --> 00:21:53,740
systems that sort of return the wrong
data like my terrible replication system

968
00:21:53,740 --> 00:21:53,750
data like my terrible replication system
 

969
00:21:53,750 --> 00:21:55,390
data like my terrible replication system
like why do that why not build systems

970
00:21:55,390 --> 00:21:55,400
like why do that why not build systems
 

971
00:21:55,400 --> 00:21:57,010
like why do that why not build systems
return the right data correct data

972
00:21:57,010 --> 00:21:57,020
return the right data correct data
 

973
00:21:57,020 --> 00:21:59,230
return the right data correct data
instead of incorrect data now with this

974
00:21:59,230 --> 00:21:59,240
instead of incorrect data now with this
 

975
00:21:59,240 --> 00:22:02,560
instead of incorrect data now with this
paper actually does not guarantee return

976
00:22:02,560 --> 00:22:02,570
paper actually does not guarantee return
 

977
00:22:02,570 --> 00:22:05,950
paper actually does not guarantee return
correct data and you know the hope is

978
00:22:05,950 --> 00:22:05,960
correct data and you know the hope is
 

979
00:22:05,960 --> 00:22:07,120
correct data and you know the hope is
that they take advantage of that in

980
00:22:07,120 --> 00:22:07,130
that they take advantage of that in
 

981
00:22:07,130 --> 00:22:09,430
that they take advantage of that in
order to get better performance I'm a

982
00:22:09,430 --> 00:22:09,440
order to get better performance I'm a
 

983
00:22:09,440 --> 00:22:11,890
order to get better performance I'm a
final thing that was sort of interesting

984
00:22:11,890 --> 00:22:11,900
final thing that was sort of interesting
 

985
00:22:11,900 --> 00:22:13,570
final thing that was sort of interesting
about this paper is its use of a single

986
00:22:13,570 --> 00:22:13,580
about this paper is its use of a single
 

987
00:22:13,580 --> 00:22:16,360
about this paper is its use of a single
master in a sort of academic paper you

988
00:22:16,360 --> 00:22:16,370
master in a sort of academic paper you
 

989
00:22:16,370 --> 00:22:18,010
master in a sort of academic paper you
probably have some fault-tolerant

990
00:22:18,010 --> 00:22:18,020
probably have some fault-tolerant
 

991
00:22:18,020 --> 00:22:20,890
probably have some fault-tolerant
replicated automatic failure recovering

992
00:22:20,890 --> 00:22:20,900
replicated automatic failure recovering
 

993
00:22:20,900 --> 00:22:24,100
replicated automatic failure recovering
master perhaps many masters with the

994
00:22:24,100 --> 00:22:24,110
master perhaps many masters with the
 

995
00:22:24,110 --> 00:22:25,540
master perhaps many masters with the
work split open um but this paper said

996
00:22:25,540 --> 00:22:25,550
work split open um but this paper said
 

997
00:22:25,550 --> 00:22:26,950
work split open um but this paper said
look you know you they can get away with

998
00:22:26,950 --> 00:22:26,960
look you know you they can get away with
 

999
00:22:26,960 --> 00:22:39,250
look you know you they can get away with
a single master and it worked fine well

1000
00:22:39,250 --> 00:22:39,260
a single master and it worked fine well
 

1001
00:22:39,260 --> 00:22:40,600
a single master and it worked fine well
cynically you know who's going to notice

1002
00:22:40,600 --> 00:22:40,610
cynically you know who's going to notice
 

1003
00:22:40,610 --> 00:22:43,000
cynically you know who's going to notice
on the web that some vote count or

1004
00:22:43,000 --> 00:22:43,010
on the web that some vote count or
 

1005
00:22:43,010 --> 00:22:44,910
on the web that some vote count or
something is wrong or if you do a search

1006
00:22:44,910 --> 00:22:44,920
something is wrong or if you do a search
 

1007
00:22:44,920 --> 00:22:47,500
something is wrong or if you do a search
on a search engine now you're gonna know

1008
00:22:47,500 --> 00:22:47,510
on a search engine now you're gonna know
 

1009
00:22:47,510 --> 00:22:50,470
on a search engine now you're gonna know
that oh you know like one of 20,000

1010
00:22:50,470 --> 00:22:50,480
that oh you know like one of 20,000
 

1011
00:22:50,480 --> 00:22:51,880
that oh you know like one of 20,000
items is missing from the search results

1012
00:22:51,880 --> 00:22:51,890
items is missing from the search results
 

1013
00:22:51,890 --> 00:22:54,850
items is missing from the search results
or they're in the wrong order probably

1014
00:22:54,850 --> 00:22:54,860
or they're in the wrong order probably
 

1015
00:22:54,860 --> 00:22:58,120
or they're in the wrong order probably
not so there was just much more

1016
00:22:58,120 --> 00:22:58,130
not so there was just much more
 

1017
00:22:58,130 --> 00:22:59,500
not so there was just much more
tolerance in these kind of systems than

1018
00:22:59,500 --> 00:22:59,510
tolerance in these kind of systems than
 

1019
00:22:59,510 --> 00:23:02,200
tolerance in these kind of systems than
there would like in a bank for incorrect

1020
00:23:02,200 --> 00:23:02,210
there would like in a bank for incorrect
 

1021
00:23:02,210 --> 00:23:04,060
there would like in a bank for incorrect
data it doesn't mean that all data and

1022
00:23:04,060 --> 00:23:04,070
data it doesn't mean that all data and
 

1023
00:23:04,070 --> 00:23:05,620
data it doesn't mean that all data and
websites can be wrong like if you're

1024
00:23:05,620 --> 00:23:05,630
websites can be wrong like if you're
 

1025
00:23:05,630 --> 00:23:07,870
websites can be wrong like if you're
charging people for ad impressions you

1026
00:23:07,870 --> 00:23:07,880
charging people for ad impressions you
 

1027
00:23:07,880 --> 00:23:09,880
charging people for ad impressions you
better get the numbers right but this is

1028
00:23:09,880 --> 00:23:09,890
better get the numbers right but this is
 

1029
00:23:09,890 --> 00:23:15,820
better get the numbers right but this is
not really about that in addition some

1030
00:23:15,820 --> 00:23:15,830
not really about that in addition some
 

1031
00:23:15,830 --> 00:23:18,360
not really about that in addition some
of the ways in which GFS could serve up

1032
00:23:18,360 --> 00:23:18,370
of the ways in which GFS could serve up
 

1033
00:23:18,370 --> 00:23:21,760
of the ways in which GFS could serve up
odd data could be compensated for in the

1034
00:23:21,760 --> 00:23:21,770
odd data could be compensated for in the
 

1035
00:23:21,770 --> 00:23:23,530
odd data could be compensated for in the
applications like where the paper says

1036
00:23:23,530 --> 00:23:23,540
applications like where the paper says
 

1037
00:23:23,540 --> 00:23:25,480
applications like where the paper says
you know applications should accompany

1038
00:23:25,480 --> 00:23:25,490
you know applications should accompany
 

1039
00:23:25,490 --> 00:23:28,030
you know applications should accompany
their data with check sums and clearly

1040
00:23:28,030 --> 00:23:28,040
their data with check sums and clearly
 

1041
00:23:28,040 --> 00:23:30,250
their data with check sums and clearly
mark record boundaries that's so the

1042
00:23:30,250 --> 00:23:30,260
mark record boundaries that's so the
 

1043
00:23:30,260 --> 00:23:32,370
mark record boundaries that's so the
applications can recover from GFS

1044
00:23:32,370 --> 00:23:32,380
applications can recover from GFS
 

1045
00:23:32,380 --> 00:23:35,470
applications can recover from GFS
serving them maybe not quite the right

1046
00:23:35,470 --> 00:23:35,480
serving them maybe not quite the right
 

1047
00:23:35,480 --> 00:23:40,960
serving them maybe not quite the right
data

1048
00:23:40,960 --> 00:23:40,970

 

1049
00:23:40,970 --> 00:23:44,720

all right so the general structure and

1050
00:23:44,720 --> 00:23:44,730
all right so the general structure and
 

1051
00:23:44,730 --> 00:23:48,830
all right so the general structure and
this is just figure one in the paper so

1052
00:23:48,830 --> 00:23:48,840
this is just figure one in the paper so
 

1053
00:23:48,840 --> 00:23:53,840
this is just figure one in the paper so
we have a bunch of clients hundreds

1054
00:23:53,840 --> 00:23:53,850
we have a bunch of clients hundreds
 

1055
00:23:53,850 --> 00:23:59,440
we have a bunch of clients hundreds
hundreds of clients we have one master

1056
00:23:59,440 --> 00:23:59,450

 

1057
00:23:59,450 --> 00:24:02,030

although there might be replicas of the

1058
00:24:02,030 --> 00:24:02,040
although there might be replicas of the
 

1059
00:24:02,040 --> 00:24:07,130
although there might be replicas of the
master the master keeps the mapping from

1060
00:24:07,130 --> 00:24:07,140
master the master keeps the mapping from
 

1061
00:24:07,140 --> 00:24:09,500
master the master keeps the mapping from
file names to where to find the data

1062
00:24:09,500 --> 00:24:09,510
file names to where to find the data
 

1063
00:24:09,510 --> 00:24:10,970
file names to where to find the data
basically although there's really two

1064
00:24:10,970 --> 00:24:10,980
basically although there's really two
 

1065
00:24:10,980 --> 00:24:14,090
basically although there's really two
tables so and then there's a bunch of

1066
00:24:14,090 --> 00:24:14,100
tables so and then there's a bunch of
 

1067
00:24:14,100 --> 00:24:18,380
tables so and then there's a bunch of
chunk servers maybe hundreds of chunk

1068
00:24:18,380 --> 00:24:18,390
chunk servers maybe hundreds of chunk
 

1069
00:24:18,390 --> 00:24:21,080
chunk servers maybe hundreds of chunk
servers each with perhaps one or two

1070
00:24:21,080 --> 00:24:21,090
servers each with perhaps one or two
 

1071
00:24:21,090 --> 00:24:23,630
servers each with perhaps one or two
discs the separation here's the master

1072
00:24:23,630 --> 00:24:23,640
discs the separation here's the master
 

1073
00:24:23,640 --> 00:24:25,310
discs the separation here's the master
is all about naming and knowing where

1074
00:24:25,310 --> 00:24:25,320
is all about naming and knowing where
 

1075
00:24:25,320 --> 00:24:27,470
is all about naming and knowing where
the chunks are and the chunk servers

1076
00:24:27,470 --> 00:24:27,480
the chunks are and the chunk servers
 

1077
00:24:27,480 --> 00:24:29,390
the chunks are and the chunk servers
store the actual data this is like a

1078
00:24:29,390 --> 00:24:29,400
store the actual data this is like a
 

1079
00:24:29,400 --> 00:24:31,010
store the actual data this is like a
nice aspect of the design that these two

1080
00:24:31,010 --> 00:24:31,020
nice aspect of the design that these two
 

1081
00:24:31,020 --> 00:24:32,750
nice aspect of the design that these two
concerns are almost completely separated

1082
00:24:32,750 --> 00:24:32,760
concerns are almost completely separated
 

1083
00:24:32,760 --> 00:24:35,870
concerns are almost completely separated
from each other and can be designed just

1084
00:24:35,870 --> 00:24:35,880
from each other and can be designed just
 

1085
00:24:35,880 --> 00:24:41,690
from each other and can be designed just
separately with separate properties the

1086
00:24:41,690 --> 00:24:41,700
separately with separate properties the
 

1087
00:24:41,700 --> 00:24:43,160
separately with separate properties the
master knows about all the files for

1088
00:24:43,160 --> 00:24:43,170
master knows about all the files for
 

1089
00:24:43,170 --> 00:24:44,960
master knows about all the files for
every file the master keeps track of a

1090
00:24:44,960 --> 00:24:44,970
every file the master keeps track of a
 

1091
00:24:44,970 --> 00:24:48,250
every file the master keeps track of a
list of chunks chunk identifiers that

1092
00:24:48,250 --> 00:24:48,260
list of chunks chunk identifiers that
 

1093
00:24:48,260 --> 00:24:50,870
list of chunks chunk identifiers that
contain the successive pieces that file

1094
00:24:50,870 --> 00:24:50,880
contain the successive pieces that file
 

1095
00:24:50,880 --> 00:24:53,390
contain the successive pieces that file
each chunk is 64 megabytes so if I have

1096
00:24:53,390 --> 00:24:53,400
each chunk is 64 megabytes so if I have
 

1097
00:24:53,400 --> 00:24:57,080
each chunk is 64 megabytes so if I have
a you know gigabyte file the master is

1098
00:24:57,080 --> 00:24:57,090
a you know gigabyte file the master is
 

1099
00:24:57,090 --> 00:24:58,580
a you know gigabyte file the master is
gonna know that maybe the first chunk is

1100
00:24:58,580 --> 00:24:58,590
gonna know that maybe the first chunk is
 

1101
00:24:58,590 --> 00:25:00,049
gonna know that maybe the first chunk is
stored here and the second chunk is

1102
00:25:00,049 --> 00:25:00,059
stored here and the second chunk is
 

1103
00:25:00,059 --> 00:25:01,549
stored here and the second chunk is
stored here the third chunk is stored

1104
00:25:01,549 --> 00:25:01,559
stored here the third chunk is stored
 

1105
00:25:01,559 --> 00:25:03,770
stored here the third chunk is stored
here and if I want to read whatever part

1106
00:25:03,770 --> 00:25:03,780
here and if I want to read whatever part
 

1107
00:25:03,780 --> 00:25:05,480
here and if I want to read whatever part
of the file I need to ask the master oh

1108
00:25:05,480 --> 00:25:05,490
of the file I need to ask the master oh
 

1109
00:25:05,490 --> 00:25:07,250
of the file I need to ask the master oh
which server hole is that chunk and I go

1110
00:25:07,250 --> 00:25:07,260
which server hole is that chunk and I go
 

1111
00:25:07,260 --> 00:25:08,990
which server hole is that chunk and I go
talk to that server and read the chunk

1112
00:25:08,990 --> 00:25:09,000
talk to that server and read the chunk
 

1113
00:25:09,000 --> 00:25:17,120
talk to that server and read the chunk
roughly speaking all right so more

1114
00:25:17,120 --> 00:25:17,130
roughly speaking all right so more
 

1115
00:25:17,130 --> 00:25:21,140
roughly speaking all right so more
precisely we need to turns out if we're

1116
00:25:21,140 --> 00:25:21,150
precisely we need to turns out if we're
 

1117
00:25:21,150 --> 00:25:23,180
precisely we need to turns out if we're
going to talk about how the system about

1118
00:25:23,180 --> 00:25:23,190
going to talk about how the system about
 

1119
00:25:23,190 --> 00:25:24,680
going to talk about how the system about
the consistency of the system and how it

1120
00:25:24,680 --> 00:25:24,690
the consistency of the system and how it
 

1121
00:25:24,690 --> 00:25:27,350
the consistency of the system and how it
deals with false we need to know what

1122
00:25:27,350 --> 00:25:27,360
deals with false we need to know what
 

1123
00:25:27,360 --> 00:25:29,090
deals with false we need to know what
the master is actually storing in a

1124
00:25:29,090 --> 00:25:29,100
the master is actually storing in a
 

1125
00:25:29,100 --> 00:25:31,760
the master is actually storing in a
little bit more detail so the master

1126
00:25:31,760 --> 00:25:31,770
little bit more detail so the master
 

1127
00:25:31,770 --> 00:25:36,180
little bit more detail so the master
data

1128
00:25:36,180 --> 00:25:36,190

 

1129
00:25:36,190 --> 00:25:38,890

it's got two main tables that we care

1130
00:25:38,890 --> 00:25:38,900
it's got two main tables that we care
 

1131
00:25:38,900 --> 00:25:41,350
it's got two main tables that we care
about it's got one table that map's file

1132
00:25:41,350 --> 00:25:41,360
about it's got one table that map's file
 

1133
00:25:41,360 --> 00:25:52,450
about it's got one table that map's file
name to an array of chunk IDs or chunk

1134
00:25:52,450 --> 00:25:52,460
name to an array of chunk IDs or chunk
 

1135
00:25:52,460 --> 00:26:00,820
name to an array of chunk IDs or chunk
handles this just tells you where to

1136
00:26:00,820 --> 00:26:00,830
handles this just tells you where to
 

1137
00:26:00,830 --> 00:26:03,040
handles this just tells you where to
find the data or what the what the

1138
00:26:03,040 --> 00:26:03,050
find the data or what the what the
 

1139
00:26:03,050 --> 00:26:05,020
find the data or what the what the
identifiers are the chunks are so it's

1140
00:26:05,020 --> 00:26:05,030
identifiers are the chunks are so it's
 

1141
00:26:05,030 --> 00:26:06,610
identifiers are the chunks are so it's
not much yet you can do with a chunk

1142
00:26:06,610 --> 00:26:06,620
not much yet you can do with a chunk
 

1143
00:26:06,620 --> 00:26:08,830
not much yet you can do with a chunk
identifier but the master also happens

1144
00:26:08,830 --> 00:26:08,840
identifier but the master also happens
 

1145
00:26:08,840 --> 00:26:11,430
identifier but the master also happens
to have a a second table that map's

1146
00:26:11,430 --> 00:26:11,440
to have a a second table that map's
 

1147
00:26:11,440 --> 00:26:17,560
to have a a second table that map's
chunk handles each chunk handle to a

1148
00:26:17,560 --> 00:26:17,570
chunk handles each chunk handle to a
 

1149
00:26:17,570 --> 00:26:21,100
chunk handles each chunk handle to a
bunch of data about that chunk so one is

1150
00:26:21,100 --> 00:26:21,110
bunch of data about that chunk so one is
 

1151
00:26:21,110 --> 00:26:23,320
bunch of data about that chunk so one is
the list of chunk servers that hold

1152
00:26:23,320 --> 00:26:23,330
the list of chunk servers that hold
 

1153
00:26:23,330 --> 00:26:25,890
the list of chunk servers that hold
replicas of that data each chunk is

1154
00:26:25,890 --> 00:26:25,900
replicas of that data each chunk is
 

1155
00:26:25,900 --> 00:26:28,030
replicas of that data each chunk is
stored on more than one chunk server so

1156
00:26:28,030 --> 00:26:28,040
stored on more than one chunk server so
 

1157
00:26:28,040 --> 00:26:39,640
stored on more than one chunk server so
it's a list chunk servers every chunk

1158
00:26:39,640 --> 00:26:39,650
it's a list chunk servers every chunk
 

1159
00:26:39,650 --> 00:26:42,390
it's a list chunk servers every chunk
has a current version number so this

1160
00:26:42,390 --> 00:26:42,400
has a current version number so this
 

1161
00:26:42,400 --> 00:26:46,600
has a current version number so this
master has a remembers the version

1162
00:26:46,600 --> 00:26:46,610
master has a remembers the version
 

1163
00:26:46,610 --> 00:26:50,140
master has a remembers the version
number for each chunk all rights for a

1164
00:26:50,140 --> 00:26:50,150
number for each chunk all rights for a
 

1165
00:26:50,150 --> 00:26:51,940
number for each chunk all rights for a
chunk have to be sequence ooh the chunks

1166
00:26:51,940 --> 00:26:51,950
chunk have to be sequence ooh the chunks
 

1167
00:26:51,950 --> 00:26:54,900
chunk have to be sequence ooh the chunks
primary it's one of the replicas so

1168
00:26:54,900 --> 00:26:54,910
primary it's one of the replicas so
 

1169
00:26:54,910 --> 00:26:58,870
primary it's one of the replicas so
master remembers the rich chunk servers

1170
00:26:58,870 --> 00:26:58,880
master remembers the rich chunk servers
 

1171
00:26:58,880 --> 00:27:00,970
master remembers the rich chunk servers
the primary and there's also that

1172
00:27:00,970 --> 00:27:00,980
the primary and there's also that
 

1173
00:27:00,980 --> 00:27:02,560
the primary and there's also that
primary is only allowed to be primary

1174
00:27:02,560 --> 00:27:02,570
primary is only allowed to be primary
 

1175
00:27:02,570 --> 00:27:05,440
primary is only allowed to be primary
for a certain least time so the master

1176
00:27:05,440 --> 00:27:05,450
for a certain least time so the master
 

1177
00:27:05,450 --> 00:27:13,360
for a certain least time so the master
remembers the expiration time of the

1178
00:27:13,360 --> 00:27:13,370
remembers the expiration time of the
 

1179
00:27:13,370 --> 00:27:17,230
remembers the expiration time of the
lease this stuff so far it's all in RAM

1180
00:27:17,230 --> 00:27:17,240
lease this stuff so far it's all in RAM
 

1181
00:27:17,240 --> 00:27:19,660
lease this stuff so far it's all in RAM
and the master so just be gone if the

1182
00:27:19,660 --> 00:27:19,670
and the master so just be gone if the
 

1183
00:27:19,670 --> 00:27:24,520
and the master so just be gone if the
master crashed so in order that you'd be

1184
00:27:24,520 --> 00:27:24,530
master crashed so in order that you'd be
 

1185
00:27:24,530 --> 00:27:26,560
master crashed so in order that you'd be
able to reboot the master and not forget

1186
00:27:26,560 --> 00:27:26,570
able to reboot the master and not forget
 

1187
00:27:26,570 --> 00:27:29,140
able to reboot the master and not forget
everything about the file system the

1188
00:27:29,140 --> 00:27:29,150
everything about the file system the
 

1189
00:27:29,150 --> 00:27:30,700
everything about the file system the
master actually stores all of this data

1190
00:27:30,700 --> 00:27:30,710
master actually stores all of this data
 

1191
00:27:30,710 --> 00:27:35,170
master actually stores all of this data
on disk as well as in memory so reads

1192
00:27:35,170 --> 00:27:35,180
on disk as well as in memory so reads
 

1193
00:27:35,180 --> 00:27:38,260
on disk as well as in memory so reads
just come from memory but writes to at

1194
00:27:38,260 --> 00:27:38,270
just come from memory but writes to at
 

1195
00:27:38,270 --> 00:27:40,480
just come from memory but writes to at
least the parts of this data that had to

1196
00:27:40,480 --> 00:27:40,490
least the parts of this data that had to
 

1197
00:27:40,490 --> 00:27:42,130
least the parts of this data that had to
be reflected on this writes have to go

1198
00:27:42,130 --> 00:27:42,140
be reflected on this writes have to go
 

1199
00:27:42,140 --> 00:27:45,490
be reflected on this writes have to go
to the disk so and the way it actually

1200
00:27:45,490 --> 00:27:45,500
to the disk so and the way it actually
 

1201
00:27:45,500 --> 00:27:47,500
to the disk so and the way it actually
managed that is that there's all

1202
00:27:47,500 --> 00:27:47,510
managed that is that there's all
 

1203
00:27:47,510 --> 00:27:51,280
managed that is that there's all
the master has a log on disk and every

1204
00:27:51,280 --> 00:27:51,290
the master has a log on disk and every
 

1205
00:27:51,290 --> 00:27:53,740
the master has a log on disk and every
time it changes the data it appends an

1206
00:27:53,740 --> 00:27:53,750
time it changes the data it appends an
 

1207
00:27:53,750 --> 00:28:04,470
time it changes the data it appends an
entry to the log on disk and checkpoint

1208
00:28:04,470 --> 00:28:04,480

 

1209
00:28:04,480 --> 00:28:07,210

so some of this stuff actually needs to

1210
00:28:07,210 --> 00:28:07,220
so some of this stuff actually needs to
 

1211
00:28:07,220 --> 00:28:10,590
so some of this stuff actually needs to
be on disk and some doesn't it turns out

1212
00:28:10,590 --> 00:28:10,600
be on disk and some doesn't it turns out
 

1213
00:28:10,600 --> 00:28:12,970
be on disk and some doesn't it turns out
I'm guessing a little bit here but

1214
00:28:12,970 --> 00:28:12,980
I'm guessing a little bit here but
 

1215
00:28:12,980 --> 00:28:16,180
I'm guessing a little bit here but
certainly the array of chunk handles has

1216
00:28:16,180 --> 00:28:16,190
certainly the array of chunk handles has
 

1217
00:28:16,190 --> 00:28:18,040
certainly the array of chunk handles has
to be on disk and so I'm gonna write env

1218
00:28:18,040 --> 00:28:18,050
to be on disk and so I'm gonna write env
 

1219
00:28:18,050 --> 00:28:20,500
to be on disk and so I'm gonna write env
here for non-volatile meaning it it's

1220
00:28:20,500 --> 00:28:20,510
here for non-volatile meaning it it's
 

1221
00:28:20,510 --> 00:28:22,840
here for non-volatile meaning it it's
got to be reflected on disk the list of

1222
00:28:22,840 --> 00:28:22,850
got to be reflected on disk the list of
 

1223
00:28:22,850 --> 00:28:25,600
got to be reflected on disk the list of
chunk servers it turns out doesn't

1224
00:28:25,600 --> 00:28:25,610
chunk servers it turns out doesn't
 

1225
00:28:25,610 --> 00:28:28,360
chunk servers it turns out doesn't
because the master if it reboots talks

1226
00:28:28,360 --> 00:28:28,370
because the master if it reboots talks
 

1227
00:28:28,370 --> 00:28:29,710
because the master if it reboots talks
to all the chunk servers and ask them

1228
00:28:29,710 --> 00:28:29,720
to all the chunk servers and ask them
 

1229
00:28:29,720 --> 00:28:32,700
to all the chunk servers and ask them
what chunks they have so this is I

1230
00:28:32,700 --> 00:28:32,710
what chunks they have so this is I
 

1231
00:28:32,710 --> 00:28:36,280
what chunks they have so this is I
imagine not written to disk the version

1232
00:28:36,280 --> 00:28:36,290
imagine not written to disk the version
 

1233
00:28:36,290 --> 00:28:38,440
imagine not written to disk the version
number any guesses written to disk not

1234
00:28:38,440 --> 00:28:38,450
number any guesses written to disk not
 

1235
00:28:38,450 --> 00:28:42,940
number any guesses written to disk not
written to disk requires knowing how the

1236
00:28:42,940 --> 00:28:42,950
written to disk requires knowing how the
 

1237
00:28:42,950 --> 00:28:51,820
written to disk requires knowing how the
system works I'm gonna vote written to

1238
00:28:51,820 --> 00:28:51,830
system works I'm gonna vote written to
 

1239
00:28:51,830 --> 00:28:55,780
system works I'm gonna vote written to
disk non-volatile we can argue about

1240
00:28:55,780 --> 00:28:55,790
disk non-volatile we can argue about
 

1241
00:28:55,790 --> 00:28:57,490
disk non-volatile we can argue about
that later when we talk about how system

1242
00:28:57,490 --> 00:28:57,500
that later when we talk about how system
 

1243
00:28:57,500 --> 00:29:04,780
that later when we talk about how system
works identity the primary it turns out

1244
00:29:04,780 --> 00:29:04,790
works identity the primary it turns out
 

1245
00:29:04,790 --> 00:29:06,550
works identity the primary it turns out
not almost certainly not written to disk

1246
00:29:06,550 --> 00:29:06,560
not almost certainly not written to disk
 

1247
00:29:06,560 --> 00:29:10,630
not almost certainly not written to disk
so volatile and the reason is the master

1248
00:29:10,630 --> 00:29:10,640
so volatile and the reason is the master
 

1249
00:29:10,640 --> 00:29:13,000
so volatile and the reason is the master
is um reboots and forgets therefore

1250
00:29:13,000 --> 00:29:13,010
is um reboots and forgets therefore
 

1251
00:29:13,010 --> 00:29:15,670
is um reboots and forgets therefore
since it's volatile forgets who the

1252
00:29:15,670 --> 00:29:15,680
since it's volatile forgets who the
 

1253
00:29:15,680 --> 00:29:17,320
since it's volatile forgets who the
primary is for a chunk it can simply

1254
00:29:17,320 --> 00:29:17,330
primary is for a chunk it can simply
 

1255
00:29:17,330 --> 00:29:19,900
primary is for a chunk it can simply
wait for the 62nd lease expiration time

1256
00:29:19,900 --> 00:29:19,910
wait for the 62nd lease expiration time
 

1257
00:29:19,910 --> 00:29:21,910
wait for the 62nd lease expiration time
and then it knows that absolutely no

1258
00:29:21,910 --> 00:29:21,920
and then it knows that absolutely no
 

1259
00:29:21,920 --> 00:29:23,530
and then it knows that absolutely no
primary will be functioning for this

1260
00:29:23,530 --> 00:29:23,540
primary will be functioning for this
 

1261
00:29:23,540 --> 00:29:24,910
primary will be functioning for this
chunk and then it can designate a

1262
00:29:24,910 --> 00:29:24,920
chunk and then it can designate a
 

1263
00:29:24,920 --> 00:29:27,010
chunk and then it can designate a
different primary safely and similarly

1264
00:29:27,010 --> 00:29:27,020
different primary safely and similarly
 

1265
00:29:27,020 --> 00:29:29,650
different primary safely and similarly
the lease expiration stuff is volatile

1266
00:29:29,650 --> 00:29:29,660
the lease expiration stuff is volatile
 

1267
00:29:29,660 --> 00:29:32,830
the lease expiration stuff is volatile
so that means that whenever a file is

1268
00:29:32,830 --> 00:29:32,840
so that means that whenever a file is
 

1269
00:29:32,840 --> 00:29:35,020
so that means that whenever a file is
extended with a new chunk goes to the

1270
00:29:35,020 --> 00:29:35,030
extended with a new chunk goes to the
 

1271
00:29:35,030 --> 00:29:40,090
extended with a new chunk goes to the
next 64 megabyte boundary or the version

1272
00:29:40,090 --> 00:29:40,100
next 64 megabyte boundary or the version
 

1273
00:29:40,100 --> 00:29:42,700
next 64 megabyte boundary or the version
number changes because the new primary

1274
00:29:42,700 --> 00:29:42,710
number changes because the new primary
 

1275
00:29:42,710 --> 00:29:45,730
number changes because the new primary
is designated that means that the master

1276
00:29:45,730 --> 00:29:45,740
is designated that means that the master
 

1277
00:29:45,740 --> 00:29:48,430
is designated that means that the master
has to first append a little record to

1278
00:29:48,430 --> 00:29:48,440
has to first append a little record to
 

1279
00:29:48,440 --> 00:29:50,890
has to first append a little record to
his log basically saying oh I just added

1280
00:29:50,890 --> 00:29:50,900
his log basically saying oh I just added
 

1281
00:29:50,900 --> 00:29:53,500
his log basically saying oh I just added
a such-and-such a chunk to this file or

1282
00:29:53,500 --> 00:29:53,510
a such-and-such a chunk to this file or
 

1283
00:29:53,510 --> 00:29:56,410
a such-and-such a chunk to this file or
I just changed the version number so

1284
00:29:56,410 --> 00:29:56,420
I just changed the version number so
 

1285
00:29:56,420 --> 00:29:57,520
I just changed the version number so
every time I change is one of those that

1286
00:29:57,520 --> 00:29:57,530
every time I change is one of those that
 

1287
00:29:57,530 --> 00:29:59,350
every time I change is one of those that
needs to writes right it's disk so this

1288
00:29:59,350 --> 00:29:59,360
needs to writes right it's disk so this
 

1289
00:29:59,360 --> 00:30:00,820
needs to writes right it's disk so this
is paper doesn't talk about this

1290
00:30:00,820 --> 00:30:00,830
is paper doesn't talk about this
 

1291
00:30:00,830 --> 00:30:02,860
is paper doesn't talk about this
much but you know there's limits the

1292
00:30:02,860 --> 00:30:02,870
much but you know there's limits the
 

1293
00:30:02,870 --> 00:30:05,080
much but you know there's limits the
rate at which the master can change

1294
00:30:05,080 --> 00:30:05,090
rate at which the master can change
 

1295
00:30:05,090 --> 00:30:07,029
rate at which the master can change
things because you can only write your

1296
00:30:07,029 --> 00:30:07,039
things because you can only write your
 

1297
00:30:07,039 --> 00:30:09,330
things because you can only write your
disk however many times per second and

1298
00:30:09,330 --> 00:30:09,340
disk however many times per second and
 

1299
00:30:09,340 --> 00:30:12,940
disk however many times per second and
the reason for using a log rather than a

1300
00:30:12,940 --> 00:30:12,950
the reason for using a log rather than a
 

1301
00:30:12,950 --> 00:30:16,269
the reason for using a log rather than a
database you know some sort of b-tree or

1302
00:30:16,269 --> 00:30:16,279
database you know some sort of b-tree or
 

1303
00:30:16,279 --> 00:30:20,169
database you know some sort of b-tree or
hash table on disk is that you can

1304
00:30:20,169 --> 00:30:20,179
hash table on disk is that you can
 

1305
00:30:20,179 --> 00:30:24,000
hash table on disk is that you can
append to a log very efficiently because

1306
00:30:24,000 --> 00:30:24,010

 

1307
00:30:24,010 --> 00:30:26,590

you only need you can take a bunch of

1308
00:30:26,590 --> 00:30:26,600
you only need you can take a bunch of
 

1309
00:30:26,600 --> 00:30:28,299
you only need you can take a bunch of
recent log records they need to be added

1310
00:30:28,299 --> 00:30:28,309
recent log records they need to be added
 

1311
00:30:28,309 --> 00:30:29,529
recent log records they need to be added
and sort of write them all on a single

1312
00:30:29,529 --> 00:30:29,539
and sort of write them all on a single
 

1313
00:30:29,539 --> 00:30:32,139
and sort of write them all on a single
write after a single rotation to

1314
00:30:32,139 --> 00:30:32,149
write after a single rotation to
 

1315
00:30:32,149 --> 00:30:33,639
write after a single rotation to
whatever the point in the disk is that

1316
00:30:33,639 --> 00:30:33,649
whatever the point in the disk is that
 

1317
00:30:33,649 --> 00:30:36,070
whatever the point in the disk is that
contains the end of the log file whereas

1318
00:30:36,070 --> 00:30:36,080
contains the end of the log file whereas
 

1319
00:30:36,080 --> 00:30:38,889
contains the end of the log file whereas
if it were a sort of b-tree reflecting

1320
00:30:38,889 --> 00:30:38,899
if it were a sort of b-tree reflecting
 

1321
00:30:38,899 --> 00:30:42,070
if it were a sort of b-tree reflecting
the real structure of this data then you

1322
00:30:42,070 --> 00:30:42,080
the real structure of this data then you
 

1323
00:30:42,080 --> 00:30:43,360
the real structure of this data then you
would have to seek to a random place in

1324
00:30:43,360 --> 00:30:43,370
would have to seek to a random place in
 

1325
00:30:43,370 --> 00:30:45,159
would have to seek to a random place in
the disk and do a little right so the

1326
00:30:45,159 --> 00:30:45,169
the disk and do a little right so the
 

1327
00:30:45,169 --> 00:30:46,509
the disk and do a little right so the
log makes a little bit faster to write

1328
00:30:46,509 --> 00:30:46,519
log makes a little bit faster to write
 

1329
00:30:46,519 --> 00:30:51,610
log makes a little bit faster to write
there to reflect operations on to the

1330
00:30:51,610 --> 00:30:51,620
there to reflect operations on to the
 

1331
00:30:51,620 --> 00:30:56,560
there to reflect operations on to the
disk however if the master crashes and

1332
00:30:56,560 --> 00:30:56,570
disk however if the master crashes and
 

1333
00:30:56,570 --> 00:30:58,779
disk however if the master crashes and
has to reconstruct its state you

1334
00:30:58,779 --> 00:30:58,789
has to reconstruct its state you
 

1335
00:30:58,789 --> 00:31:00,399
has to reconstruct its state you
wouldn't want to have to reread its log

1336
00:31:00,399 --> 00:31:00,409
wouldn't want to have to reread its log
 

1337
00:31:00,409 --> 00:31:02,560
wouldn't want to have to reread its log
file back starting from the beginning of

1338
00:31:02,560 --> 00:31:02,570
file back starting from the beginning of
 

1339
00:31:02,570 --> 00:31:04,149
file back starting from the beginning of
time from when the server was first

1340
00:31:04,149 --> 00:31:04,159
time from when the server was first
 

1341
00:31:04,159 --> 00:31:06,549
time from when the server was first
installed you know a few years ago so in

1342
00:31:06,549 --> 00:31:06,559
installed you know a few years ago so in
 

1343
00:31:06,559 --> 00:31:08,860
installed you know a few years ago so in
addition the master sometimes

1344
00:31:08,860 --> 00:31:08,870
addition the master sometimes
 

1345
00:31:08,870 --> 00:31:10,930
addition the master sometimes
checkpoints its complete state to disk

1346
00:31:10,930 --> 00:31:10,940
checkpoints its complete state to disk
 

1347
00:31:10,940 --> 00:31:15,100
checkpoints its complete state to disk
which takes some amount of time seconds

1348
00:31:15,100 --> 00:31:15,110
which takes some amount of time seconds
 

1349
00:31:15,110 --> 00:31:17,769
which takes some amount of time seconds
maybe a minute or something and then

1350
00:31:17,769 --> 00:31:17,779
maybe a minute or something and then
 

1351
00:31:17,779 --> 00:31:20,200
maybe a minute or something and then
when it restarts what it does is goes

1352
00:31:20,200 --> 00:31:20,210
when it restarts what it does is goes
 

1353
00:31:20,210 --> 00:31:21,850
when it restarts what it does is goes
back to the most recent checkpoint and

1354
00:31:21,850 --> 00:31:21,860
back to the most recent checkpoint and
 

1355
00:31:21,860 --> 00:31:24,610
back to the most recent checkpoint and
plays just the portion of a log that

1356
00:31:24,610 --> 00:31:24,620
plays just the portion of a log that
 

1357
00:31:24,620 --> 00:31:26,470
plays just the portion of a log that
sort of starting at the point in time

1358
00:31:26,470 --> 00:31:26,480
sort of starting at the point in time
 

1359
00:31:26,480 --> 00:31:30,009
sort of starting at the point in time
when that check one is created any

1360
00:31:30,009 --> 00:31:30,019
when that check one is created any
 

1361
00:31:30,019 --> 00:31:40,350
when that check one is created any
questions about the master data okay

1362
00:31:40,350 --> 00:31:40,360

 

1363
00:31:40,360 --> 00:31:44,019

so with that in mind I'm going to lay

1364
00:31:44,019 --> 00:31:44,029
so with that in mind I'm going to lay
 

1365
00:31:44,029 --> 00:31:46,330
so with that in mind I'm going to lay
out the steps in a read and the steps in

1366
00:31:46,330 --> 00:31:46,340
out the steps in a read and the steps in
 

1367
00:31:46,340 --> 00:31:46,869
out the steps in a read and the steps in
the right

1368
00:31:46,869 --> 00:31:46,879
the right
 

1369
00:31:46,879 --> 00:31:49,119
the right
where all this is heading is that I then

1370
00:31:49,119 --> 00:31:49,129
where all this is heading is that I then
 

1371
00:31:49,129 --> 00:31:50,950
where all this is heading is that I then
want to discuss you know for each

1372
00:31:50,950 --> 00:31:50,960
want to discuss you know for each
 

1373
00:31:50,960 --> 00:31:53,830
want to discuss you know for each
failure I can think of why does the

1374
00:31:53,830 --> 00:31:53,840
failure I can think of why does the
 

1375
00:31:53,840 --> 00:31:56,379
failure I can think of why does the
system or does the system act directly

1376
00:31:56,379 --> 00:31:56,389
system or does the system act directly
 

1377
00:31:56,389 --> 00:31:58,629
system or does the system act directly
after that failure um but in order to do

1378
00:31:58,629 --> 00:31:58,639
after that failure um but in order to do
 

1379
00:31:58,639 --> 00:32:00,730
after that failure um but in order to do
that we need to understand the data and

1380
00:32:00,730 --> 00:32:00,740
that we need to understand the data and
 

1381
00:32:00,740 --> 00:32:03,460
that we need to understand the data and
operations in the data okay so if

1382
00:32:03,460 --> 00:32:03,470
operations in the data okay so if
 

1383
00:32:03,470 --> 00:32:11,200
operations in the data okay so if
there's a read the first step is that

1384
00:32:11,200 --> 00:32:11,210
there's a read the first step is that
 

1385
00:32:11,210 --> 00:32:12,970
there's a read the first step is that
the client and what a read means that

1386
00:32:12,970 --> 00:32:12,980
the client and what a read means that
 

1387
00:32:12,980 --> 00:32:14,739
the client and what a read means that
the application has a file name in mind

1388
00:32:14,739 --> 00:32:14,749
the application has a file name in mind
 

1389
00:32:14,749 --> 00:32:17,440
the application has a file name in mind
and an offset in the file that it wants

1390
00:32:17,440 --> 00:32:17,450
and an offset in the file that it wants
 

1391
00:32:17,450 --> 00:32:19,269
and an offset in the file that it wants
to read some data front so it sends the

1392
00:32:19,269 --> 00:32:19,279
to read some data front so it sends the
 

1393
00:32:19,279 --> 00:32:21,789
to read some data front so it sends the
file name and the offset to the master

1394
00:32:21,789 --> 00:32:21,799
file name and the offset to the master
 

1395
00:32:21,799 --> 00:32:23,859
file name and the offset to the master
and the master looks up the file name in

1396
00:32:23,859 --> 00:32:23,869
and the master looks up the file name in
 

1397
00:32:23,869 --> 00:32:25,749
and the master looks up the file name in
its file table and then you know each

1398
00:32:25,749 --> 00:32:25,759
its file table and then you know each
 

1399
00:32:25,759 --> 00:32:28,299
its file table and then you know each
chunk is 64 megabytes who can use the

1400
00:32:28,299 --> 00:32:28,309
chunk is 64 megabytes who can use the
 

1401
00:32:28,309 --> 00:32:30,879
chunk is 64 megabytes who can use the
offset divided by 64 megabytes to find

1402
00:32:30,879 --> 00:32:30,889
offset divided by 64 megabytes to find
 

1403
00:32:30,889 --> 00:32:33,639
offset divided by 64 megabytes to find
which chunk and then it looks at that

1404
00:32:33,639 --> 00:32:33,649
which chunk and then it looks at that
 

1405
00:32:33,649 --> 00:32:39,399
which chunk and then it looks at that
chunk in its chunk table finds the list

1406
00:32:39,399 --> 00:32:39,409
chunk in its chunk table finds the list
 

1407
00:32:39,409 --> 00:32:41,859
chunk in its chunk table finds the list
of chunk servers that have replicas of

1408
00:32:41,859 --> 00:32:41,869
of chunk servers that have replicas of
 

1409
00:32:41,869 --> 00:32:44,499
of chunk servers that have replicas of
that data and returns that list to the

1410
00:32:44,499 --> 00:32:44,509
that data and returns that list to the
 

1411
00:32:44,509 --> 00:32:52,239
that data and returns that list to the
client so the first step is so you know

1412
00:32:52,239 --> 00:32:52,249
client so the first step is so you know
 

1413
00:32:52,249 --> 00:32:56,799
client so the first step is so you know
the file name and the offset the master

1414
00:32:56,799 --> 00:32:56,809
the file name and the offset the master
 

1415
00:32:56,809 --> 00:33:05,710
the file name and the offset the master
and the master sends the chunk handle

1416
00:33:05,710 --> 00:33:05,720
and the master sends the chunk handle
 

1417
00:33:05,720 --> 00:33:11,440
and the master sends the chunk handle
let's say H and the list of servers so

1418
00:33:11,440 --> 00:33:11,450
let's say H and the list of servers so
 

1419
00:33:11,450 --> 00:33:13,060
let's say H and the list of servers so
now we have some choice we can ask any

1420
00:33:13,060 --> 00:33:13,070
now we have some choice we can ask any
 

1421
00:33:13,070 --> 00:33:15,580
now we have some choice we can ask any
one of these servers pick one that's and

1422
00:33:15,580 --> 00:33:15,590
one of these servers pick one that's and
 

1423
00:33:15,590 --> 00:33:17,980
one of these servers pick one that's and
the paper says that clients try to guess

1424
00:33:17,980 --> 00:33:17,990
the paper says that clients try to guess
 

1425
00:33:17,990 --> 00:33:19,419
the paper says that clients try to guess
which server is closest to them in the

1426
00:33:19,419 --> 00:33:19,429
which server is closest to them in the
 

1427
00:33:19,429 --> 00:33:23,350
which server is closest to them in the
network maybe in the same rack and send

1428
00:33:23,350 --> 00:33:23,360
network maybe in the same rack and send
 

1429
00:33:23,360 --> 00:33:28,470
network maybe in the same rack and send
the read request to that to that replica

1430
00:33:28,470 --> 00:33:28,480

 

1431
00:33:28,480 --> 00:33:35,540

the client actually caches

1432
00:33:35,540 --> 00:33:35,550

 

1433
00:33:35,550 --> 00:33:37,920

cassia's this result so that if it reads

1434
00:33:37,920 --> 00:33:37,930
cassia's this result so that if it reads
 

1435
00:33:37,930 --> 00:33:39,810
cassia's this result so that if it reads
that chunk again and indeed the client

1436
00:33:39,810 --> 00:33:39,820
that chunk again and indeed the client
 

1437
00:33:39,820 --> 00:33:41,550
that chunk again and indeed the client
might read a given chunk in you know one

1438
00:33:41,550 --> 00:33:41,560
might read a given chunk in you know one
 

1439
00:33:41,560 --> 00:33:45,540
might read a given chunk in you know one
megabyte pieces or 64 kilobyte pieces or

1440
00:33:45,540 --> 00:33:45,550
megabyte pieces or 64 kilobyte pieces or
 

1441
00:33:45,550 --> 00:33:47,610
megabyte pieces or 64 kilobyte pieces or
something so I may end up reading the

1442
00:33:47,610 --> 00:33:47,620
something so I may end up reading the
 

1443
00:33:47,620 --> 00:33:49,400
something so I may end up reading the
same chunk different points successive

1444
00:33:49,400 --> 00:33:49,410
same chunk different points successive
 

1445
00:33:49,410 --> 00:33:51,720
same chunk different points successive
regions of a chunk many times and so

1446
00:33:51,720 --> 00:33:51,730
regions of a chunk many times and so
 

1447
00:33:51,730 --> 00:33:56,040
regions of a chunk many times and so
caches which server to talk to you for

1448
00:33:56,040 --> 00:33:56,050
caches which server to talk to you for
 

1449
00:33:56,050 --> 00:33:57,300
caches which server to talk to you for
giving chunks so it doesn't have to keep

1450
00:33:57,300 --> 00:33:57,310
giving chunks so it doesn't have to keep
 

1451
00:33:57,310 --> 00:33:59,010
giving chunks so it doesn't have to keep
beating on the master asking the master

1452
00:33:59,010 --> 00:33:59,020
beating on the master asking the master
 

1453
00:33:59,020 --> 00:34:03,140
beating on the master asking the master
for the same information over and over

1454
00:34:03,140 --> 00:34:03,150

 

1455
00:34:03,150 --> 00:34:07,320

now the client talks to one of the chunk

1456
00:34:07,320 --> 00:34:07,330
now the client talks to one of the chunk
 

1457
00:34:07,330 --> 00:34:12,870
now the client talks to one of the chunk
servers tells us a chunk handling offset

1458
00:34:12,870 --> 00:34:12,880
servers tells us a chunk handling offset
 

1459
00:34:12,880 --> 00:34:16,530
servers tells us a chunk handling offset
and the chunk servers store these chunks

1460
00:34:16,530 --> 00:34:16,540
and the chunk servers store these chunks
 

1461
00:34:16,540 --> 00:34:19,050
and the chunk servers store these chunks
each chunk in a separate Linux file on

1462
00:34:19,050 --> 00:34:19,060
each chunk in a separate Linux file on
 

1463
00:34:19,060 --> 00:34:21,330
each chunk in a separate Linux file on
their hard drive in a ordinary Linux

1464
00:34:21,330 --> 00:34:21,340
their hard drive in a ordinary Linux
 

1465
00:34:21,340 --> 00:34:24,690
their hard drive in a ordinary Linux
file system and presumably the chunk

1466
00:34:24,690 --> 00:34:24,700
file system and presumably the chunk
 

1467
00:34:24,700 --> 00:34:26,790
file system and presumably the chunk
files are just named by the handle so

1468
00:34:26,790 --> 00:34:26,800
files are just named by the handle so
 

1469
00:34:26,800 --> 00:34:28,650
files are just named by the handle so
all the chunk server has to do is go

1470
00:34:28,650 --> 00:34:28,660
all the chunk server has to do is go
 

1471
00:34:28,660 --> 00:34:31,200
all the chunk server has to do is go
find the file with the right name you

1472
00:34:31,200 --> 00:34:31,210
find the file with the right name you
 

1473
00:34:31,210 --> 00:34:33,440
find the file with the right name you
know I'll give it that

1474
00:34:33,440 --> 00:34:33,450
know I'll give it that
 

1475
00:34:33,450 --> 00:34:35,550
know I'll give it that
entire chunk and then just read the

1476
00:34:35,550 --> 00:34:35,560
entire chunk and then just read the
 

1477
00:34:35,560 --> 00:34:38,120
entire chunk and then just read the
desired range of bytes out of that file

1478
00:34:38,120 --> 00:34:38,130
desired range of bytes out of that file
 

1479
00:34:38,130 --> 00:34:46,560
desired range of bytes out of that file
and return the data to the client I hate

1480
00:34:46,560 --> 00:34:46,570
and return the data to the client I hate
 

1481
00:34:46,570 --> 00:34:51,900
and return the data to the client I hate
question about how reads operate can I

1482
00:34:51,900 --> 00:34:51,910
question about how reads operate can I
 

1483
00:34:51,910 --> 00:34:54,360
question about how reads operate can I
repeat number one the step one is the

1484
00:34:54,360 --> 00:34:54,370
repeat number one the step one is the
 

1485
00:34:54,370 --> 00:34:57,870
repeat number one the step one is the
application wants to read it a

1486
00:34:57,870 --> 00:34:57,880
application wants to read it a
 

1487
00:34:57,880 --> 00:35:00,030
application wants to read it a
particular file at a particular offset

1488
00:35:00,030 --> 00:35:00,040
particular file at a particular offset
 

1489
00:35:00,040 --> 00:35:02,880
particular file at a particular offset
within the file a particular range of

1490
00:35:02,880 --> 00:35:02,890
within the file a particular range of
 

1491
00:35:02,890 --> 00:35:04,410
within the file a particular range of
bytes in the files and one thousand two

1492
00:35:04,410 --> 00:35:04,420
bytes in the files and one thousand two
 

1493
00:35:04,420 --> 00:35:05,820
bytes in the files and one thousand two
two thousand and so it just sends a name

1494
00:35:05,820 --> 00:35:05,830
two thousand and so it just sends a name
 

1495
00:35:05,830 --> 00:35:09,000
two thousand and so it just sends a name
of the file and the beginning of the

1496
00:35:09,000 --> 00:35:09,010
of the file and the beginning of the
 

1497
00:35:09,010 --> 00:35:12,150
of the file and the beginning of the
byte range to the master and then the

1498
00:35:12,150 --> 00:35:12,160
byte range to the master and then the
 

1499
00:35:12,160 --> 00:35:14,040
byte range to the master and then the
master looks a file name and it's file

1500
00:35:14,040 --> 00:35:14,050
master looks a file name and it's file
 

1501
00:35:14,050 --> 00:35:18,600
master looks a file name and it's file
table to find the chunk that contains

1502
00:35:18,600 --> 00:35:18,610
table to find the chunk that contains
 

1503
00:35:18,610 --> 00:35:30,970
table to find the chunk that contains
that byte range for that file so good

1504
00:35:30,970 --> 00:35:30,980

 

1505
00:35:30,980 --> 00:35:34,140

[Music]

1506
00:35:34,140 --> 00:35:34,150

 

1507
00:35:34,150 --> 00:35:36,490

so I don't know the exact details my

1508
00:35:36,490 --> 00:35:36,500
so I don't know the exact details my
 

1509
00:35:36,500 --> 00:35:38,190
so I don't know the exact details my
impression is that the if the

1510
00:35:38,190 --> 00:35:38,200
impression is that the if the
 

1511
00:35:38,200 --> 00:35:40,299
impression is that the if the
application wants to read more than 64

1512
00:35:40,299 --> 00:35:40,309
application wants to read more than 64
 

1513
00:35:40,309 --> 00:35:42,309
application wants to read more than 64
megabytes or even just two bytes but

1514
00:35:42,309 --> 00:35:42,319
megabytes or even just two bytes but
 

1515
00:35:42,319 --> 00:35:44,769
megabytes or even just two bytes but
spanning a chunk boundary that the

1516
00:35:44,769 --> 00:35:44,779
spanning a chunk boundary that the
 

1517
00:35:44,779 --> 00:35:47,859
spanning a chunk boundary that the
library so the applications linked with

1518
00:35:47,859 --> 00:35:47,869
library so the applications linked with
 

1519
00:35:47,869 --> 00:35:52,089
library so the applications linked with
a library that sends our pcs to the

1520
00:35:52,089 --> 00:35:52,099
a library that sends our pcs to the
 

1521
00:35:52,099 --> 00:35:54,220
a library that sends our pcs to the
various servers and that library would

1522
00:35:54,220 --> 00:35:54,230
various servers and that library would
 

1523
00:35:54,230 --> 00:35:56,680
various servers and that library would
notice that the reads spanned a chunk

1524
00:35:56,680 --> 00:35:56,690
notice that the reads spanned a chunk
 

1525
00:35:56,690 --> 00:35:58,480
notice that the reads spanned a chunk
boundary and break it into two separate

1526
00:35:58,480 --> 00:35:58,490
boundary and break it into two separate
 

1527
00:35:58,490 --> 00:36:01,029
boundary and break it into two separate
reads and maybe talk to the master I

1528
00:36:01,029 --> 00:36:01,039
reads and maybe talk to the master I
 

1529
00:36:01,039 --> 00:36:02,470
reads and maybe talk to the master I
mean it may be that you could talk to

1530
00:36:02,470 --> 00:36:02,480
mean it may be that you could talk to
 

1531
00:36:02,480 --> 00:36:04,059
mean it may be that you could talk to
the master once and get two results or

1532
00:36:04,059 --> 00:36:04,069
the master once and get two results or
 

1533
00:36:04,069 --> 00:36:06,700
the master once and get two results or
something but logically at least it two

1534
00:36:06,700 --> 00:36:06,710
something but logically at least it two
 

1535
00:36:06,710 --> 00:36:08,259
something but logically at least it two
requests to the master and then requests

1536
00:36:08,259 --> 00:36:08,269
requests to the master and then requests
 

1537
00:36:08,269 --> 00:36:19,599
requests to the master and then requests
to two different chunk servers yes well

1538
00:36:19,599 --> 00:36:19,609
to two different chunk servers yes well
 

1539
00:36:19,609 --> 00:36:21,640
to two different chunk servers yes well
at least initially the client doesn't

1540
00:36:21,640 --> 00:36:21,650
at least initially the client doesn't
 

1541
00:36:21,650 --> 00:36:26,819
at least initially the client doesn't
know for a given file

1542
00:36:26,819 --> 00:36:26,829
know for a given file
 

1543
00:36:26,829 --> 00:36:35,980
know for a given file
what chunks need what chunks well it can

1544
00:36:35,980 --> 00:36:35,990
what chunks need what chunks well it can
 

1545
00:36:35,990 --> 00:36:37,710
what chunks need what chunks well it can
calculate it needs the seventeenth chunk

1546
00:36:37,710 --> 00:36:37,720
calculate it needs the seventeenth chunk
 

1547
00:36:37,720 --> 00:36:40,120
calculate it needs the seventeenth chunk
but but then it needs to know what chunk

1548
00:36:40,120 --> 00:36:40,130
but but then it needs to know what chunk
 

1549
00:36:40,130 --> 00:36:42,099
but but then it needs to know what chunk
server holds the seventeenth chunk of

1550
00:36:42,099 --> 00:36:42,109
server holds the seventeenth chunk of
 

1551
00:36:42,109 --> 00:36:44,829
server holds the seventeenth chunk of
that file and for that it certainly

1552
00:36:44,829 --> 00:36:44,839
that file and for that it certainly
 

1553
00:36:44,839 --> 00:36:47,589
that file and for that it certainly
needs for that it needs to talk to the

1554
00:36:47,589 --> 00:36:47,599
needs for that it needs to talk to the
 

1555
00:36:47,599 --> 00:36:58,480
needs for that it needs to talk to the
master okay so all right did I'm not

1556
00:36:58,480 --> 00:36:58,490
master okay so all right did I'm not
 

1557
00:36:58,490 --> 00:36:59,829
master okay so all right did I'm not
going to make a strong claim about which

1558
00:36:59,829 --> 00:36:59,839
going to make a strong claim about which
 

1559
00:36:59,839 --> 00:37:01,120
going to make a strong claim about which
of them decides that it was the

1560
00:37:01,120 --> 00:37:01,130
of them decides that it was the
 

1561
00:37:01,130 --> 00:37:03,160
of them decides that it was the
seventeenth chunk in the file but it's

1562
00:37:03,160 --> 00:37:03,170
seventeenth chunk in the file but it's
 

1563
00:37:03,170 --> 00:37:06,370
seventeenth chunk in the file but it's
the master that finds the identifier of

1564
00:37:06,370 --> 00:37:06,380
the master that finds the identifier of
 

1565
00:37:06,380 --> 00:37:07,839
the master that finds the identifier of
the handle of the seventeenth chunk in

1566
00:37:07,839 --> 00:37:07,849
the handle of the seventeenth chunk in
 

1567
00:37:07,849 --> 00:37:09,940
the handle of the seventeenth chunk in
the file looks that up in its table and

1568
00:37:09,940 --> 00:37:09,950
the file looks that up in its table and
 

1569
00:37:09,950 --> 00:37:12,579
the file looks that up in its table and
figures out which chunk servers hold

1570
00:37:12,579 --> 00:37:12,589
figures out which chunk servers hold
 

1571
00:37:12,589 --> 00:37:25,599
figures out which chunk servers hold
that chunk yes

1572
00:37:25,599 --> 00:37:25,609

 

1573
00:37:25,609 --> 00:37:35,470

how does that or you mean if the if the

1574
00:37:35,470 --> 00:37:35,480
how does that or you mean if the if the
 

1575
00:37:35,480 --> 00:37:38,000
how does that or you mean if the if the
client asks for a range of bytes that

1576
00:37:38,000 --> 00:37:38,010
client asks for a range of bytes that
 

1577
00:37:38,010 --> 00:37:46,390
client asks for a range of bytes that
spans a chunk boundary yeah so the the

1578
00:37:46,390 --> 00:37:46,400
spans a chunk boundary yeah so the the
 

1579
00:37:46,400 --> 00:37:49,039
spans a chunk boundary yeah so the the
well you know the client will ask that

1580
00:37:49,039 --> 00:37:49,049
well you know the client will ask that
 

1581
00:37:49,049 --> 00:37:50,480
well you know the client will ask that
well the clients linked with this

1582
00:37:50,480 --> 00:37:50,490
well the clients linked with this
 

1583
00:37:50,490 --> 00:37:52,940
well the clients linked with this
library is a GFS library that noticed

1584
00:37:52,940 --> 00:37:52,950
library is a GFS library that noticed
 

1585
00:37:52,950 --> 00:37:56,180
library is a GFS library that noticed
how to take read requests apart and put

1586
00:37:56,180 --> 00:37:56,190
how to take read requests apart and put
 

1587
00:37:56,190 --> 00:38:00,260
how to take read requests apart and put
them back together and so that library

1588
00:38:00,260 --> 00:38:00,270
them back together and so that library
 

1589
00:38:00,270 --> 00:38:01,280
them back together and so that library
would talk to the master and the master

1590
00:38:01,280 --> 00:38:01,290
would talk to the master and the master
 

1591
00:38:01,290 --> 00:38:02,900
would talk to the master and the master
would tell it well well you know chunk

1592
00:38:02,900 --> 00:38:02,910
would tell it well well you know chunk
 

1593
00:38:02,910 --> 00:38:05,120
would tell it well well you know chunk
seven is on this server and chunk eight

1594
00:38:05,120 --> 00:38:05,130
seven is on this server and chunk eight
 

1595
00:38:05,130 --> 00:38:07,579
seven is on this server and chunk eight
is on that server and then why the

1596
00:38:07,579 --> 00:38:07,589
is on that server and then why the
 

1597
00:38:07,589 --> 00:38:09,260
is on that server and then why the
library would just be able to say oh you

1598
00:38:09,260 --> 00:38:09,270
library would just be able to say oh you
 

1599
00:38:09,270 --> 00:38:10,849
library would just be able to say oh you
know I need the last couple bites of

1600
00:38:10,849 --> 00:38:10,859
know I need the last couple bites of
 

1601
00:38:10,859 --> 00:38:12,230
know I need the last couple bites of
chunk seven and the first couple bites

1602
00:38:12,230 --> 00:38:12,240
chunk seven and the first couple bites
 

1603
00:38:12,240 --> 00:38:15,410
chunk seven and the first couple bites
of chunk eight and then would fetch

1604
00:38:15,410 --> 00:38:15,420
of chunk eight and then would fetch
 

1605
00:38:15,420 --> 00:38:17,809
of chunk eight and then would fetch
those put them together in a buffer and

1606
00:38:17,809 --> 00:38:17,819
those put them together in a buffer and
 

1607
00:38:17,819 --> 00:38:26,020
those put them together in a buffer and
return them to the calling application

1608
00:38:26,020 --> 00:38:26,030

 

1609
00:38:26,030 --> 00:38:28,520

well the master tells it about chunks

1610
00:38:28,520 --> 00:38:28,530
well the master tells it about chunks
 

1611
00:38:28,530 --> 00:38:30,890
well the master tells it about chunks
and the library kind of figures out

1612
00:38:30,890 --> 00:38:30,900
and the library kind of figures out
 

1613
00:38:30,900 --> 00:38:32,690
and the library kind of figures out
where it should look in a given chunk to

1614
00:38:32,690 --> 00:38:32,700
where it should look in a given chunk to
 

1615
00:38:32,700 --> 00:38:34,940
where it should look in a given chunk to
find the date of the application wanded

1616
00:38:34,940 --> 00:38:34,950
find the date of the application wanded
 

1617
00:38:34,950 --> 00:38:36,230
find the date of the application wanded
the application only thinks in terms of

1618
00:38:36,230 --> 00:38:36,240
the application only thinks in terms of
 

1619
00:38:36,240 --> 00:38:38,599
the application only thinks in terms of
file names and sort of just offsets in

1620
00:38:38,599 --> 00:38:38,609
file names and sort of just offsets in
 

1621
00:38:38,609 --> 00:38:41,270
file names and sort of just offsets in
the entire file in the library and the

1622
00:38:41,270 --> 00:38:41,280
the entire file in the library and the
 

1623
00:38:41,280 --> 00:38:45,490
the entire file in the library and the
master conspire to turn that into chunks

1624
00:38:45,490 --> 00:38:45,500

 

1625
00:38:45,500 --> 00:38:50,339

yeah

1626
00:38:50,339 --> 00:38:50,349

 

1627
00:38:50,349 --> 00:38:55,390

sorry let me get closer here you see

1628
00:38:55,390 --> 00:38:55,400
sorry let me get closer here you see
 

1629
00:38:55,400 --> 00:39:03,279
sorry let me get closer here you see
again so the question is does it matter

1630
00:39:03,279 --> 00:39:03,289
again so the question is does it matter
 

1631
00:39:03,289 --> 00:39:06,099
again so the question is does it matter
which chunk server you reach room so you

1632
00:39:06,099 --> 00:39:06,109
which chunk server you reach room so you
 

1633
00:39:06,109 --> 00:39:08,919
which chunk server you reach room so you
know yes and no notionally they're all

1634
00:39:08,919 --> 00:39:08,929
know yes and no notionally they're all
 

1635
00:39:08,929 --> 00:39:13,029
know yes and no notionally they're all
supposed to be replicas in fact as you

1636
00:39:13,029 --> 00:39:13,039
supposed to be replicas in fact as you
 

1637
00:39:13,039 --> 00:39:14,859
supposed to be replicas in fact as you
may have noticed or as we'll talk about

1638
00:39:14,859 --> 00:39:14,869
may have noticed or as we'll talk about
 

1639
00:39:14,869 --> 00:39:17,199
may have noticed or as we'll talk about
they're not you know they're not

1640
00:39:17,199 --> 00:39:17,209
they're not you know they're not
 

1641
00:39:17,209 --> 00:39:20,679
they're not you know they're not
necessarily identical and applications

1642
00:39:20,679 --> 00:39:20,689
necessarily identical and applications
 

1643
00:39:20,689 --> 00:39:21,969
necessarily identical and applications
are supposed to be able to tolerate this

1644
00:39:21,969 --> 00:39:21,979
are supposed to be able to tolerate this
 

1645
00:39:21,979 --> 00:39:23,769
are supposed to be able to tolerate this
but the fact is that you make a slightly

1646
00:39:23,769 --> 00:39:23,779
but the fact is that you make a slightly
 

1647
00:39:23,779 --> 00:39:24,819
but the fact is that you make a slightly
different data depending on which

1648
00:39:24,819 --> 00:39:24,829
different data depending on which
 

1649
00:39:24,829 --> 00:39:28,989
different data depending on which
replicas you read yeah so the paper says

1650
00:39:28,989 --> 00:39:28,999
replicas you read yeah so the paper says
 

1651
00:39:28,999 --> 00:39:32,410
replicas you read yeah so the paper says
that clients try to read from the chunk

1652
00:39:32,410 --> 00:39:32,420
that clients try to read from the chunk
 

1653
00:39:32,420 --> 00:39:34,689
that clients try to read from the chunk
server that's in the same rack or on the

1654
00:39:34,689 --> 00:39:34,699
server that's in the same rack or on the
 

1655
00:39:34,699 --> 00:39:44,739
server that's in the same rack or on the
same switch or something all right so

1656
00:39:44,739 --> 00:39:44,749
same switch or something all right so
 

1657
00:39:44,749 --> 00:39:48,849
same switch or something all right so
that's reads

1658
00:39:48,849 --> 00:39:48,859

 

1659
00:39:48,859 --> 00:39:51,410

the rights are more complex and

1660
00:39:51,410 --> 00:39:51,420
the rights are more complex and
 

1661
00:39:51,420 --> 00:40:02,870
the rights are more complex and
interesting now the application

1662
00:40:02,870 --> 00:40:02,880
interesting now the application
 

1663
00:40:02,880 --> 00:40:04,400
interesting now the application
interface for rights is pretty similar

1664
00:40:04,400 --> 00:40:04,410
interface for rights is pretty similar
 

1665
00:40:04,410 --> 00:40:06,020
interface for rights is pretty similar
there's just some call some library you

1666
00:40:06,020 --> 00:40:06,030
there's just some call some library you
 

1667
00:40:06,030 --> 00:40:08,900
there's just some call some library you
call to mate you make to the gfs client

1668
00:40:08,900 --> 00:40:08,910
call to mate you make to the gfs client
 

1669
00:40:08,910 --> 00:40:10,220
call to mate you make to the gfs client
library saying look here's a file name

1670
00:40:10,220 --> 00:40:10,230
library saying look here's a file name
 

1671
00:40:10,230 --> 00:40:12,530
library saying look here's a file name
and a range of bytes I'd like to write

1672
00:40:12,530 --> 00:40:12,540
and a range of bytes I'd like to write
 

1673
00:40:12,540 --> 00:40:14,329
and a range of bytes I'd like to write
and the buffer of data that I'd like you

1674
00:40:14,329 --> 00:40:14,339
and the buffer of data that I'd like you
 

1675
00:40:14,339 --> 00:40:17,599
and the buffer of data that I'd like you
to write to that that range actually let

1676
00:40:17,599 --> 00:40:17,609
to write to that that range actually let
 

1677
00:40:17,609 --> 00:40:19,520
to write to that that range actually let
me let me backpedal I only want to talk

1678
00:40:19,520 --> 00:40:19,530
me let me backpedal I only want to talk
 

1679
00:40:19,530 --> 00:40:23,089
me let me backpedal I only want to talk
about record of pens and so I'm going to

1680
00:40:23,089 --> 00:40:23,099
about record of pens and so I'm going to
 

1681
00:40:23,099 --> 00:40:26,329
about record of pens and so I'm going to
praise this the client interface as the

1682
00:40:26,329 --> 00:40:26,339
praise this the client interface as the
 

1683
00:40:26,339 --> 00:40:28,190
praise this the client interface as the
client makes a library call that says

1684
00:40:28,190 --> 00:40:28,200
client makes a library call that says
 

1685
00:40:28,200 --> 00:40:29,930
client makes a library call that says
here's a file name and I'd like to

1686
00:40:29,930 --> 00:40:29,940
here's a file name and I'd like to
 

1687
00:40:29,940 --> 00:40:32,059
here's a file name and I'd like to
append this buffer of bytes to the file

1688
00:40:32,059 --> 00:40:32,069
append this buffer of bytes to the file
 

1689
00:40:32,069 --> 00:40:35,089
append this buffer of bytes to the file
I said this is the record of pens that

1690
00:40:35,089 --> 00:40:35,099
I said this is the record of pens that
 

1691
00:40:35,099 --> 00:40:42,890
I said this is the record of pens that
the paper talks about so again the

1692
00:40:42,890 --> 00:40:42,900
the paper talks about so again the
 

1693
00:40:42,900 --> 00:40:47,569
the paper talks about so again the
client asks the master look I want to

1694
00:40:47,569 --> 00:40:47,579
client asks the master look I want to
 

1695
00:40:47,579 --> 00:40:49,670
client asks the master look I want to
append sends a master requesting what I

1696
00:40:49,670 --> 00:40:49,680
append sends a master requesting what I
 

1697
00:40:49,680 --> 00:40:51,230
append sends a master requesting what I
would like to pen to this named file

1698
00:40:51,230 --> 00:40:51,240
would like to pen to this named file
 

1699
00:40:51,240 --> 00:40:55,130
would like to pen to this named file
please tell me where to look for the

1700
00:40:55,130 --> 00:40:55,140
please tell me where to look for the
 

1701
00:40:55,140 --> 00:40:56,780
please tell me where to look for the
last chunk in the file because the

1702
00:40:56,780 --> 00:40:56,790
last chunk in the file because the
 

1703
00:40:56,790 --> 00:40:58,609
last chunk in the file because the
client may not know how long the file is

1704
00:40:58,609 --> 00:40:58,619
client may not know how long the file is
 

1705
00:40:58,619 --> 00:41:00,319
client may not know how long the file is
if lots of clients are opinion to the

1706
00:41:00,319 --> 00:41:00,329
if lots of clients are opinion to the
 

1707
00:41:00,329 --> 00:41:02,809
if lots of clients are opinion to the
same file because we have some big file

1708
00:41:02,809 --> 00:41:02,819
same file because we have some big file
 

1709
00:41:02,819 --> 00:41:04,940
same file because we have some big file
this logging stuff from a lot of

1710
00:41:04,940 --> 00:41:04,950
this logging stuff from a lot of
 

1711
00:41:04,950 --> 00:41:06,890
this logging stuff from a lot of
different clients may be you know no

1712
00:41:06,890 --> 00:41:06,900
different clients may be you know no
 

1713
00:41:06,900 --> 00:41:08,359
different clients may be you know no
client will necessarily know how long

1714
00:41:08,359 --> 00:41:08,369
client will necessarily know how long
 

1715
00:41:08,369 --> 00:41:10,370
client will necessarily know how long
the file is and therefore which offset

1716
00:41:10,370 --> 00:41:10,380
the file is and therefore which offset
 

1717
00:41:10,380 --> 00:41:12,260
the file is and therefore which offset
or which chunk it should be appending to

1718
00:41:12,260 --> 00:41:12,270
or which chunk it should be appending to
 

1719
00:41:12,270 --> 00:41:14,270
or which chunk it should be appending to
so you can ask the master please tell me

1720
00:41:14,270 --> 00:41:14,280
so you can ask the master please tell me
 

1721
00:41:14,280 --> 00:41:16,670
so you can ask the master please tell me
about the the server's that hold the

1722
00:41:16,670 --> 00:41:16,680
about the the server's that hold the
 

1723
00:41:16,680 --> 00:41:18,700
about the the server's that hold the
very last chunk

1724
00:41:18,700 --> 00:41:18,710
very last chunk
 

1725
00:41:18,710 --> 00:41:22,540
very last chunk
current chunk in this file so

1726
00:41:22,540 --> 00:41:22,550
current chunk in this file so
 

1727
00:41:22,550 --> 00:41:26,030
current chunk in this file so
unfortunately now the writing if you're

1728
00:41:26,030 --> 00:41:26,040
unfortunately now the writing if you're
 

1729
00:41:26,040 --> 00:41:27,559
unfortunately now the writing if you're
reading you can read from any up-to-date

1730
00:41:27,559 --> 00:41:27,569
reading you can read from any up-to-date
 

1731
00:41:27,569 --> 00:41:30,050
reading you can read from any up-to-date
replica for writing though there needs

1732
00:41:30,050 --> 00:41:30,060
replica for writing though there needs
 

1733
00:41:30,060 --> 00:41:32,750
replica for writing though there needs
to be a primary so at this point on the

1734
00:41:32,750 --> 00:41:32,760
to be a primary so at this point on the
 

1735
00:41:32,760 --> 00:41:35,569
to be a primary so at this point on the
file may or may not have a primary

1736
00:41:35,569 --> 00:41:35,579
file may or may not have a primary
 

1737
00:41:35,579 --> 00:41:37,700
file may or may not have a primary
already designated by the master so we

1738
00:41:37,700 --> 00:41:37,710
already designated by the master so we
 

1739
00:41:37,710 --> 00:41:39,170
already designated by the master so we
need to consider the case of if there's

1740
00:41:39,170 --> 00:41:39,180
need to consider the case of if there's
 

1741
00:41:39,180 --> 00:41:40,970
need to consider the case of if there's
no primary already and all the master

1742
00:41:40,970 --> 00:41:40,980
no primary already and all the master
 

1743
00:41:40,980 --> 00:41:49,550
no primary already and all the master
knows well there's no primary so so one

1744
00:41:49,550 --> 00:41:49,560
knows well there's no primary so so one
 

1745
00:41:49,560 --> 00:41:57,589
knows well there's no primary so so one
case is no primary

1746
00:41:57,589 --> 00:41:57,599

 

1747
00:41:57,599 --> 00:42:00,089

in that case the master needs to find

1748
00:42:00,089 --> 00:42:00,099
in that case the master needs to find
 

1749
00:42:00,099 --> 00:42:03,420
in that case the master needs to find
out the set of chunk servers that have

1750
00:42:03,420 --> 00:42:03,430
out the set of chunk servers that have
 

1751
00:42:03,430 --> 00:42:06,329
out the set of chunk servers that have
the most up-to-date copy of the chunk

1752
00:42:06,329 --> 00:42:06,339
the most up-to-date copy of the chunk
 

1753
00:42:06,339 --> 00:42:08,460
the most up-to-date copy of the chunk
because know if you've been running the

1754
00:42:08,460 --> 00:42:08,470
because know if you've been running the
 

1755
00:42:08,470 --> 00:42:10,650
because know if you've been running the
system for a long time due to failures

1756
00:42:10,650 --> 00:42:10,660
system for a long time due to failures
 

1757
00:42:10,660 --> 00:42:11,790
system for a long time due to failures
or whatever there may be chunk servers

1758
00:42:11,790 --> 00:42:11,800
or whatever there may be chunk servers
 

1759
00:42:11,800 --> 00:42:14,280
or whatever there may be chunk servers
out there that have old copies of the

1760
00:42:14,280 --> 00:42:14,290
out there that have old copies of the
 

1761
00:42:14,290 --> 00:42:15,569
out there that have old copies of the
chunk from you know yesterday or last

1762
00:42:15,569 --> 00:42:15,579
chunk from you know yesterday or last
 

1763
00:42:15,579 --> 00:42:17,940
chunk from you know yesterday or last
week that I've been kept up to kept up

1764
00:42:17,940 --> 00:42:17,950
week that I've been kept up to kept up
 

1765
00:42:17,950 --> 00:42:19,680
week that I've been kept up to kept up
to date because maybe that server was

1766
00:42:19,680 --> 00:42:19,690
to date because maybe that server was
 

1767
00:42:19,690 --> 00:42:21,809
to date because maybe that server was
dead for a couple days and wasn't

1768
00:42:21,809 --> 00:42:21,819
dead for a couple days and wasn't
 

1769
00:42:21,819 --> 00:42:23,790
dead for a couple days and wasn't
receiving updates so there's you need to

1770
00:42:23,790 --> 00:42:23,800
receiving updates so there's you need to
 

1771
00:42:23,800 --> 00:42:24,720
receiving updates so there's you need to
be able to tell the difference between

1772
00:42:24,720 --> 00:42:24,730
be able to tell the difference between
 

1773
00:42:24,730 --> 00:42:27,180
be able to tell the difference between
up-to-date copies of the chunk and non

1774
00:42:27,180 --> 00:42:27,190
up-to-date copies of the chunk and non
 

1775
00:42:27,190 --> 00:42:33,559
up-to-date copies of the chunk and non
up-to-date so the first step is to find

1776
00:42:33,559 --> 00:42:33,569
up-to-date so the first step is to find
 

1777
00:42:33,569 --> 00:42:37,500
up-to-date so the first step is to find
you know find up-to-date this is all

1778
00:42:37,500 --> 00:42:37,510
you know find up-to-date this is all
 

1779
00:42:37,510 --> 00:42:41,309
you know find up-to-date this is all
happening in the master because the

1780
00:42:41,309 --> 00:42:41,319
happening in the master because the
 

1781
00:42:41,319 --> 00:42:42,780
happening in the master because the
client has asked the master told the

1782
00:42:42,780 --> 00:42:42,790
client has asked the master told the
 

1783
00:42:42,790 --> 00:42:44,250
client has asked the master told the
master look I want up end of this file

1784
00:42:44,250 --> 00:42:44,260
master look I want up end of this file
 

1785
00:42:44,260 --> 00:42:46,170
master look I want up end of this file
please tell me what chunk service to

1786
00:42:46,170 --> 00:42:46,180
please tell me what chunk service to
 

1787
00:42:46,180 --> 00:42:48,540
please tell me what chunk service to
talk to so a part of the master trying

1788
00:42:48,540 --> 00:42:48,550
talk to so a part of the master trying
 

1789
00:42:48,550 --> 00:42:49,770
talk to so a part of the master trying
to figure out what chunk servers the

1790
00:42:49,770 --> 00:42:49,780
to figure out what chunk servers the
 

1791
00:42:49,780 --> 00:42:50,670
to figure out what chunk servers the
client should talk to you

1792
00:42:50,670 --> 00:42:50,680
client should talk to you
 

1793
00:42:50,680 --> 00:42:52,940
client should talk to you
so when we finally find up-to-date

1794
00:42:52,940 --> 00:42:52,950
so when we finally find up-to-date
 

1795
00:42:52,950 --> 00:42:59,760
so when we finally find up-to-date
replicas and what update means is a

1796
00:42:59,760 --> 00:42:59,770
replicas and what update means is a
 

1797
00:42:59,770 --> 00:43:02,250
replicas and what update means is a
replica whose version of the chunk is

1798
00:43:02,250 --> 00:43:02,260
replica whose version of the chunk is
 

1799
00:43:02,260 --> 00:43:04,710
replica whose version of the chunk is
equal to the version number that the

1800
00:43:04,710 --> 00:43:04,720
equal to the version number that the
 

1801
00:43:04,720 --> 00:43:06,720
equal to the version number that the
master knows is the most up-to-date

1802
00:43:06,720 --> 00:43:06,730
master knows is the most up-to-date
 

1803
00:43:06,730 --> 00:43:08,130
master knows is the most up-to-date
version number it's the master that

1804
00:43:08,130 --> 00:43:08,140
version number it's the master that
 

1805
00:43:08,140 --> 00:43:10,620
version number it's the master that
hands out these version numbers the

1806
00:43:10,620 --> 00:43:10,630
hands out these version numbers the
 

1807
00:43:10,630 --> 00:43:14,730
hands out these version numbers the
master remembers that oh for this

1808
00:43:14,730 --> 00:43:14,740
master remembers that oh for this
 

1809
00:43:14,740 --> 00:43:18,450
master remembers that oh for this
particular chunk you know the trunk

1810
00:43:18,450 --> 00:43:18,460
particular chunk you know the trunk
 

1811
00:43:18,460 --> 00:43:19,559
particular chunk you know the trunk
server is only up to date if it has

1812
00:43:19,559 --> 00:43:19,569
server is only up to date if it has
 

1813
00:43:19,569 --> 00:43:21,210
server is only up to date if it has
version number 17 and this is why it has

1814
00:43:21,210 --> 00:43:21,220
version number 17 and this is why it has
 

1815
00:43:21,220 --> 00:43:23,540
version number 17 and this is why it has
to be non-volatile stored on disk

1816
00:43:23,540 --> 00:43:23,550
to be non-volatile stored on disk
 

1817
00:43:23,550 --> 00:43:26,550
to be non-volatile stored on disk
because if if it was lost in a crash and

1818
00:43:26,550 --> 00:43:26,560
because if if it was lost in a crash and
 

1819
00:43:26,560 --> 00:43:30,990
because if if it was lost in a crash and
there were chunk servers holding stale

1820
00:43:30,990 --> 00:43:31,000
there were chunk servers holding stale
 

1821
00:43:31,000 --> 00:43:33,660
there were chunk servers holding stale
copies of chunks the master wouldn't be

1822
00:43:33,660 --> 00:43:33,670
copies of chunks the master wouldn't be
 

1823
00:43:33,670 --> 00:43:35,130
copies of chunks the master wouldn't be
able to distinguish between chunk

1824
00:43:35,130 --> 00:43:35,140
able to distinguish between chunk
 

1825
00:43:35,140 --> 00:43:36,809
able to distinguish between chunk
servers holding stale copies of a chunk

1826
00:43:36,809 --> 00:43:36,819
servers holding stale copies of a chunk
 

1827
00:43:36,819 --> 00:43:39,300
servers holding stale copies of a chunk
from last week and a chunk server that

1828
00:43:39,300 --> 00:43:39,310
from last week and a chunk server that
 

1829
00:43:39,310 --> 00:43:42,240
from last week and a chunk server that
holds the copy of the chunk that was

1830
00:43:42,240 --> 00:43:42,250
holds the copy of the chunk that was
 

1831
00:43:42,250 --> 00:43:44,430
holds the copy of the chunk that was
up-to-date as of the crash that's why

1832
00:43:44,430 --> 00:43:44,440
up-to-date as of the crash that's why
 

1833
00:43:44,440 --> 00:43:46,650
up-to-date as of the crash that's why
the master members of version number on

1834
00:43:46,650 --> 00:43:46,660
the master members of version number on
 

1835
00:43:46,660 --> 00:43:54,440
the master members of version number on
disk yeah

1836
00:43:54,440 --> 00:43:54,450

 

1837
00:43:54,450 --> 00:43:56,849

if you knew you were talking to all the

1838
00:43:56,849 --> 00:43:56,859
if you knew you were talking to all the
 

1839
00:43:56,859 --> 00:43:59,960
if you knew you were talking to all the
chunk servers okay so the observation is

1840
00:43:59,960 --> 00:43:59,970
chunk servers okay so the observation is
 

1841
00:43:59,970 --> 00:44:02,250
chunk servers okay so the observation is
the master has to talk to the chunk

1842
00:44:02,250 --> 00:44:02,260
the master has to talk to the chunk
 

1843
00:44:02,260 --> 00:44:04,650
the master has to talk to the chunk
servers anyway if it reboots in order to

1844
00:44:04,650 --> 00:44:04,660
servers anyway if it reboots in order to
 

1845
00:44:04,660 --> 00:44:06,270
servers anyway if it reboots in order to
find which chunk server holds which

1846
00:44:06,270 --> 00:44:06,280
find which chunk server holds which
 

1847
00:44:06,280 --> 00:44:08,880
find which chunk server holds which
chunk because the master doesn't

1848
00:44:08,880 --> 00:44:08,890
chunk because the master doesn't
 

1849
00:44:08,890 --> 00:44:12,140
chunk because the master doesn't
remember that so you might think that

1850
00:44:12,140 --> 00:44:12,150
remember that so you might think that
 

1851
00:44:12,150 --> 00:44:14,370
remember that so you might think that
you could just take the maximum you

1852
00:44:14,370 --> 00:44:14,380
you could just take the maximum you
 

1853
00:44:14,380 --> 00:44:15,569
you could just take the maximum you
could just talk to the chunk servers

1854
00:44:15,569 --> 00:44:15,579
could just talk to the chunk servers
 

1855
00:44:15,579 --> 00:44:17,069
could just talk to the chunk servers
find out what trunks and versions they

1856
00:44:17,069 --> 00:44:17,079
find out what trunks and versions they
 

1857
00:44:17,079 --> 00:44:18,990
find out what trunks and versions they
hold and take the maximum for a given

1858
00:44:18,990 --> 00:44:19,000
hold and take the maximum for a given
 

1859
00:44:19,000 --> 00:44:20,609
hold and take the maximum for a given
chunk overall the responding chunk

1860
00:44:20,609 --> 00:44:20,619
chunk overall the responding chunk
 

1861
00:44:20,619 --> 00:44:22,740
chunk overall the responding chunk
servers and that would work if all the

1862
00:44:22,740 --> 00:44:22,750
servers and that would work if all the
 

1863
00:44:22,750 --> 00:44:24,569
servers and that would work if all the
chunk servers holding a chunk responded

1864
00:44:24,569 --> 00:44:24,579
chunk servers holding a chunk responded
 

1865
00:44:24,579 --> 00:44:26,910
chunk servers holding a chunk responded
but the risk is that at the time the

1866
00:44:26,910 --> 00:44:26,920
but the risk is that at the time the
 

1867
00:44:26,920 --> 00:44:28,470
but the risk is that at the time the
master reboots maybe some of the chunk

1868
00:44:28,470 --> 00:44:28,480
master reboots maybe some of the chunk
 

1869
00:44:28,480 --> 00:44:30,390
master reboots maybe some of the chunk
servers are offline or disconnected or

1870
00:44:30,390 --> 00:44:30,400
servers are offline or disconnected or
 

1871
00:44:30,400 --> 00:44:32,760
servers are offline or disconnected or
whatever themselves rebooting and don't

1872
00:44:32,760 --> 00:44:32,770
whatever themselves rebooting and don't
 

1873
00:44:32,770 --> 00:44:35,339
whatever themselves rebooting and don't
respond and so all the master gets back

1874
00:44:35,339 --> 00:44:35,349
respond and so all the master gets back
 

1875
00:44:35,349 --> 00:44:38,190
respond and so all the master gets back
is responses from chunk servers that

1876
00:44:38,190 --> 00:44:38,200
is responses from chunk servers that
 

1877
00:44:38,200 --> 00:44:40,109
is responses from chunk servers that
have last week's copies of the block and

1878
00:44:40,109 --> 00:44:40,119
have last week's copies of the block and
 

1879
00:44:40,119 --> 00:44:42,450
have last week's copies of the block and
the chunk servers that have the current

1880
00:44:42,450 --> 00:44:42,460
the chunk servers that have the current
 

1881
00:44:42,460 --> 00:44:44,310
the chunk servers that have the current
copy haven't finished rebooting or

1882
00:44:44,310 --> 00:44:44,320
copy haven't finished rebooting or
 

1883
00:44:44,320 --> 00:44:54,930
copy haven't finished rebooting or
offline or something so ok oh yes if if

1884
00:44:54,930 --> 00:44:54,940
offline or something so ok oh yes if if
 

1885
00:44:54,940 --> 00:44:56,609
offline or something so ok oh yes if if
the server's holding the most recent

1886
00:44:56,609 --> 00:44:56,619
the server's holding the most recent
 

1887
00:44:56,619 --> 00:44:59,849
the server's holding the most recent
copy are permanently dead if you've lost

1888
00:44:59,849 --> 00:44:59,859
copy are permanently dead if you've lost
 

1889
00:44:59,859 --> 00:45:02,970
copy are permanently dead if you've lost
all copies all of the most recent

1890
00:45:02,970 --> 00:45:02,980
all copies all of the most recent
 

1891
00:45:02,980 --> 00:45:09,020
all copies all of the most recent
version of a chunk then yes

1892
00:45:09,020 --> 00:45:09,030

 

1893
00:45:09,030 --> 00:45:11,120

No

1894
00:45:11,120 --> 00:45:11,130
No
 

1895
00:45:11,130 --> 00:45:15,329
No
okay so the question is the master knows

1896
00:45:15,329 --> 00:45:15,339
okay so the question is the master knows
 

1897
00:45:15,339 --> 00:45:17,550
okay so the question is the master knows
that for this chunk is looking for

1898
00:45:17,550 --> 00:45:17,560
that for this chunk is looking for
 

1899
00:45:17,560 --> 00:45:18,540
that for this chunk is looking for
version 17

1900
00:45:18,540 --> 00:45:18,550
version 17
 

1901
00:45:18,550 --> 00:45:21,569
version 17
supposing it finds no chunk server you

1902
00:45:21,569 --> 00:45:21,579
supposing it finds no chunk server you
 

1903
00:45:21,579 --> 00:45:22,680
supposing it finds no chunk server you
know and it talks to the chunk servers

1904
00:45:22,680 --> 00:45:22,690
know and it talks to the chunk servers
 

1905
00:45:22,690 --> 00:45:24,420
know and it talks to the chunk servers
periodically to sort of ask them what

1906
00:45:24,420 --> 00:45:24,430
periodically to sort of ask them what
 

1907
00:45:24,430 --> 00:45:25,770
periodically to sort of ask them what
chunks do you have what versions you

1908
00:45:25,770 --> 00:45:25,780
chunks do you have what versions you
 

1909
00:45:25,780 --> 00:45:27,510
chunks do you have what versions you
have supposing it finds no server with

1910
00:45:27,510 --> 00:45:27,520
have supposing it finds no server with
 

1911
00:45:27,520 --> 00:45:30,359
have supposing it finds no server with
chunk 17 with version 17 for this this

1912
00:45:30,359 --> 00:45:30,369
chunk 17 with version 17 for this this
 

1913
00:45:30,369 --> 00:45:32,790
chunk 17 with version 17 for this this
chunk then the master will either say

1914
00:45:32,790 --> 00:45:32,800
chunk then the master will either say
 

1915
00:45:32,800 --> 00:45:35,700
chunk then the master will either say
well either not respond yet and wait or

1916
00:45:35,700 --> 00:45:35,710
well either not respond yet and wait or
 

1917
00:45:35,710 --> 00:45:39,780
well either not respond yet and wait or
it will tell the client look I can't

1918
00:45:39,780 --> 00:45:39,790
it will tell the client look I can't
 

1919
00:45:39,790 --> 00:45:42,870
it will tell the client look I can't
answer that try again later and this

1920
00:45:42,870 --> 00:45:42,880
answer that try again later and this
 

1921
00:45:42,880 --> 00:45:44,520
answer that try again later and this
would come up like there was a power

1922
00:45:44,520 --> 00:45:44,530
would come up like there was a power
 

1923
00:45:44,530 --> 00:45:45,839
would come up like there was a power
failure in the building and all the

1924
00:45:45,839 --> 00:45:45,849
failure in the building and all the
 

1925
00:45:45,849 --> 00:45:47,069
failure in the building and all the
server's crashed and we're slowly

1926
00:45:47,069 --> 00:45:47,079
server's crashed and we're slowly
 

1927
00:45:47,079 --> 00:45:49,500
server's crashed and we're slowly
rebooting the master might come up first

1928
00:45:49,500 --> 00:45:49,510
rebooting the master might come up first
 

1929
00:45:49,510 --> 00:45:51,420
rebooting the master might come up first
and you know some fraction of the chunk

1930
00:45:51,420 --> 00:45:51,430
and you know some fraction of the chunk
 

1931
00:45:51,430 --> 00:45:53,069
and you know some fraction of the chunk
servers might be up and other ones would

1932
00:45:53,069 --> 00:45:53,079
servers might be up and other ones would
 

1933
00:45:53,079 --> 00:45:57,599
servers might be up and other ones would
reboot five minutes from now but so we

1934
00:45:57,599 --> 00:45:57,609
reboot five minutes from now but so we
 

1935
00:45:57,609 --> 00:45:59,880
reboot five minutes from now but so we
ask to be prepared to wait and it will

1936
00:45:59,880 --> 00:45:59,890
ask to be prepared to wait and it will
 

1937
00:45:59,890 --> 00:46:02,280
ask to be prepared to wait and it will
wait forever because you don't want to

1938
00:46:02,280 --> 00:46:02,290
wait forever because you don't want to
 

1939
00:46:02,290 --> 00:46:05,430
wait forever because you don't want to
use a stale version of that of a chunk

1940
00:46:05,430 --> 00:46:05,440
use a stale version of that of a chunk
 

1941
00:46:05,440 --> 00:46:09,180
use a stale version of that of a chunk
okay so the master needs to assemble the

1942
00:46:09,180 --> 00:46:09,190
okay so the master needs to assemble the
 

1943
00:46:09,190 --> 00:46:10,530
okay so the master needs to assemble the
list of chunk servers that have the most

1944
00:46:10,530 --> 00:46:10,540
list of chunk servers that have the most
 

1945
00:46:10,540 --> 00:46:12,900
list of chunk servers that have the most
recent version the master knows the most

1946
00:46:12,900 --> 00:46:12,910
recent version the master knows the most
 

1947
00:46:12,910 --> 00:46:14,609
recent version the master knows the most
recent versions stored on disk each

1948
00:46:14,609 --> 00:46:14,619
recent versions stored on disk each
 

1949
00:46:14,619 --> 00:46:16,530
recent versions stored on disk each
chunk server along with each chunk as

1950
00:46:16,530 --> 00:46:16,540
chunk server along with each chunk as
 

1951
00:46:16,540 --> 00:46:18,270
chunk server along with each chunk as
you pointed out also remembers the

1952
00:46:18,270 --> 00:46:18,280
you pointed out also remembers the
 

1953
00:46:18,280 --> 00:46:19,800
you pointed out also remembers the
version number of the chunk that it's

1954
00:46:19,800 --> 00:46:19,810
version number of the chunk that it's
 

1955
00:46:19,810 --> 00:46:22,530
version number of the chunk that it's
stores so that when chunk slivers

1956
00:46:22,530 --> 00:46:22,540
stores so that when chunk slivers
 

1957
00:46:22,540 --> 00:46:23,849
stores so that when chunk slivers
reported into the master saying look I

1958
00:46:23,849 --> 00:46:23,859
reported into the master saying look I
 

1959
00:46:23,859 --> 00:46:25,680
reported into the master saying look I
have this chunk the master can ignore

1960
00:46:25,680 --> 00:46:25,690
have this chunk the master can ignore
 

1961
00:46:25,690 --> 00:46:27,750
have this chunk the master can ignore
the ones whose version does not match

1962
00:46:27,750 --> 00:46:27,760
the ones whose version does not match
 

1963
00:46:27,760 --> 00:46:30,329
the ones whose version does not match
the version the master knows is the most

1964
00:46:30,329 --> 00:46:30,339
the version the master knows is the most
 

1965
00:46:30,339 --> 00:46:34,859
the version the master knows is the most
recent okay so remember we were the

1966
00:46:34,859 --> 00:46:34,869
recent okay so remember we were the
 

1967
00:46:34,869 --> 00:46:36,660
recent okay so remember we were the
client want to append the master doesn't

1968
00:46:36,660 --> 00:46:36,670
client want to append the master doesn't
 

1969
00:46:36,670 --> 00:46:39,569
client want to append the master doesn't
have a primary it figures out maybe you

1970
00:46:39,569 --> 00:46:39,579
have a primary it figures out maybe you
 

1971
00:46:39,579 --> 00:46:42,300
have a primary it figures out maybe you
have to wait for the set of chunk

1972
00:46:42,300 --> 00:46:42,310
have to wait for the set of chunk
 

1973
00:46:42,310 --> 00:46:43,950
have to wait for the set of chunk
servers that have the most recent

1974
00:46:43,950 --> 00:46:43,960
servers that have the most recent
 

1975
00:46:43,960 --> 00:46:50,030
servers that have the most recent
version of that chunk it picks a primary

1976
00:46:50,030 --> 00:46:50,040

 

1977
00:46:50,040 --> 00:46:52,920

so I'm gonna pick one of them to be the

1978
00:46:52,920 --> 00:46:52,930
so I'm gonna pick one of them to be the
 

1979
00:46:52,930 --> 00:46:56,099
so I'm gonna pick one of them to be the
primary and the others to be secondary

1980
00:46:56,099 --> 00:46:56,109
primary and the others to be secondary
 

1981
00:46:56,109 --> 00:46:56,849
primary and the others to be secondary
servers

1982
00:46:56,849 --> 00:46:56,859
servers
 

1983
00:46:56,859 --> 00:46:58,200
servers
among the replicas set at the most

1984
00:46:58,200 --> 00:46:58,210
among the replicas set at the most
 

1985
00:46:58,210 --> 00:47:02,130
among the replicas set at the most
recent version the master then

1986
00:47:02,130 --> 00:47:02,140
recent version the master then
 

1987
00:47:02,140 --> 00:47:07,560
recent version the master then
increments

1988
00:47:07,560 --> 00:47:07,570

 

1989
00:47:07,570 --> 00:47:11,160

the version number and writes that to

1990
00:47:11,160 --> 00:47:11,170
the version number and writes that to
 

1991
00:47:11,170 --> 00:47:13,590
the version number and writes that to
disk so it doesn't forget it the crashes

1992
00:47:13,590 --> 00:47:13,600
disk so it doesn't forget it the crashes
 

1993
00:47:13,600 --> 00:47:15,960
disk so it doesn't forget it the crashes
and then it sends the primary in the

1994
00:47:15,960 --> 00:47:15,970
and then it sends the primary in the
 

1995
00:47:15,970 --> 00:47:18,690
and then it sends the primary in the
secondaries and that's each of them a

1996
00:47:18,690 --> 00:47:18,700
secondaries and that's each of them a
 

1997
00:47:18,700 --> 00:47:20,700
secondaries and that's each of them a
message saying look for this chunk

1998
00:47:20,700 --> 00:47:20,710
message saying look for this chunk
 

1999
00:47:20,710 --> 00:47:22,830
message saying look for this chunk
here's the primary here's the

2000
00:47:22,830 --> 00:47:22,840
here's the primary here's the
 

2001
00:47:22,840 --> 00:47:26,640
here's the primary here's the
secondaries you know recipient maybe one

2002
00:47:26,640 --> 00:47:26,650
secondaries you know recipient maybe one
 

2003
00:47:26,650 --> 00:47:28,440
secondaries you know recipient maybe one
of them and here's the new version

2004
00:47:28,440 --> 00:47:28,450
of them and here's the new version
 

2005
00:47:28,450 --> 00:47:32,160
of them and here's the new version
number so then it tells primary

2006
00:47:32,160 --> 00:47:32,170
number so then it tells primary
 

2007
00:47:32,170 --> 00:47:37,050
number so then it tells primary
secondaries this information plus the

2008
00:47:37,050 --> 00:47:37,060
secondaries this information plus the
 

2009
00:47:37,060 --> 00:47:39,480
secondaries this information plus the
version number the primaries and

2010
00:47:39,480 --> 00:47:39,490
version number the primaries and
 

2011
00:47:39,490 --> 00:47:39,960
version number the primaries and
secondaries

2012
00:47:39,960 --> 00:47:39,970
secondaries
 

2013
00:47:39,970 --> 00:47:41,910
secondaries
alright the version number to disk so

2014
00:47:41,910 --> 00:47:41,920
alright the version number to disk so
 

2015
00:47:41,920 --> 00:47:43,770
alright the version number to disk so
they don't forget because you know if

2016
00:47:43,770 --> 00:47:43,780
they don't forget because you know if
 

2017
00:47:43,780 --> 00:47:45,030
they don't forget because you know if
there's a power failure or whatever they

2018
00:47:45,030 --> 00:47:45,040
there's a power failure or whatever they
 

2019
00:47:45,040 --> 00:47:47,130
there's a power failure or whatever they
have to report in to the master with the

2020
00:47:47,130 --> 00:47:47,140
have to report in to the master with the
 

2021
00:47:47,140 --> 00:48:04,220
have to report in to the master with the
actual version number they hold yes

2022
00:48:04,220 --> 00:48:04,230

 

2023
00:48:04,230 --> 00:48:06,180

that's a great question

2024
00:48:06,180 --> 00:48:06,190
that's a great question
 

2025
00:48:06,190 --> 00:48:08,490
that's a great question
so I don't know there's hints in the

2026
00:48:08,490 --> 00:48:08,500
so I don't know there's hints in the
 

2027
00:48:08,500 --> 00:48:11,160
so I don't know there's hints in the
paper that I'm slightly wrong about this

2028
00:48:11,160 --> 00:48:11,170
paper that I'm slightly wrong about this
 

2029
00:48:11,170 --> 00:48:14,730
paper that I'm slightly wrong about this
so the paper says I think your question

2030
00:48:14,730 --> 00:48:14,740
so the paper says I think your question
 

2031
00:48:14,740 --> 00:48:16,020
so the paper says I think your question
was explaining something to me about the

2032
00:48:16,020 --> 00:48:16,030
was explaining something to me about the
 

2033
00:48:16,030 --> 00:48:18,300
was explaining something to me about the
paper the paper says if the master

2034
00:48:18,300 --> 00:48:18,310
paper the paper says if the master
 

2035
00:48:18,310 --> 00:48:22,470
paper the paper says if the master
reboots and talks to chunk servers and

2036
00:48:22,470 --> 00:48:22,480
reboots and talks to chunk servers and
 

2037
00:48:22,480 --> 00:48:24,210
reboots and talks to chunk servers and
one of the chunk servers reboot reports

2038
00:48:24,210 --> 00:48:24,220
one of the chunk servers reboot reports
 

2039
00:48:24,220 --> 00:48:26,520
one of the chunk servers reboot reports
a version number that's higher than the

2040
00:48:26,520 --> 00:48:26,530
a version number that's higher than the
 

2041
00:48:26,530 --> 00:48:28,530
a version number that's higher than the
version number the master remembers the

2042
00:48:28,530 --> 00:48:28,540
version number the master remembers the
 

2043
00:48:28,540 --> 00:48:31,590
version number the master remembers the
master assumes that there was a failure

2044
00:48:31,590 --> 00:48:31,600
master assumes that there was a failure
 

2045
00:48:31,600 --> 00:48:34,590
master assumes that there was a failure
while it was assigning a new primary and

2046
00:48:34,590 --> 00:48:34,600
while it was assigning a new primary and
 

2047
00:48:34,600 --> 00:48:36,750
while it was assigning a new primary and
adopts the new the higher version number

2048
00:48:36,750 --> 00:48:36,760
adopts the new the higher version number
 

2049
00:48:36,760 --> 00:48:38,850
adopts the new the higher version number
that it heard from a chunk server so it

2050
00:48:38,850 --> 00:48:38,860
that it heard from a chunk server so it
 

2051
00:48:38,860 --> 00:48:42,240
that it heard from a chunk server so it
must be the case that in order to handle

2052
00:48:42,240 --> 00:48:42,250
must be the case that in order to handle
 

2053
00:48:42,250 --> 00:48:48,000
must be the case that in order to handle
a master crash at this point that the

2054
00:48:48,000 --> 00:48:48,010
a master crash at this point that the
 

2055
00:48:48,010 --> 00:48:55,859
a master crash at this point that the
master writes its own version number to

2056
00:48:55,859 --> 00:48:55,869
master writes its own version number to
 

2057
00:48:55,869 --> 00:49:02,520
master writes its own version number to
disk after telling the primaries there's

2058
00:49:02,520 --> 00:49:02,530
disk after telling the primaries there's
 

2059
00:49:02,530 --> 00:49:03,540
disk after telling the primaries there's
a bit of a problem here though because

2060
00:49:03,540 --> 00:49:03,550
a bit of a problem here though because
 

2061
00:49:03,550 --> 00:49:12,400
a bit of a problem here though because
if the was that is there an ACK

2062
00:49:12,400 --> 00:49:12,410

 

2063
00:49:12,410 --> 00:49:17,240

all right so maybe the master tells the

2064
00:49:17,240 --> 00:49:17,250
all right so maybe the master tells the
 

2065
00:49:17,250 --> 00:49:18,800
all right so maybe the master tells the
primaries and backups and that their

2066
00:49:18,800 --> 00:49:18,810
primaries and backups and that their
 

2067
00:49:18,810 --> 00:49:20,390
primaries and backups and that their
primaries and secondaries if they're a

2068
00:49:20,390 --> 00:49:20,400
primaries and secondaries if they're a
 

2069
00:49:20,400 --> 00:49:21,710
primaries and secondaries if they're a
primary secondary tells him the new

2070
00:49:21,710 --> 00:49:21,720
primary secondary tells him the new
 

2071
00:49:21,720 --> 00:49:24,440
primary secondary tells him the new
version number waits for the AK and then

2072
00:49:24,440 --> 00:49:24,450
version number waits for the AK and then
 

2073
00:49:24,450 --> 00:49:27,860
version number waits for the AK and then
writes to disk or something unsatisfying

2074
00:49:27,860 --> 00:49:27,870
writes to disk or something unsatisfying
 

2075
00:49:27,870 --> 00:49:37,760
writes to disk or something unsatisfying
about this I don't believe that works

2076
00:49:37,760 --> 00:49:37,770
about this I don't believe that works
 

2077
00:49:37,770 --> 00:49:40,370
about this I don't believe that works
because of the possibility that the

2078
00:49:40,370 --> 00:49:40,380
because of the possibility that the
 

2079
00:49:40,380 --> 00:49:41,930
because of the possibility that the
chunk servers with the most recent

2080
00:49:41,930 --> 00:49:41,940
chunk servers with the most recent
 

2081
00:49:41,940 --> 00:49:44,180
chunk servers with the most recent
version numbers being offline at the

2082
00:49:44,180 --> 00:49:44,190
version numbers being offline at the
 

2083
00:49:44,190 --> 00:49:46,640
version numbers being offline at the
time the master reboots we wouldn't want

2084
00:49:46,640 --> 00:49:46,650
time the master reboots we wouldn't want
 

2085
00:49:46,650 --> 00:49:48,350
time the master reboots we wouldn't want
the master the master doesn't know the

2086
00:49:48,350 --> 00:49:48,360
the master the master doesn't know the
 

2087
00:49:48,360 --> 00:49:50,600
the master the master doesn't know the
current version number it'll just accept

2088
00:49:50,600 --> 00:49:50,610
current version number it'll just accept
 

2089
00:49:50,610 --> 00:49:51,950
current version number it'll just accept
whatever highest version number adheres

2090
00:49:51,950 --> 00:49:51,960
whatever highest version number adheres
 

2091
00:49:51,960 --> 00:49:54,290
whatever highest version number adheres
which could be an old version number all

2092
00:49:54,290 --> 00:49:54,300
which could be an old version number all
 

2093
00:49:54,300 --> 00:49:56,990
which could be an old version number all
right so this is a an area of my

2094
00:49:56,990 --> 00:49:57,000
right so this is a an area of my
 

2095
00:49:57,000 --> 00:49:58,250
right so this is a an area of my
ignorance I don't really understand

2096
00:49:58,250 --> 00:49:58,260
ignorance I don't really understand
 

2097
00:49:58,260 --> 00:50:00,560
ignorance I don't really understand
whether the master update system version

2098
00:50:00,560 --> 00:50:00,570
whether the master update system version
 

2099
00:50:00,570 --> 00:50:01,790
whether the master update system version
number on this first and then tells the

2100
00:50:01,790 --> 00:50:01,800
number on this first and then tells the
 

2101
00:50:01,800 --> 00:50:03,590
number on this first and then tells the
primary secondary or the other way

2102
00:50:03,590 --> 00:50:03,600
primary secondary or the other way
 

2103
00:50:03,600 --> 00:50:06,350
primary secondary or the other way
around and I'm not sure it works either

2104
00:50:06,350 --> 00:50:06,360
around and I'm not sure it works either
 

2105
00:50:06,360 --> 00:50:11,330
around and I'm not sure it works either
way okay but in any case one way or

2106
00:50:11,330 --> 00:50:11,340
way okay but in any case one way or
 

2107
00:50:11,340 --> 00:50:12,800
way okay but in any case one way or
another the master update is version

2108
00:50:12,800 --> 00:50:12,810
another the master update is version
 

2109
00:50:12,810 --> 00:50:14,330
another the master update is version
number tells the primary secondary look

2110
00:50:14,330 --> 00:50:14,340
number tells the primary secondary look
 

2111
00:50:14,340 --> 00:50:16,130
number tells the primary secondary look
your primaries and secondaries here's a

2112
00:50:16,130 --> 00:50:16,140
your primaries and secondaries here's a
 

2113
00:50:16,140 --> 00:50:17,690
your primaries and secondaries here's a
new version number and so now we have a

2114
00:50:17,690 --> 00:50:17,700
new version number and so now we have a
 

2115
00:50:17,700 --> 00:50:19,400
new version number and so now we have a
primary which is able to accept writes

2116
00:50:19,400 --> 00:50:19,410
primary which is able to accept writes
 

2117
00:50:19,410 --> 00:50:21,470
primary which is able to accept writes
all right that's what the primaries job

2118
00:50:21,470 --> 00:50:21,480
all right that's what the primaries job
 

2119
00:50:21,480 --> 00:50:23,720
all right that's what the primaries job
is to take rights from clients and

2120
00:50:23,720 --> 00:50:23,730
is to take rights from clients and
 

2121
00:50:23,730 --> 00:50:26,750
is to take rights from clients and
organize applying those rights to the

2122
00:50:26,750 --> 00:50:26,760
organize applying those rights to the
 

2123
00:50:26,760 --> 00:50:35,120
organize applying those rights to the
various chunk servers and you know the

2124
00:50:35,120 --> 00:50:35,130
various chunk servers and you know the
 

2125
00:50:35,130 --> 00:50:36,440
various chunk servers and you know the
reason for the version number stuff is

2126
00:50:36,440 --> 00:50:36,450
reason for the version number stuff is
 

2127
00:50:36,450 --> 00:50:44,410
reason for the version number stuff is
so that the master will recognize the

2128
00:50:44,410 --> 00:50:44,420

 

2129
00:50:44,420 --> 00:50:50,230

which servers have this new you know the

2130
00:50:50,230 --> 00:50:50,240

 

2131
00:50:50,240 --> 00:50:52,790

master hands out the ability to be

2132
00:50:52,790 --> 00:50:52,800
master hands out the ability to be
 

2133
00:50:52,800 --> 00:50:55,310
master hands out the ability to be
primary for some chunk server we want to

2134
00:50:55,310 --> 00:50:55,320
primary for some chunk server we want to
 

2135
00:50:55,320 --> 00:50:58,940
primary for some chunk server we want to
be able to recognize if the master

2136
00:50:58,940 --> 00:50:58,950
be able to recognize if the master
 

2137
00:50:58,950 --> 00:51:01,250
be able to recognize if the master
crashes you know that it was that was

2138
00:51:01,250 --> 00:51:01,260
crashes you know that it was that was
 

2139
00:51:01,260 --> 00:51:03,830
crashes you know that it was that was
the primary that only that primary and

2140
00:51:03,830 --> 00:51:03,840
the primary that only that primary and
 

2141
00:51:03,840 --> 00:51:05,060
the primary that only that primary and
it secondaries which were actually

2142
00:51:05,060 --> 00:51:05,070
it secondaries which were actually
 

2143
00:51:05,070 --> 00:51:06,710
it secondaries which were actually
processed which were in charge of

2144
00:51:06,710 --> 00:51:06,720
processed which were in charge of
 

2145
00:51:06,720 --> 00:51:08,240
processed which were in charge of
updating that chunk that only those

2146
00:51:08,240 --> 00:51:08,250
updating that chunk that only those
 

2147
00:51:08,250 --> 00:51:10,520
updating that chunk that only those
primaries and secondaries are allowed to

2148
00:51:10,520 --> 00:51:10,530
primaries and secondaries are allowed to
 

2149
00:51:10,530 --> 00:51:12,620
primaries and secondaries are allowed to
be chunk servers in the future and the

2150
00:51:12,620 --> 00:51:12,630
be chunk servers in the future and the
 

2151
00:51:12,630 --> 00:51:14,060
be chunk servers in the future and the
way the master does this is with this

2152
00:51:14,060 --> 00:51:14,070
way the master does this is with this
 

2153
00:51:14,070 --> 00:51:17,470
way the master does this is with this
version number logic

2154
00:51:17,470 --> 00:51:17,480

 

2155
00:51:17,480 --> 00:51:21,490

okay so the master tells the primaries

2156
00:51:21,490 --> 00:51:21,500
okay so the master tells the primaries
 

2157
00:51:21,500 --> 00:51:23,109
okay so the master tells the primaries
and secondaries that there it they're

2158
00:51:23,109 --> 00:51:23,119
and secondaries that there it they're
 

2159
00:51:23,119 --> 00:51:24,730
and secondaries that there it they're
allowed to modify this block it also

2160
00:51:24,730 --> 00:51:24,740
allowed to modify this block it also
 

2161
00:51:24,740 --> 00:51:27,520
allowed to modify this block it also
gives the primary a lease which

2162
00:51:27,520 --> 00:51:27,530
gives the primary a lease which
 

2163
00:51:27,530 --> 00:51:29,380
gives the primary a lease which
basically tells the primary look you're

2164
00:51:29,380 --> 00:51:29,390
basically tells the primary look you're
 

2165
00:51:29,390 --> 00:51:31,089
basically tells the primary look you're
allowed to be primary for the next sixty

2166
00:51:31,089 --> 00:51:31,099
allowed to be primary for the next sixty
 

2167
00:51:31,099 --> 00:51:33,190
allowed to be primary for the next sixty
seconds after sixty Seconds you have to

2168
00:51:33,190 --> 00:51:33,200
seconds after sixty Seconds you have to
 

2169
00:51:33,200 --> 00:51:37,270
seconds after sixty Seconds you have to
stop and this is part of the machinery

2170
00:51:37,270 --> 00:51:37,280
stop and this is part of the machinery
 

2171
00:51:37,280 --> 00:51:39,280
stop and this is part of the machinery
for making sure that we don't end up

2172
00:51:39,280 --> 00:51:39,290
for making sure that we don't end up
 

2173
00:51:39,290 --> 00:51:41,859
for making sure that we don't end up
with two primaries I'll talk about a bit

2174
00:51:41,859 --> 00:51:41,869
with two primaries I'll talk about a bit
 

2175
00:51:41,869 --> 00:51:46,329
with two primaries I'll talk about a bit
later okay so now we were primary now

2176
00:51:46,329 --> 00:51:46,339
later okay so now we were primary now
 

2177
00:51:46,339 --> 00:51:50,079
later okay so now we were primary now
the master tells the client who the

2178
00:51:50,079 --> 00:51:50,089
the master tells the client who the
 

2179
00:51:50,089 --> 00:51:54,430
the master tells the client who the
primary and the secondary czar and at

2180
00:51:54,430 --> 00:51:54,440
primary and the secondary czar and at
 

2181
00:51:54,440 --> 00:51:59,040
primary and the secondary czar and at
this point we're we're executing in

2182
00:51:59,040 --> 00:51:59,050
this point we're we're executing in
 

2183
00:51:59,050 --> 00:52:02,230
this point we're we're executing in
figure two in the paper the client now

2184
00:52:02,230 --> 00:52:02,240
figure two in the paper the client now
 

2185
00:52:02,240 --> 00:52:04,030
figure two in the paper the client now
knows who the primary secondaries are in

2186
00:52:04,030 --> 00:52:04,040
knows who the primary secondaries are in
 

2187
00:52:04,040 --> 00:52:05,650
knows who the primary secondaries are in
some order or another and the paper

2188
00:52:05,650 --> 00:52:05,660
some order or another and the paper
 

2189
00:52:05,660 --> 00:52:08,170
some order or another and the paper
explains a sort of clever way to manage

2190
00:52:08,170 --> 00:52:08,180
explains a sort of clever way to manage
 

2191
00:52:08,180 --> 00:52:10,839
explains a sort of clever way to manage
this in some order or another the client

2192
00:52:10,839 --> 00:52:10,849
this in some order or another the client
 

2193
00:52:10,849 --> 00:52:13,240
this in some order or another the client
sends a copy of the data it wants to be

2194
00:52:13,240 --> 00:52:13,250
sends a copy of the data it wants to be
 

2195
00:52:13,250 --> 00:52:15,220
sends a copy of the data it wants to be
appended to the primary in all the

2196
00:52:15,220 --> 00:52:15,230
appended to the primary in all the
 

2197
00:52:15,230 --> 00:52:18,430
appended to the primary in all the
secondaries and the primary in the

2198
00:52:18,430 --> 00:52:18,440
secondaries and the primary in the
 

2199
00:52:18,440 --> 00:52:20,380
secondaries and the primary in the
secondaries write that data to a

2200
00:52:20,380 --> 00:52:20,390
secondaries write that data to a
 

2201
00:52:20,390 --> 00:52:22,089
secondaries write that data to a
temporary location it's not appended to

2202
00:52:22,089 --> 00:52:22,099
temporary location it's not appended to
 

2203
00:52:22,099 --> 00:52:24,370
temporary location it's not appended to
the file yet after they've all said yes

2204
00:52:24,370 --> 00:52:24,380
the file yet after they've all said yes
 

2205
00:52:24,380 --> 00:52:29,170
the file yet after they've all said yes
we have the data the client sends a

2206
00:52:29,170 --> 00:52:29,180
we have the data the client sends a
 

2207
00:52:29,180 --> 00:52:31,120
we have the data the client sends a
message to the primary saying look you

2208
00:52:31,120 --> 00:52:31,130
message to the primary saying look you
 

2209
00:52:31,130 --> 00:52:33,460
message to the primary saying look you
know you and all the secondaries have

2210
00:52:33,460 --> 00:52:33,470
know you and all the secondaries have
 

2211
00:52:33,470 --> 00:52:35,559
know you and all the secondaries have
the data I'd like to append it for this

2212
00:52:35,559 --> 00:52:35,569
the data I'd like to append it for this
 

2213
00:52:35,569 --> 00:52:36,569
the data I'd like to append it for this
file

2214
00:52:36,569 --> 00:52:36,579
file
 

2215
00:52:36,579 --> 00:52:38,950
file
the primary maybe is receiving these

2216
00:52:38,950 --> 00:52:38,960
the primary maybe is receiving these
 

2217
00:52:38,960 --> 00:52:40,510
the primary maybe is receiving these
requests from lots of different clients

2218
00:52:40,510 --> 00:52:40,520
requests from lots of different clients
 

2219
00:52:40,520 --> 00:52:43,000
requests from lots of different clients
concurrently it picks some order execute

2220
00:52:43,000 --> 00:52:43,010
concurrently it picks some order execute
 

2221
00:52:43,010 --> 00:52:45,250
concurrently it picks some order execute
the client request one at a time and for

2222
00:52:45,250 --> 00:52:45,260
the client request one at a time and for
 

2223
00:52:45,260 --> 00:52:48,250
the client request one at a time and for
each client a pen request the primary

2224
00:52:48,250 --> 00:52:48,260
each client a pen request the primary
 

2225
00:52:48,260 --> 00:52:50,440
each client a pen request the primary
looks at the offset that's the end of

2226
00:52:50,440 --> 00:52:50,450
looks at the offset that's the end of
 

2227
00:52:50,450 --> 00:52:53,020
looks at the offset that's the end of
the file the current end of the current

2228
00:52:53,020 --> 00:52:53,030
the file the current end of the current
 

2229
00:52:53,030 --> 00:52:54,730
the file the current end of the current
chunk makes sure there's enough

2230
00:52:54,730 --> 00:52:54,740
chunk makes sure there's enough
 

2231
00:52:54,740 --> 00:52:56,470
chunk makes sure there's enough
remaining space in the chunk and then

2232
00:52:56,470 --> 00:52:56,480
remaining space in the chunk and then
 

2233
00:52:56,480 --> 00:52:59,950
remaining space in the chunk and then
tells then writes the clients record to

2234
00:52:59,950 --> 00:52:59,960
tells then writes the clients record to
 

2235
00:52:59,960 --> 00:53:02,230
tells then writes the clients record to
the end of the current chunk and tells

2236
00:53:02,230 --> 00:53:02,240
the end of the current chunk and tells
 

2237
00:53:02,240 --> 00:53:04,359
the end of the current chunk and tells
all the secondaries to also write the

2238
00:53:04,359 --> 00:53:04,369
all the secondaries to also write the
 

2239
00:53:04,369 --> 00:53:08,349
all the secondaries to also write the
clients data to the end to the same

2240
00:53:08,349 --> 00:53:08,359
clients data to the end to the same
 

2241
00:53:08,359 --> 00:53:12,000
clients data to the end to the same
offset the same offset in their chunks

2242
00:53:12,000 --> 00:53:12,010
offset the same offset in their chunks
 

2243
00:53:12,010 --> 00:53:20,490
offset the same offset in their chunks
all right so the primary picks an offset

2244
00:53:20,490 --> 00:53:20,500
all right so the primary picks an offset
 

2245
00:53:20,500 --> 00:53:26,470
all right so the primary picks an offset
all the replicas including the primary

2246
00:53:26,470 --> 00:53:26,480
all the replicas including the primary
 

2247
00:53:26,480 --> 00:53:29,170
all the replicas including the primary
are told to write

2248
00:53:29,170 --> 00:53:29,180
are told to write
 

2249
00:53:29,180 --> 00:53:36,080
are told to write
the new appended record at at offset the

2250
00:53:36,080 --> 00:53:36,090
the new appended record at at offset the
 

2251
00:53:36,090 --> 00:53:38,690
the new appended record at at offset the
secondary's they may do it they may not

2252
00:53:38,690 --> 00:53:38,700
secondary's they may do it they may not
 

2253
00:53:38,700 --> 00:53:41,240
secondary's they may do it they may not
do it I'm either run out of space maybe

2254
00:53:41,240 --> 00:53:41,250
do it I'm either run out of space maybe
 

2255
00:53:41,250 --> 00:53:42,800
do it I'm either run out of space maybe
they crashed maybe the network message

2256
00:53:42,800 --> 00:53:42,810
they crashed maybe the network message
 

2257
00:53:42,810 --> 00:53:45,470
they crashed maybe the network message
was lost from the primary so if a

2258
00:53:45,470 --> 00:53:45,480
was lost from the primary so if a
 

2259
00:53:45,480 --> 00:53:47,960
was lost from the primary so if a
secondary actually wrote the data to its

2260
00:53:47,960 --> 00:53:47,970
secondary actually wrote the data to its
 

2261
00:53:47,970 --> 00:53:50,750
secondary actually wrote the data to its
disk at that offset it will reply yes to

2262
00:53:50,750 --> 00:53:50,760
disk at that offset it will reply yes to
 

2263
00:53:50,760 --> 00:53:52,849
disk at that offset it will reply yes to
the primary if the primary collects a

2264
00:53:52,849 --> 00:53:52,859
the primary if the primary collects a
 

2265
00:53:52,859 --> 00:53:58,510
the primary if the primary collects a
yes answer from all of the secondaries

2266
00:53:58,510 --> 00:53:58,520

 

2267
00:53:58,520 --> 00:54:02,180

so if they all of all of them managed to

2268
00:54:02,180 --> 00:54:02,190
so if they all of all of them managed to
 

2269
00:54:02,190 --> 00:54:03,620
so if they all of all of them managed to
actually write and reply to the primary

2270
00:54:03,620 --> 00:54:03,630
actually write and reply to the primary
 

2271
00:54:03,630 --> 00:54:08,240
actually write and reply to the primary
saying yes I did it then the primary is

2272
00:54:08,240 --> 00:54:08,250
saying yes I did it then the primary is
 

2273
00:54:08,250 --> 00:54:10,790
saying yes I did it then the primary is
going to reply reply success to the

2274
00:54:10,790 --> 00:54:10,800
going to reply reply success to the
 

2275
00:54:10,800 --> 00:54:18,920
going to reply reply success to the
client if the primary doesn't get an

2276
00:54:18,920 --> 00:54:18,930
client if the primary doesn't get an
 

2277
00:54:18,930 --> 00:54:21,500
client if the primary doesn't get an
answer from one of the secondaries or

2278
00:54:21,500 --> 00:54:21,510
answer from one of the secondaries or
 

2279
00:54:21,510 --> 00:54:23,570
answer from one of the secondaries or
the secondary reply sorry something bad

2280
00:54:23,570 --> 00:54:23,580
the secondary reply sorry something bad
 

2281
00:54:23,580 --> 00:54:25,580
the secondary reply sorry something bad
happened I ran out of disk space my disk

2282
00:54:25,580 --> 00:54:25,590
happened I ran out of disk space my disk
 

2283
00:54:25,590 --> 00:54:28,970
happened I ran out of disk space my disk
I don't know what then the primary

2284
00:54:28,970 --> 00:54:28,980
I don't know what then the primary
 

2285
00:54:28,980 --> 00:54:37,940
I don't know what then the primary
replies no to the client and the paper

2286
00:54:37,940 --> 00:54:37,950
replies no to the client and the paper
 

2287
00:54:37,950 --> 00:54:39,410
replies no to the client and the paper
says oh if the client gets an error like

2288
00:54:39,410 --> 00:54:39,420
says oh if the client gets an error like
 

2289
00:54:39,420 --> 00:54:41,990
says oh if the client gets an error like
that back in the primary the client is

2290
00:54:41,990 --> 00:54:42,000
that back in the primary the client is
 

2291
00:54:42,000 --> 00:54:44,359
that back in the primary the client is
supposed to reissue the entire append

2292
00:54:44,359 --> 00:54:44,369
supposed to reissue the entire append
 

2293
00:54:44,369 --> 00:54:46,010
supposed to reissue the entire append
sequence starting again talking to the

2294
00:54:46,010 --> 00:54:46,020
sequence starting again talking to the
 

2295
00:54:46,020 --> 00:54:48,520
sequence starting again talking to the
master to find out the most grease the

2296
00:54:48,520 --> 00:54:48,530
master to find out the most grease the
 

2297
00:54:48,530 --> 00:54:50,359
master to find out the most grease the
chunk at the end of the file

2298
00:54:50,359 --> 00:54:50,369
chunk at the end of the file
 

2299
00:54:50,369 --> 00:54:52,490
chunk at the end of the file
I want to know the client supposed to

2300
00:54:52,490 --> 00:54:52,500
I want to know the client supposed to
 

2301
00:54:52,500 --> 00:54:54,290
I want to know the client supposed to
reissue the whole record append

2302
00:54:54,290 --> 00:54:54,300
reissue the whole record append
 

2303
00:54:54,300 --> 00:55:01,640
reissue the whole record append
operation ah you would think but they

2304
00:55:01,640 --> 00:55:01,650
operation ah you would think but they
 

2305
00:55:01,650 --> 00:55:05,170
operation ah you would think but they
don't so the question is jeez you know

2306
00:55:05,170 --> 00:55:05,180
don't so the question is jeez you know
 

2307
00:55:05,180 --> 00:55:08,210
don't so the question is jeez you know
the the primary tells all the replicas

2308
00:55:08,210 --> 00:55:08,220
the the primary tells all the replicas
 

2309
00:55:08,220 --> 00:55:09,859
the the primary tells all the replicas
to do the append yeah maybe some of them

2310
00:55:09,859 --> 00:55:09,869
to do the append yeah maybe some of them
 

2311
00:55:09,869 --> 00:55:10,820
to do the append yeah maybe some of them
do some of them don't

2312
00:55:10,820 --> 00:55:10,830
do some of them don't
 

2313
00:55:10,830 --> 00:55:12,859
do some of them don't
right if some of them don't then we

2314
00:55:12,859 --> 00:55:12,869
right if some of them don't then we
 

2315
00:55:12,869 --> 00:55:14,450
right if some of them don't then we
apply an error to the client so the

2316
00:55:14,450 --> 00:55:14,460
apply an error to the client so the
 

2317
00:55:14,460 --> 00:55:16,099
apply an error to the client so the
client thinks of the append in happen

2318
00:55:16,099 --> 00:55:16,109
client thinks of the append in happen
 

2319
00:55:16,109 --> 00:55:18,620
client thinks of the append in happen
but those other replicas where the pen

2320
00:55:18,620 --> 00:55:18,630
but those other replicas where the pen
 

2321
00:55:18,630 --> 00:55:23,540
but those other replicas where the pen
succeeded they did append so now we have

2322
00:55:23,540 --> 00:55:23,550
succeeded they did append so now we have
 

2323
00:55:23,550 --> 00:55:25,390
succeeded they did append so now we have
replicas donor the same data one of them

2324
00:55:25,390 --> 00:55:25,400
replicas donor the same data one of them
 

2325
00:55:25,400 --> 00:55:27,470
replicas donor the same data one of them
the one that returned in error didn't do

2326
00:55:27,470 --> 00:55:27,480
the one that returned in error didn't do
 

2327
00:55:27,480 --> 00:55:28,880
the one that returned in error didn't do
the append and the ones they returned

2328
00:55:28,880 --> 00:55:28,890
the append and the ones they returned
 

2329
00:55:28,890 --> 00:55:31,820
the append and the ones they returned
yes did do the append so that is just

2330
00:55:31,820 --> 00:55:31,830
yes did do the append so that is just
 

2331
00:55:31,830 --> 00:55:44,580
yes did do the append so that is just
the way GFS works

2332
00:55:44,580 --> 00:55:44,590

 

2333
00:55:44,590 --> 00:55:47,580

yeah so if a reader then reads this file

2334
00:55:47,580 --> 00:55:47,590
yeah so if a reader then reads this file
 

2335
00:55:47,590 --> 00:55:50,320
yeah so if a reader then reads this file
they depending on what replica they be

2336
00:55:50,320 --> 00:55:50,330
they depending on what replica they be
 

2337
00:55:50,330 --> 00:55:53,350
they depending on what replica they be
they may either see the appended record

2338
00:55:53,350 --> 00:55:53,360
they may either see the appended record
 

2339
00:55:53,360 --> 00:55:56,800
they may either see the appended record
or they may not if the record append

2340
00:55:56,800 --> 00:55:56,810
or they may not if the record append
 

2341
00:55:56,810 --> 00:55:59,110
or they may not if the record append
but if the record append succeeded if

2342
00:55:59,110 --> 00:55:59,120
but if the record append succeeded if
 

2343
00:55:59,120 --> 00:56:00,910
but if the record append succeeded if
the client got a success message back

2344
00:56:00,910 --> 00:56:00,920
the client got a success message back
 

2345
00:56:00,920 --> 00:56:03,910
the client got a success message back
then that means all of the replicas

2346
00:56:03,910 --> 00:56:03,920
then that means all of the replicas
 

2347
00:56:03,920 --> 00:56:05,410
then that means all of the replicas
appended that record at the same offset

2348
00:56:05,410 --> 00:56:05,420
appended that record at the same offset
 

2349
00:56:05,420 --> 00:56:10,150
appended that record at the same offset
if the client gets a no back then zero

2350
00:56:10,150 --> 00:56:10,160
if the client gets a no back then zero
 

2351
00:56:10,160 --> 00:56:14,080
if the client gets a no back then zero
or more of the replicas may have

2352
00:56:14,080 --> 00:56:14,090
or more of the replicas may have
 

2353
00:56:14,090 --> 00:56:15,730
or more of the replicas may have
appended the record of that all set and

2354
00:56:15,730 --> 00:56:15,740
appended the record of that all set and
 

2355
00:56:15,740 --> 00:56:20,230
appended the record of that all set and
the other ones not so the client got to

2356
00:56:20,230 --> 00:56:20,240
the other ones not so the client got to
 

2357
00:56:20,240 --> 00:56:22,270
the other ones not so the client got to
know then that means that some replicas

2358
00:56:22,270 --> 00:56:22,280
know then that means that some replicas
 

2359
00:56:22,280 --> 00:56:25,120
know then that means that some replicas
maybe some replicas have the record and

2360
00:56:25,120 --> 00:56:25,130
maybe some replicas have the record and
 

2361
00:56:25,130 --> 00:56:27,850
maybe some replicas have the record and
some don't so what you which were

2362
00:56:27,850 --> 00:56:27,860
some don't so what you which were
 

2363
00:56:27,860 --> 00:56:29,740
some don't so what you which were
roughly read from you know you may or

2364
00:56:29,740 --> 00:56:29,750
roughly read from you know you may or
 

2365
00:56:29,750 --> 00:56:39,400
roughly read from you know you may or
may not see the record yeah

2366
00:56:39,400 --> 00:56:39,410

 

2367
00:56:39,410 --> 00:56:45,309

oh that all the replicas are the same

2368
00:56:45,309 --> 00:56:45,319
oh that all the replicas are the same
 

2369
00:56:45,319 --> 00:56:47,230
oh that all the replicas are the same
all the secondaries are the same version

2370
00:56:47,230 --> 00:56:47,240
all the secondaries are the same version
 

2371
00:56:47,240 --> 00:56:49,420
all the secondaries are the same version
number so the version number only

2372
00:56:49,420 --> 00:56:49,430
number so the version number only
 

2373
00:56:49,430 --> 00:56:51,490
number so the version number only
changes when the master assigns a new

2374
00:56:51,490 --> 00:56:51,500
changes when the master assigns a new
 

2375
00:56:51,500 --> 00:56:53,890
changes when the master assigns a new
primary which would ordinarily happen

2376
00:56:53,890 --> 00:56:53,900
primary which would ordinarily happen
 

2377
00:56:53,900 --> 00:56:55,299
primary which would ordinarily happen
and probably only happen if the primary

2378
00:56:55,299 --> 00:56:55,309
and probably only happen if the primary
 

2379
00:56:55,309 --> 00:56:58,260
and probably only happen if the primary
failed so what we're talking about is is

2380
00:56:58,260 --> 00:56:58,270
failed so what we're talking about is is
 

2381
00:56:58,270 --> 00:57:00,190
failed so what we're talking about is is
replicas that have the fresh version

2382
00:57:00,190 --> 00:57:00,200
replicas that have the fresh version
 

2383
00:57:00,200 --> 00:57:02,650
replicas that have the fresh version
number all right and you can't tell from

2384
00:57:02,650 --> 00:57:02,660
number all right and you can't tell from
 

2385
00:57:02,660 --> 00:57:03,730
number all right and you can't tell from
looking at them that they're missing

2386
00:57:03,730 --> 00:57:03,740
looking at them that they're missing
 

2387
00:57:03,740 --> 00:57:08,049
looking at them that they're missing
that the replicas are different but

2388
00:57:08,049 --> 00:57:08,059
that the replicas are different but
 

2389
00:57:08,059 --> 00:57:09,309
that the replicas are different but
maybe they're different and the

2390
00:57:09,309 --> 00:57:09,319
maybe they're different and the
 

2391
00:57:09,319 --> 00:57:11,380
maybe they're different and the
justification for this is that yeah you

2392
00:57:11,380 --> 00:57:11,390
justification for this is that yeah you
 

2393
00:57:11,390 --> 00:57:13,150
justification for this is that yeah you
know maybe the replicas don't all have

2394
00:57:13,150 --> 00:57:13,160
know maybe the replicas don't all have
 

2395
00:57:13,160 --> 00:57:16,089
know maybe the replicas don't all have
that the appended record but that's the

2396
00:57:16,089 --> 00:57:16,099
that the appended record but that's the
 

2397
00:57:16,099 --> 00:57:18,190
that the appended record but that's the
case in which the primary answer no to

2398
00:57:18,190 --> 00:57:18,200
case in which the primary answer no to
 

2399
00:57:18,200 --> 00:57:20,170
case in which the primary answer no to
the clients and the client knows that

2400
00:57:20,170 --> 00:57:20,180
the clients and the client knows that
 

2401
00:57:20,180 --> 00:57:22,930
the clients and the client knows that
the write failed and the reasoning

2402
00:57:22,930 --> 00:57:22,940
the write failed and the reasoning
 

2403
00:57:22,940 --> 00:57:24,400
the write failed and the reasoning
behind this is that then the client

2404
00:57:24,400 --> 00:57:24,410
behind this is that then the client
 

2405
00:57:24,410 --> 00:57:27,849
behind this is that then the client
library will reissue the append so the

2406
00:57:27,849 --> 00:57:27,859
library will reissue the append so the
 

2407
00:57:27,859 --> 00:57:29,470
library will reissue the append so the
appended record will show up you know

2408
00:57:29,470 --> 00:57:29,480
appended record will show up you know
 

2409
00:57:29,480 --> 00:57:33,250
appended record will show up you know
eventually the a pendel succeed you

2410
00:57:33,250 --> 00:57:33,260
eventually the a pendel succeed you
 

2411
00:57:33,260 --> 00:57:36,910
eventually the a pendel succeed you
would think because the client I'll keep

2412
00:57:36,910 --> 00:57:36,920
would think because the client I'll keep
 

2413
00:57:36,920 --> 00:57:38,470
would think because the client I'll keep
reissuing it until succeeds and then

2414
00:57:38,470 --> 00:57:38,480
reissuing it until succeeds and then
 

2415
00:57:38,480 --> 00:57:39,760
reissuing it until succeeds and then
when it succeeds that means there's

2416
00:57:39,760 --> 00:57:39,770
when it succeeds that means there's
 

2417
00:57:39,770 --> 00:57:41,500
when it succeeds that means there's
gonna be some offset you know farther on

2418
00:57:41,500 --> 00:57:41,510
gonna be some offset you know farther on
 

2419
00:57:41,510 --> 00:57:43,450
gonna be some offset you know farther on
in the file where that record actually

2420
00:57:43,450 --> 00:57:43,460
in the file where that record actually
 

2421
00:57:43,460 --> 00:57:45,849
in the file where that record actually
occurs in all the replicas as well as

2422
00:57:45,849 --> 00:57:45,859
occurs in all the replicas as well as
 

2423
00:57:45,859 --> 00:57:48,039
occurs in all the replicas as well as
offsets preceding that word only occurs

2424
00:57:48,039 --> 00:57:48,049
offsets preceding that word only occurs
 

2425
00:57:48,049 --> 00:58:04,670
offsets preceding that word only occurs
in a few of the replicas yes

2426
00:58:04,670 --> 00:58:04,680

 

2427
00:58:04,680 --> 00:58:11,769

oh this is a great question

2428
00:58:11,769 --> 00:58:11,779
oh this is a great question
 

2429
00:58:11,779 --> 00:58:15,680
oh this is a great question
the exact path that the right data takes

2430
00:58:15,680 --> 00:58:15,690
the exact path that the right data takes
 

2431
00:58:15,690 --> 00:58:17,900
the exact path that the right data takes
might be quite important with respect to

2432
00:58:17,900 --> 00:58:17,910
might be quite important with respect to
 

2433
00:58:17,910 --> 00:58:19,400
might be quite important with respect to
the underlying network and the paper

2434
00:58:19,400 --> 00:58:19,410
the underlying network and the paper
 

2435
00:58:19,410 --> 00:58:22,940
the underlying network and the paper
somewhere says even though when the

2436
00:58:22,940 --> 00:58:22,950
somewhere says even though when the
 

2437
00:58:22,950 --> 00:58:24,529
somewhere says even though when the
paper first talks about it he claims

2438
00:58:24,529 --> 00:58:24,539
paper first talks about it he claims
 

2439
00:58:24,539 --> 00:58:26,480
paper first talks about it he claims
that the client sends the data to each

2440
00:58:26,480 --> 00:58:26,490
that the client sends the data to each
 

2441
00:58:26,490 --> 00:58:29,299
that the client sends the data to each
replica in fact later on it changes the

2442
00:58:29,299 --> 00:58:29,309
replica in fact later on it changes the
 

2443
00:58:29,309 --> 00:58:31,279
replica in fact later on it changes the
tune and says the client sends it to

2444
00:58:31,279 --> 00:58:31,289
tune and says the client sends it to
 

2445
00:58:31,289 --> 00:58:33,529
tune and says the client sends it to
only the closest of the replicas and

2446
00:58:33,529 --> 00:58:33,539
only the closest of the replicas and
 

2447
00:58:33,539 --> 00:58:36,349
only the closest of the replicas and
then the replicas then that replica

2448
00:58:36,349 --> 00:58:36,359
then the replicas then that replica
 

2449
00:58:36,359 --> 00:58:37,819
then the replicas then that replica
forwards the data to another replica

2450
00:58:37,819 --> 00:58:37,829
forwards the data to another replica
 

2451
00:58:37,829 --> 00:58:39,620
forwards the data to another replica
along I sort of chained until all the

2452
00:58:39,620 --> 00:58:39,630
along I sort of chained until all the
 

2453
00:58:39,630 --> 00:58:41,930
along I sort of chained until all the
replicas had the data and that path of

2454
00:58:41,930 --> 00:58:41,940
replicas had the data and that path of
 

2455
00:58:41,940 --> 00:58:43,760
replicas had the data and that path of
that chain is taken to sort of minimize

2456
00:58:43,760 --> 00:58:43,770
that chain is taken to sort of minimize
 

2457
00:58:43,770 --> 00:58:46,849
that chain is taken to sort of minimize
crossing bottleneck inter switch links

2458
00:58:46,849 --> 00:58:46,859
crossing bottleneck inter switch links
 

2459
00:58:46,859 --> 00:59:00,380
crossing bottleneck inter switch links
in a data center yes the version number

2460
00:59:00,380 --> 00:59:00,390
in a data center yes the version number
 

2461
00:59:00,390 --> 00:59:03,529
in a data center yes the version number
only gets incremented if the master

2462
00:59:03,529 --> 00:59:03,539
only gets incremented if the master
 

2463
00:59:03,539 --> 00:59:06,109
only gets incremented if the master
thinks there's no primary so it's a so

2464
00:59:06,109 --> 00:59:06,119
thinks there's no primary so it's a so
 

2465
00:59:06,119 --> 00:59:09,349
thinks there's no primary so it's a so
in the ordinary sequence there already

2466
00:59:09,349 --> 00:59:09,359
in the ordinary sequence there already
 

2467
00:59:09,359 --> 00:59:13,700
in the ordinary sequence there already
be a primary for that chunk the the

2468
00:59:13,700 --> 00:59:13,710
be a primary for that chunk the the
 

2469
00:59:13,710 --> 00:59:16,670
be a primary for that chunk the the
the the master sort of will remember oh

2470
00:59:16,670 --> 00:59:16,680
the the master sort of will remember oh
 

2471
00:59:16,680 --> 00:59:18,170
the the master sort of will remember oh
gosh there's already a primary and

2472
00:59:18,170 --> 00:59:18,180
gosh there's already a primary and
 

2473
00:59:18,180 --> 00:59:19,460
gosh there's already a primary and
secondary for that chunk and it'll just

2474
00:59:19,460 --> 00:59:19,470
secondary for that chunk and it'll just
 

2475
00:59:19,470 --> 00:59:20,630
secondary for that chunk and it'll just
it won't go through this master

2476
00:59:20,630 --> 00:59:20,640
it won't go through this master
 

2477
00:59:20,640 --> 00:59:22,069
it won't go through this master
selection it won't increment the version

2478
00:59:22,069 --> 00:59:22,079
selection it won't increment the version
 

2479
00:59:22,079 --> 00:59:24,440
selection it won't increment the version
number it'll just tell the client look

2480
00:59:24,440 --> 00:59:24,450
number it'll just tell the client look
 

2481
00:59:24,450 --> 00:59:26,390
number it'll just tell the client look
up here's the primary with with no

2482
00:59:26,390 --> 00:59:26,400
up here's the primary with with no
 

2483
00:59:26,400 --> 00:59:42,330
up here's the primary with with no
version number change

2484
00:59:42,330 --> 00:59:42,340

 

2485
00:59:42,340 --> 00:59:47,080

my understanding is that if this is this

2486
00:59:47,080 --> 00:59:47,090
my understanding is that if this is this
 

2487
00:59:47,090 --> 00:59:49,120
my understanding is that if this is this
I think you're asking a you're asking an

2488
00:59:49,120 --> 00:59:49,130
I think you're asking a you're asking an
 

2489
00:59:49,130 --> 00:59:51,040
I think you're asking a you're asking an
interesting question so in this scenario

2490
00:59:51,040 --> 00:59:51,050
interesting question so in this scenario
 

2491
00:59:51,050 --> 00:59:52,930
interesting question so in this scenario
in which the primaries isn't answered

2492
00:59:52,930 --> 00:59:52,940
in which the primaries isn't answered
 

2493
00:59:52,940 --> 00:59:54,580
in which the primaries isn't answered
failure to the client you might think

2494
00:59:54,580 --> 00:59:54,590
failure to the client you might think
 

2495
00:59:54,590 --> 00:59:55,990
failure to the client you might think
something must be wrong with something

2496
00:59:55,990 --> 00:59:56,000
something must be wrong with something
 

2497
00:59:56,000 --> 00:59:57,850
something must be wrong with something
and that it should be fixed before you

2498
00:59:57,850 --> 00:59:57,860
and that it should be fixed before you
 

2499
00:59:57,860 --> 00:59:59,860
and that it should be fixed before you
proceed in fact as far as I can tell the

2500
00:59:59,860 --> 00:59:59,870
proceed in fact as far as I can tell the
 

2501
00:59:59,870 --> 01:00:03,310
proceed in fact as far as I can tell the
paper there's no immediate anything the

2502
01:00:03,310 --> 01:00:03,320
paper there's no immediate anything the
 

2503
01:00:03,320 --> 01:00:08,290
paper there's no immediate anything the
client retries the append you know

2504
01:00:08,290 --> 01:00:08,300
client retries the append you know
 

2505
01:00:08,300 --> 01:00:10,000
client retries the append you know
because maybe the problem was a network

2506
01:00:10,000 --> 01:00:10,010
because maybe the problem was a network
 

2507
01:00:10,010 --> 01:00:11,560
because maybe the problem was a network
message got lost so there's nothing to

2508
01:00:11,560 --> 01:00:11,570
message got lost so there's nothing to
 

2509
01:00:11,570 --> 01:00:12,970
message got lost so there's nothing to
repair right you know now we're gonna

2510
01:00:12,970 --> 01:00:12,980
repair right you know now we're gonna
 

2511
01:00:12,980 --> 01:00:13,840
repair right you know now we're gonna
message got lost we should be

2512
01:00:13,840 --> 01:00:13,850
message got lost we should be
 

2513
01:00:13,850 --> 01:00:15,070
message got lost we should be
transmitted and this is sort of a

2514
01:00:15,070 --> 01:00:15,080
transmitted and this is sort of a
 

2515
01:00:15,080 --> 01:00:17,590
transmitted and this is sort of a
complicated way of retransmitting the

2516
01:00:17,590 --> 01:00:17,600
complicated way of retransmitting the
 

2517
01:00:17,600 --> 01:00:19,030
complicated way of retransmitting the
network message maybe that's the most

2518
01:00:19,030 --> 01:00:19,040
network message maybe that's the most
 

2519
01:00:19,040 --> 01:00:21,010
network message maybe that's the most
common kind of failure in that case just

2520
01:00:21,010 --> 01:00:21,020
common kind of failure in that case just
 

2521
01:00:21,020 --> 01:00:22,780
common kind of failure in that case just
we don't change anything it's still the

2522
01:00:22,780 --> 01:00:22,790
we don't change anything it's still the
 

2523
01:00:22,790 --> 01:00:26,740
we don't change anything it's still the
same primary same secondaries the client

2524
01:00:26,740 --> 01:00:26,750
same primary same secondaries the client
 

2525
01:00:26,750 --> 01:00:28,120
same primary same secondaries the client
we tries maybe this time it'll work

2526
01:00:28,120 --> 01:00:28,130
we tries maybe this time it'll work
 

2527
01:00:28,130 --> 01:00:29,260
we tries maybe this time it'll work
because the network doesn't

2528
01:00:29,260 --> 01:00:29,270
because the network doesn't
 

2529
01:00:29,270 --> 01:00:31,480
because the network doesn't
discard a message it's an interesting

2530
01:00:31,480 --> 01:00:31,490
discard a message it's an interesting
 

2531
01:00:31,490 --> 01:00:32,890
discard a message it's an interesting
question though that if what went wrong

2532
01:00:32,890 --> 01:00:32,900
question though that if what went wrong
 

2533
01:00:32,900 --> 01:00:35,500
question though that if what went wrong
here is that one of that there was a

2534
01:00:35,500 --> 01:00:35,510
here is that one of that there was a
 

2535
01:00:35,510 --> 01:00:37,900
here is that one of that there was a
serious error or Fault in one of the

2536
01:00:37,900 --> 01:00:37,910
serious error or Fault in one of the
 

2537
01:00:37,910 --> 01:00:41,140
serious error or Fault in one of the
secondaries what we would like is for

2538
01:00:41,140 --> 01:00:41,150
secondaries what we would like is for
 

2539
01:00:41,150 --> 01:00:43,870
secondaries what we would like is for
the master to reconfigure that set of

2540
01:00:43,870 --> 01:00:43,880
the master to reconfigure that set of
 

2541
01:00:43,880 --> 01:00:46,810
the master to reconfigure that set of
replicas to drop that secondary that's

2542
01:00:46,810 --> 01:00:46,820
replicas to drop that secondary that's
 

2543
01:00:46,820 --> 01:00:49,450
replicas to drop that secondary that's
not working and it would then because

2544
01:00:49,450 --> 01:00:49,460
not working and it would then because
 

2545
01:00:49,460 --> 01:00:50,890
not working and it would then because
it's choosing a new primary in executing

2546
01:00:50,890 --> 01:00:50,900
it's choosing a new primary in executing
 

2547
01:00:50,900 --> 01:00:52,600
it's choosing a new primary in executing
this code path the master would then

2548
01:00:52,600 --> 01:00:52,610
this code path the master would then
 

2549
01:00:52,610 --> 01:00:54,880
this code path the master would then
increment the version and then we have a

2550
01:00:54,880 --> 01:00:54,890
increment the version and then we have a
 

2551
01:00:54,890 --> 01:00:56,740
increment the version and then we have a
new primary and new working secondaries

2552
01:00:56,740 --> 01:00:56,750
new primary and new working secondaries
 

2553
01:00:56,750 --> 01:01:00,160
new primary and new working secondaries
with a new version and this not-so-great

2554
01:01:00,160 --> 01:01:00,170
with a new version and this not-so-great
 

2555
01:01:00,170 --> 01:01:02,710
with a new version and this not-so-great
secondary with an old version and a

2556
01:01:02,710 --> 01:01:02,720
secondary with an old version and a
 

2557
01:01:02,720 --> 01:01:04,150
secondary with an old version and a
stale copy of the data but because that

2558
01:01:04,150 --> 01:01:04,160
stale copy of the data but because that
 

2559
01:01:04,160 --> 01:01:06,990
stale copy of the data but because that
has an old version the master will never

2560
01:01:06,990 --> 01:01:07,000
has an old version the master will never
 

2561
01:01:07,000 --> 01:01:09,250
has an old version the master will never
never mistake it for being fresh but

2562
01:01:09,250 --> 01:01:09,260
never mistake it for being fresh but
 

2563
01:01:09,260 --> 01:01:10,630
never mistake it for being fresh but
there's no evidence in the paper that

2564
01:01:10,630 --> 01:01:10,640
there's no evidence in the paper that
 

2565
01:01:10,640 --> 01:01:12,460
there's no evidence in the paper that
that happens immediately as far as

2566
01:01:12,460 --> 01:01:12,470
that happens immediately as far as
 

2567
01:01:12,470 --> 01:01:15,100
that happens immediately as far as
what's said in the paper the client just

2568
01:01:15,100 --> 01:01:15,110
what's said in the paper the client just
 

2569
01:01:15,110 --> 01:01:17,170
what's said in the paper the client just
retries and hopes it works again later

2570
01:01:17,170 --> 01:01:17,180
retries and hopes it works again later
 

2571
01:01:17,180 --> 01:01:19,600
retries and hopes it works again later
eventually the master will if the

2572
01:01:19,600 --> 01:01:19,610
eventually the master will if the
 

2573
01:01:19,610 --> 01:01:21,220
eventually the master will if the
secondary is dead

2574
01:01:21,220 --> 01:01:21,230
secondary is dead
 

2575
01:01:21,230 --> 01:01:23,980
secondary is dead
eventually the master does ping all the

2576
01:01:23,980 --> 01:01:23,990
eventually the master does ping all the
 

2577
01:01:23,990 --> 01:01:25,840
eventually the master does ping all the
trunk servers will realize that and will

2578
01:01:25,840 --> 01:01:25,850
trunk servers will realize that and will
 

2579
01:01:25,850 --> 01:01:30,760
trunk servers will realize that and will
probably then change the set of

2580
01:01:30,760 --> 01:01:30,770
probably then change the set of
 

2581
01:01:30,770 --> 01:01:32,080
probably then change the set of
primaries and secondaries and increment

2582
01:01:32,080 --> 01:01:32,090
primaries and secondaries and increment
 

2583
01:01:32,090 --> 01:01:40,370
primaries and secondaries and increment
the version but only only later

2584
01:01:40,370 --> 01:01:40,380

 

2585
01:01:40,380 --> 01:01:45,650

the lease the leases that the answer to

2586
01:01:45,650 --> 01:01:45,660
the lease the leases that the answer to
 

2587
01:01:45,660 --> 01:01:49,880
the lease the leases that the answer to
the question what if the master thinks

2588
01:01:49,880 --> 01:01:49,890
the question what if the master thinks
 

2589
01:01:49,890 --> 01:01:52,490
the question what if the master thinks
the primary is dead because it can't

2590
01:01:52,490 --> 01:01:52,500
the primary is dead because it can't
 

2591
01:01:52,500 --> 01:01:53,780
the primary is dead because it can't
reach it right that's supposing we're in

2592
01:01:53,780 --> 01:01:53,790
reach it right that's supposing we're in
 

2593
01:01:53,790 --> 01:01:55,460
reach it right that's supposing we're in
a situation where at some point the

2594
01:01:55,460 --> 01:01:55,470
a situation where at some point the
 

2595
01:01:55,470 --> 01:01:58,100
a situation where at some point the
master said you're the primary and the

2596
01:01:58,100 --> 01:01:58,110
master said you're the primary and the
 

2597
01:01:58,110 --> 01:01:59,930
master said you're the primary and the
master was like painting them all the

2598
01:01:59,930 --> 01:01:59,940
master was like painting them all the
 

2599
01:01:59,940 --> 01:02:01,250
master was like painting them all the
service periodically to see if they're

2600
01:02:01,250 --> 01:02:01,260
service periodically to see if they're
 

2601
01:02:01,260 --> 01:02:02,600
service periodically to see if they're
alive because if they're dead and wants

2602
01:02:02,600 --> 01:02:02,610
alive because if they're dead and wants
 

2603
01:02:02,610 --> 01:02:05,150
alive because if they're dead and wants
to pick a new primary the master sends

2604
01:02:05,150 --> 01:02:05,160
to pick a new primary the master sends
 

2605
01:02:05,160 --> 01:02:07,070
to pick a new primary the master sends
some pings to you you're the primary and

2606
01:02:07,070 --> 01:02:07,080
some pings to you you're the primary and
 

2607
01:02:07,080 --> 01:02:09,680
some pings to you you're the primary and
you don't respond right so you would

2608
01:02:09,680 --> 01:02:09,690
you don't respond right so you would
 

2609
01:02:09,690 --> 01:02:11,840
you don't respond right so you would
think that at that point where gosh

2610
01:02:11,840 --> 01:02:11,850
think that at that point where gosh
 

2611
01:02:11,850 --> 01:02:14,050
think that at that point where gosh
you're not responding to my pings then

2612
01:02:14,050 --> 01:02:14,060
you're not responding to my pings then
 

2613
01:02:14,060 --> 01:02:16,550
you're not responding to my pings then
you might think the master at that point

2614
01:02:16,550 --> 01:02:16,560
you might think the master at that point
 

2615
01:02:16,560 --> 01:02:20,780
you might think the master at that point
would designate a new primary it turns

2616
01:02:20,780 --> 01:02:20,790
would designate a new primary it turns
 

2617
01:02:20,790 --> 01:02:23,810
would designate a new primary it turns
out that by itself is a mistake and the

2618
01:02:23,810 --> 01:02:23,820
out that by itself is a mistake and the
 

2619
01:02:23,820 --> 01:02:26,120
out that by itself is a mistake and the
reason for that the reason why it's a

2620
01:02:26,120 --> 01:02:26,130
reason for that the reason why it's a
 

2621
01:02:26,130 --> 01:02:30,080
reason for that the reason why it's a
mistake to do that simple did you know

2622
01:02:30,080 --> 01:02:30,090
mistake to do that simple did you know
 

2623
01:02:30,090 --> 01:02:32,390
mistake to do that simple did you know
use that simple design is that I may be

2624
01:02:32,390 --> 01:02:32,400
use that simple design is that I may be
 

2625
01:02:32,400 --> 01:02:33,860
use that simple design is that I may be
pinging you and the reason why I'm not

2626
01:02:33,860 --> 01:02:33,870
pinging you and the reason why I'm not
 

2627
01:02:33,870 --> 01:02:35,390
pinging you and the reason why I'm not
getting responses is because then

2628
01:02:35,390 --> 01:02:35,400
getting responses is because then
 

2629
01:02:35,400 --> 01:02:36,560
getting responses is because then
there's something wrong with a network

2630
01:02:36,560 --> 01:02:36,570
there's something wrong with a network
 

2631
01:02:36,570 --> 01:02:38,180
there's something wrong with a network
between me and you so there's a

2632
01:02:38,180 --> 01:02:38,190
between me and you so there's a
 

2633
01:02:38,190 --> 01:02:39,860
between me and you so there's a
possibility that you're alive you're the

2634
01:02:39,860 --> 01:02:39,870
possibility that you're alive you're the
 

2635
01:02:39,870 --> 01:02:41,210
possibility that you're alive you're the
primary you're alive I'm peeing you the

2636
01:02:41,210 --> 01:02:41,220
primary you're alive I'm peeing you the
 

2637
01:02:41,220 --> 01:02:42,740
primary you're alive I'm peeing you the
network is dropping that packets but you

2638
01:02:42,740 --> 01:02:42,750
network is dropping that packets but you
 

2639
01:02:42,750 --> 01:02:44,270
network is dropping that packets but you
can talk to other clients and you're

2640
01:02:44,270 --> 01:02:44,280
can talk to other clients and you're
 

2641
01:02:44,280 --> 01:02:46,310
can talk to other clients and you're
serving requests from other clients you

2642
01:02:46,310 --> 01:02:46,320
serving requests from other clients you
 

2643
01:02:46,320 --> 01:02:49,130
serving requests from other clients you
know and if I if I the master sort of

2644
01:02:49,130 --> 01:02:49,140
know and if I if I the master sort of
 

2645
01:02:49,140 --> 01:02:51,830
know and if I if I the master sort of
designated a new primary for that chunk

2646
01:02:51,830 --> 01:02:51,840
designated a new primary for that chunk
 

2647
01:02:51,840 --> 01:02:54,590
designated a new primary for that chunk
now we'd have two primaries processing

2648
01:02:54,590 --> 01:02:54,600
now we'd have two primaries processing
 

2649
01:02:54,600 --> 01:02:56,330
now we'd have two primaries processing
rights but two different copies of the

2650
01:02:56,330 --> 01:02:56,340
rights but two different copies of the
 

2651
01:02:56,340 --> 01:02:58,820
rights but two different copies of the
data and so now we have totally

2652
01:02:58,820 --> 01:02:58,830
data and so now we have totally
 

2653
01:02:58,830 --> 01:03:02,360
data and so now we have totally
diverging copies the data and that's

2654
01:03:02,360 --> 01:03:02,370
diverging copies the data and that's
 

2655
01:03:02,370 --> 01:03:07,550
diverging copies the data and that's
called that error having two primaries

2656
01:03:07,550 --> 01:03:07,560
called that error having two primaries
 

2657
01:03:07,560 --> 01:03:10,760
called that error having two primaries
or whatever processing requests without

2658
01:03:10,760 --> 01:03:10,770
or whatever processing requests without
 

2659
01:03:10,770 --> 01:03:12,560
or whatever processing requests without
knowing each other it's called squid

2660
01:03:12,560 --> 01:03:12,570
knowing each other it's called squid
 

2661
01:03:12,570 --> 01:03:16,700
knowing each other it's called squid
brain and I'm writing this on board

2662
01:03:16,700 --> 01:03:16,710
brain and I'm writing this on board
 

2663
01:03:16,710 --> 01:03:19,430
brain and I'm writing this on board
because it's an important idea and it'll

2664
01:03:19,430 --> 01:03:19,440
because it's an important idea and it'll
 

2665
01:03:19,440 --> 01:03:23,150
because it's an important idea and it'll
come up again and it's caused or it's

2666
01:03:23,150 --> 01:03:23,160
come up again and it's caused or it's
 

2667
01:03:23,160 --> 01:03:24,530
come up again and it's caused or it's
usually said to be caused by network

2668
01:03:24,530 --> 01:03:24,540
usually said to be caused by network
 

2669
01:03:24,540 --> 01:03:33,110
usually said to be caused by network
partition that is some network error in

2670
01:03:33,110 --> 01:03:33,120
partition that is some network error in
 

2671
01:03:33,120 --> 01:03:34,250
partition that is some network error in
which the master can't talk to the

2672
01:03:34,250 --> 01:03:34,260
which the master can't talk to the
 

2673
01:03:34,260 --> 01:03:35,630
which the master can't talk to the
primary but the primary can talk to

2674
01:03:35,630 --> 01:03:35,640
primary but the primary can talk to
 

2675
01:03:35,640 --> 01:03:38,320
primary but the primary can talk to
clients sort of partial network failure

2676
01:03:38,320 --> 01:03:38,330
clients sort of partial network failure
 

2677
01:03:38,330 --> 01:03:41,150
clients sort of partial network failure
and you know these are some of the these

2678
01:03:41,150 --> 01:03:41,160
and you know these are some of the these
 

2679
01:03:41,160 --> 01:03:44,750
and you know these are some of the these
are the hardest problems to deal with

2680
01:03:44,750 --> 01:03:44,760
are the hardest problems to deal with
 

2681
01:03:44,760 --> 01:03:46,460
are the hardest problems to deal with
and building these kind of storage

2682
01:03:46,460 --> 01:03:46,470
and building these kind of storage
 

2683
01:03:46,470 --> 01:03:49,160
and building these kind of storage
systems okay so that's the problem is we

2684
01:03:49,160 --> 01:03:49,170
systems okay so that's the problem is we
 

2685
01:03:49,170 --> 01:03:51,680
systems okay so that's the problem is we
want to rule out the possibility of

2686
01:03:51,680 --> 01:03:51,690
want to rule out the possibility of
 

2687
01:03:51,690 --> 01:03:54,070
want to rule out the possibility of
mistakingly designating too

2688
01:03:54,070 --> 01:03:54,080
mistakingly designating too
 

2689
01:03:54,080 --> 01:03:56,200
mistakingly designating too
I'm Aries for the same chunk the way the

2690
01:03:56,200 --> 01:03:56,210
I'm Aries for the same chunk the way the
 

2691
01:03:56,210 --> 01:03:58,600
I'm Aries for the same chunk the way the
master achieves that is that when it

2692
01:03:58,600 --> 01:03:58,610
master achieves that is that when it
 

2693
01:03:58,610 --> 01:04:00,910
master achieves that is that when it
designates a primary it says it gives a

2694
01:04:00,910 --> 01:04:00,920
designates a primary it says it gives a
 

2695
01:04:00,920 --> 01:04:03,310
designates a primary it says it gives a
primary Elyse which is basically the

2696
01:04:03,310 --> 01:04:03,320
primary Elyse which is basically the
 

2697
01:04:03,320 --> 01:04:05,580
primary Elyse which is basically the
right to be primary until a certain time

2698
01:04:05,580 --> 01:04:05,590
right to be primary until a certain time
 

2699
01:04:05,590 --> 01:04:08,980
right to be primary until a certain time
the master knows it remembers and knows

2700
01:04:08,980 --> 01:04:08,990
the master knows it remembers and knows
 

2701
01:04:08,990 --> 01:04:12,490
the master knows it remembers and knows
how long the least lasts and the primary

2702
01:04:12,490 --> 01:04:12,500
how long the least lasts and the primary
 

2703
01:04:12,500 --> 01:04:14,950
how long the least lasts and the primary
knows how long is least lasts if the

2704
01:04:14,950 --> 01:04:14,960
knows how long is least lasts if the
 

2705
01:04:14,960 --> 01:04:18,790
knows how long is least lasts if the
lease expires the primary knows that it

2706
01:04:18,790 --> 01:04:18,800
lease expires the primary knows that it
 

2707
01:04:18,800 --> 01:04:20,560
lease expires the primary knows that it
expires and will simply stop executing

2708
01:04:20,560 --> 01:04:20,570
expires and will simply stop executing
 

2709
01:04:20,570 --> 01:04:23,140
expires and will simply stop executing
client requests it'll ignore or reject

2710
01:04:23,140 --> 01:04:23,150
client requests it'll ignore or reject
 

2711
01:04:23,150 --> 01:04:24,820
client requests it'll ignore or reject
client requests after the lease expired

2712
01:04:24,820 --> 01:04:24,830
client requests after the lease expired
 

2713
01:04:24,830 --> 01:04:27,790
client requests after the lease expired
and therefore if the master can't talk

2714
01:04:27,790 --> 01:04:27,800
and therefore if the master can't talk
 

2715
01:04:27,800 --> 01:04:29,560
and therefore if the master can't talk
to the primary and the master would like

2716
01:04:29,560 --> 01:04:29,570
to the primary and the master would like
 

2717
01:04:29,570 --> 01:04:31,210
to the primary and the master would like
to designate a new primary the master

2718
01:04:31,210 --> 01:04:31,220
to designate a new primary the master
 

2719
01:04:31,220 --> 01:04:33,820
to designate a new primary the master
must wait for the lease to expire for

2720
01:04:33,820 --> 01:04:33,830
must wait for the lease to expire for
 

2721
01:04:33,830 --> 01:04:35,260
must wait for the lease to expire for
the previous primary so that means

2722
01:04:35,260 --> 01:04:35,270
the previous primary so that means
 

2723
01:04:35,270 --> 01:04:37,660
the previous primary so that means
master is going to sit on its hands for

2724
01:04:37,660 --> 01:04:37,670
master is going to sit on its hands for
 

2725
01:04:37,670 --> 01:04:40,000
master is going to sit on its hands for
one lease period 60 seconds after that

2726
01:04:40,000 --> 01:04:40,010
one lease period 60 seconds after that
 

2727
01:04:40,010 --> 01:04:41,650
one lease period 60 seconds after that
it's guaranteed the old primary will

2728
01:04:41,650 --> 01:04:41,660
it's guaranteed the old primary will
 

2729
01:04:41,660 --> 01:04:44,500
it's guaranteed the old primary will
stop operating its primary and now the

2730
01:04:44,500 --> 01:04:44,510
stop operating its primary and now the
 

2731
01:04:44,510 --> 01:04:46,150
stop operating its primary and now the
master can see if he doesn't need a new

2732
01:04:46,150 --> 01:04:46,160
master can see if he doesn't need a new
 

2733
01:04:46,160 --> 01:04:50,800
master can see if he doesn't need a new
primary without producing this terrible

2734
01:04:50,800 --> 01:04:50,810
primary without producing this terrible
 

2735
01:04:50,810 --> 01:05:02,289
primary without producing this terrible
split brain situation

2736
01:05:02,289 --> 01:05:02,299

 

2737
01:05:02,299 --> 01:05:14,109

oh so the question is why is designated

2738
01:05:14,109 --> 01:05:14,119
oh so the question is why is designated
 

2739
01:05:14,119 --> 01:05:15,910
oh so the question is why is designated
a new primary bad since the clients

2740
01:05:15,910 --> 01:05:15,920
a new primary bad since the clients
 

2741
01:05:15,920 --> 01:05:18,069
a new primary bad since the clients
always ask the master first and so the

2742
01:05:18,069 --> 01:05:18,079
always ask the master first and so the
 

2743
01:05:18,079 --> 01:05:20,049
always ask the master first and so the
master changes its mind then subsequent

2744
01:05:20,049 --> 01:05:20,059
master changes its mind then subsequent
 

2745
01:05:20,059 --> 01:05:22,809
master changes its mind then subsequent
clients will direct the clients to the

2746
01:05:22,809 --> 01:05:22,819
clients will direct the clients to the
 

2747
01:05:22,819 --> 01:05:26,380
clients will direct the clients to the
new primary well one reason is that the

2748
01:05:26,380 --> 01:05:26,390
new primary well one reason is that the
 

2749
01:05:26,390 --> 01:05:28,419
new primary well one reason is that the
clients cash for efficiency the clients

2750
01:05:28,419 --> 01:05:28,429
clients cash for efficiency the clients
 

2751
01:05:28,429 --> 01:05:31,269
clients cash for efficiency the clients
cash the identity of the primary for at

2752
01:05:31,269 --> 01:05:31,279
cash the identity of the primary for at
 

2753
01:05:31,279 --> 01:05:33,999
cash the identity of the primary for at
least for short periods of time even if

2754
01:05:33,999 --> 01:05:34,009
least for short periods of time even if
 

2755
01:05:34,009 --> 01:05:37,479
least for short periods of time even if
they didn't though the bad sequence is

2756
01:05:37,479 --> 01:05:37,489
they didn't though the bad sequence is
 

2757
01:05:37,489 --> 01:05:40,630
they didn't though the bad sequence is
that I'm the prime the master you ask me

2758
01:05:40,630 --> 01:05:40,640
that I'm the prime the master you ask me
 

2759
01:05:40,640 --> 01:05:43,439
that I'm the prime the master you ask me
who the primary is I send you a message

2760
01:05:43,439 --> 01:05:43,449
who the primary is I send you a message
 

2761
01:05:43,449 --> 01:05:46,359
who the primary is I send you a message
saying the primary is server one right

2762
01:05:46,359 --> 01:05:46,369
saying the primary is server one right
 

2763
01:05:46,369 --> 01:05:47,799
saying the primary is server one right
and that message is inflate in the

2764
01:05:47,799 --> 01:05:47,809
and that message is inflate in the
 

2765
01:05:47,809 --> 01:05:50,620
and that message is inflate in the
network and then I'm the master I you

2766
01:05:50,620 --> 01:05:50,630
network and then I'm the master I you
 

2767
01:05:50,630 --> 01:05:52,150
network and then I'm the master I you
know I think somebody's failed whatever

2768
01:05:52,150 --> 01:05:52,160
know I think somebody's failed whatever
 

2769
01:05:52,160 --> 01:05:53,259
know I think somebody's failed whatever
I think that primary is filled I

2770
01:05:53,259 --> 01:05:53,269
I think that primary is filled I
 

2771
01:05:53,269 --> 01:05:55,209
I think that primary is filled I
designated a new primary and I send the

2772
01:05:55,209 --> 01:05:55,219
designated a new primary and I send the
 

2773
01:05:55,219 --> 01:05:56,199
designated a new primary and I send the
primary message saying you're the

2774
01:05:56,199 --> 01:05:56,209
primary message saying you're the
 

2775
01:05:56,209 --> 01:05:57,609
primary message saying you're the
primary and I start answering other

2776
01:05:57,609 --> 01:05:57,619
primary and I start answering other
 

2777
01:05:57,619 --> 01:06:00,339
primary and I start answering other
clients who ask the primary is saying

2778
01:06:00,339 --> 01:06:00,349
clients who ask the primary is saying
 

2779
01:06:00,349 --> 01:06:01,390
clients who ask the primary is saying
that that over there is the primary

2780
01:06:01,390 --> 01:06:01,400
that that over there is the primary
 

2781
01:06:01,400 --> 01:06:03,009
that that over there is the primary
while the message to you is still in

2782
01:06:03,009 --> 01:06:03,019
while the message to you is still in
 

2783
01:06:03,019 --> 01:06:04,870
while the message to you is still in
flight you receive the message saying

2784
01:06:04,870 --> 01:06:04,880
flight you receive the message saying
 

2785
01:06:04,880 --> 01:06:07,120
flight you receive the message saying
the old primaries the primary you think

2786
01:06:07,120 --> 01:06:07,130
the old primaries the primary you think
 

2787
01:06:07,130 --> 01:06:10,209
the old primaries the primary you think
gosh I just got this from the master I'm

2788
01:06:10,209 --> 01:06:10,219
gosh I just got this from the master I'm
 

2789
01:06:10,219 --> 01:06:11,620
gosh I just got this from the master I'm
gonna go talk to that primary and

2790
01:06:11,620 --> 01:06:11,630
gonna go talk to that primary and
 

2791
01:06:11,630 --> 01:06:13,449
gonna go talk to that primary and
without some much more clever scheme

2792
01:06:13,449 --> 01:06:13,459
without some much more clever scheme
 

2793
01:06:13,459 --> 01:06:14,849
without some much more clever scheme
there's no way you could realize that

2794
01:06:14,849 --> 01:06:14,859
there's no way you could realize that
 

2795
01:06:14,859 --> 01:06:16,839
there's no way you could realize that
even though you just got this

2796
01:06:16,839 --> 01:06:16,849
even though you just got this
 

2797
01:06:16,849 --> 01:06:19,299
even though you just got this
information from the master it's already

2798
01:06:19,299 --> 01:06:19,309
information from the master it's already
 

2799
01:06:19,309 --> 01:06:21,669
information from the master it's already
out of date and if that primary serves

2800
01:06:21,669 --> 01:06:21,679
out of date and if that primary serves
 

2801
01:06:21,679 --> 01:06:24,400
out of date and if that primary serves
your modification requests now we have

2802
01:06:24,400 --> 01:06:24,410
your modification requests now we have
 

2803
01:06:24,410 --> 01:06:27,910
your modification requests now we have
to and and respond success to you right

2804
01:06:27,910 --> 01:06:27,920
to and and respond success to you right
 

2805
01:06:27,920 --> 01:06:35,880
to and and respond success to you right
then we have two conflicting replicas

2806
01:06:35,880 --> 01:06:35,890

 

2807
01:06:35,890 --> 01:06:41,900

yes

2808
01:06:41,900 --> 01:06:41,910

 

2809
01:06:41,910 --> 01:06:50,700

again you've a new file and no replicas

2810
01:06:50,700 --> 01:06:50,710
again you've a new file and no replicas
 

2811
01:06:50,710 --> 01:06:53,400
again you've a new file and no replicas
okay so if you have a new file no

2812
01:06:53,400 --> 01:06:53,410
okay so if you have a new file no
 

2813
01:06:53,410 --> 01:06:55,170
okay so if you have a new file no
replicas or even an existing file and no

2814
01:06:55,170 --> 01:06:55,180
replicas or even an existing file and no
 

2815
01:06:55,180 --> 01:06:58,080
replicas or even an existing file and no
replicas the you'll take the path I drew

2816
01:06:58,080 --> 01:06:58,090
replicas the you'll take the path I drew
 

2817
01:06:58,090 --> 01:07:00,120
replicas the you'll take the path I drew
on the blackboard the master will

2818
01:07:00,120 --> 01:07:00,130
on the blackboard the master will
 

2819
01:07:00,130 --> 01:07:02,130
on the blackboard the master will
receive a request from a client saying

2820
01:07:02,130 --> 01:07:02,140
receive a request from a client saying
 

2821
01:07:02,140 --> 01:07:04,260
receive a request from a client saying
oh I'd like to append to this file and

2822
01:07:04,260 --> 01:07:04,270
oh I'd like to append to this file and
 

2823
01:07:04,270 --> 01:07:06,420
oh I'd like to append to this file and
then well I guess the master will first

2824
01:07:06,420 --> 01:07:06,430
then well I guess the master will first
 

2825
01:07:06,430 --> 01:07:08,190
then well I guess the master will first
see there's no chunks associated with

2826
01:07:08,190 --> 01:07:08,200
see there's no chunks associated with
 

2827
01:07:08,200 --> 01:07:11,700
see there's no chunks associated with
that file and it will just make up a new

2828
01:07:11,700 --> 01:07:11,710
that file and it will just make up a new
 

2829
01:07:11,710 --> 01:07:13,560
that file and it will just make up a new
chunk identifier or perhaps by calling

2830
01:07:13,560 --> 01:07:13,570
chunk identifier or perhaps by calling
 

2831
01:07:13,570 --> 01:07:15,720
chunk identifier or perhaps by calling
the random number generator and then

2832
01:07:15,720 --> 01:07:15,730
the random number generator and then
 

2833
01:07:15,730 --> 01:07:17,910
the random number generator and then
it'll look in its chunk information

2834
01:07:17,910 --> 01:07:17,920
it'll look in its chunk information
 

2835
01:07:17,920 --> 01:07:20,070
it'll look in its chunk information
table and see gosh I don't have any

2836
01:07:20,070 --> 01:07:20,080
table and see gosh I don't have any
 

2837
01:07:20,080 --> 01:07:22,020
table and see gosh I don't have any
information about that chunk and it'll

2838
01:07:22,020 --> 01:07:22,030
information about that chunk and it'll
 

2839
01:07:22,030 --> 01:07:24,720
information about that chunk and it'll
make up a new record saying but it must

2840
01:07:24,720 --> 01:07:24,730
make up a new record saying but it must
 

2841
01:07:24,730 --> 01:07:26,400
make up a new record saying but it must
be special case code where it says well

2842
01:07:26,400 --> 01:07:26,410
be special case code where it says well
 

2843
01:07:26,410 --> 01:07:28,710
be special case code where it says well
I don't know any version number this

2844
01:07:28,710 --> 01:07:28,720
I don't know any version number this
 

2845
01:07:28,720 --> 01:07:30,840
I don't know any version number this
chunk doesn't exist I'm just gonna make

2846
01:07:30,840 --> 01:07:30,850
chunk doesn't exist I'm just gonna make
 

2847
01:07:30,850 --> 01:07:32,730
chunk doesn't exist I'm just gonna make
up a new version number one pick a

2848
01:07:32,730 --> 01:07:32,740
up a new version number one pick a
 

2849
01:07:32,740 --> 01:07:35,370
up a new version number one pick a
random primary and set of secondaries

2850
01:07:35,370 --> 01:07:35,380
random primary and set of secondaries
 

2851
01:07:35,380 --> 01:07:37,890
random primary and set of secondaries
and tell them look you are responsible

2852
01:07:37,890 --> 01:07:37,900
and tell them look you are responsible
 

2853
01:07:37,900 --> 01:07:40,650
and tell them look you are responsible
for this new empty chunk please get to

2854
01:07:40,650 --> 01:07:40,660
for this new empty chunk please get to
 

2855
01:07:40,660 --> 01:07:47,010
for this new empty chunk please get to
work the paper says three replicas per

2856
01:07:47,010 --> 01:07:47,020
work the paper says three replicas per
 

2857
01:07:47,020 --> 01:07:50,100
work the paper says three replicas per
chunk by default so typically a primary

2858
01:07:50,100 --> 01:07:50,110
chunk by default so typically a primary
 

2859
01:07:50,110 --> 01:08:03,920
chunk by default so typically a primary
and two backups

2860
01:08:03,920 --> 01:08:03,930

 

2861
01:08:03,930 --> 01:08:13,260

okay okay so the maybe the most

2862
01:08:13,260 --> 01:08:13,270
okay okay so the maybe the most
 

2863
01:08:13,270 --> 01:08:16,289
okay okay so the maybe the most
important thing here is just to repeat

2864
01:08:16,289 --> 01:08:16,299
important thing here is just to repeat
 

2865
01:08:16,299 --> 01:08:21,530
important thing here is just to repeat
the discussion we had a few minutes ago

2866
01:08:21,530 --> 01:08:21,540

 

2867
01:08:21,540 --> 01:08:32,130

the intentional construction of GFS we

2868
01:08:32,130 --> 01:08:32,140
the intentional construction of GFS we
 

2869
01:08:32,140 --> 01:08:33,780
the intentional construction of GFS we
had these record a pens is that if we

2870
01:08:33,780 --> 01:08:33,790
had these record a pens is that if we
 

2871
01:08:33,790 --> 01:08:40,999
had these record a pens is that if we
have three we have three replicas you

2872
01:08:40,999 --> 01:08:41,009
have three we have three replicas you
 

2873
01:08:41,009 --> 01:08:43,769
have three we have three replicas you
know maybe a client sends in and a

2874
01:08:43,769 --> 01:08:43,779
know maybe a client sends in and a
 

2875
01:08:43,779 --> 01:08:46,709
know maybe a client sends in and a
record a pen for record a and all three

2876
01:08:46,709 --> 01:08:46,719
record a pen for record a and all three
 

2877
01:08:46,719 --> 01:08:49,559
record a pen for record a and all three
replicas or the primary and both of the

2878
01:08:49,559 --> 01:08:49,569
replicas or the primary and both of the
 

2879
01:08:49,569 --> 01:08:52,110
replicas or the primary and both of the
secondaries successfully append the data

2880
01:08:52,110 --> 01:08:52,120
secondaries successfully append the data
 

2881
01:08:52,120 --> 01:08:54,059
secondaries successfully append the data
the chunks and maybe the first record in

2882
01:08:54,059 --> 01:08:54,069
the chunks and maybe the first record in
 

2883
01:08:54,069 --> 01:08:55,680
the chunks and maybe the first record in
the trunk might be a in that case and

2884
01:08:55,680 --> 01:08:55,690
the trunk might be a in that case and
 

2885
01:08:55,690 --> 01:08:57,920
the trunk might be a in that case and
they all agree because they all did it

2886
01:08:57,920 --> 01:08:57,930
they all agree because they all did it
 

2887
01:08:57,930 --> 01:09:00,030
they all agree because they all did it
supposing another client comes in says

2888
01:09:00,030 --> 01:09:00,040
supposing another client comes in says
 

2889
01:09:00,040 --> 01:09:03,329
supposing another client comes in says
look I want a pen record B but the

2890
01:09:03,329 --> 01:09:03,339
look I want a pen record B but the
 

2891
01:09:03,339 --> 01:09:06,240
look I want a pen record B but the
message is lost to one of the replicas

2892
01:09:06,240 --> 01:09:06,250
message is lost to one of the replicas
 

2893
01:09:06,250 --> 01:09:08,400
message is lost to one of the replicas
the network whatever supposably the

2894
01:09:08,400 --> 01:09:08,410
the network whatever supposably the
 

2895
01:09:08,410 --> 01:09:11,579
the network whatever supposably the
message by mistake but the other two

2896
01:09:11,579 --> 01:09:11,589
message by mistake but the other two
 

2897
01:09:11,589 --> 01:09:13,380
message by mistake but the other two
replicas get the message and one of

2898
01:09:13,380 --> 01:09:13,390
replicas get the message and one of
 

2899
01:09:13,390 --> 01:09:14,370
replicas get the message and one of
them's a primary and my other

2900
01:09:14,370 --> 01:09:14,380
them's a primary and my other
 

2901
01:09:14,380 --> 01:09:15,990
them's a primary and my other
secondaries they both depend of the file

2902
01:09:15,990 --> 01:09:16,000
secondaries they both depend of the file
 

2903
01:09:16,000 --> 01:09:19,380
secondaries they both depend of the file
so now what we have is two the replicas

2904
01:09:19,380 --> 01:09:19,390
so now what we have is two the replicas
 

2905
01:09:19,390 --> 01:09:21,749
so now what we have is two the replicas
that B and the other one doesn't have

2906
01:09:21,749 --> 01:09:21,759
that B and the other one doesn't have
 

2907
01:09:21,759 --> 01:09:26,400
that B and the other one doesn't have
anything and then may be a third client

2908
01:09:26,400 --> 01:09:26,410
anything and then may be a third client
 

2909
01:09:26,410 --> 01:09:29,099
anything and then may be a third client
wants to append C and maybe the remember

2910
01:09:29,099 --> 01:09:29,109
wants to append C and maybe the remember
 

2911
01:09:29,109 --> 01:09:30,450
wants to append C and maybe the remember
that this is the primary the primary

2912
01:09:30,450 --> 01:09:30,460
that this is the primary the primary
 

2913
01:09:30,460 --> 01:09:32,729
that this is the primary the primary
picks the offset since the primary just

2914
01:09:32,729 --> 01:09:32,739
picks the offset since the primary just
 

2915
01:09:32,739 --> 01:09:35,099
picks the offset since the primary just
gonna tell the secondaries look in a

2916
01:09:35,099 --> 01:09:35,109
gonna tell the secondaries look in a
 

2917
01:09:35,109 --> 01:09:38,610
gonna tell the secondaries look in a
right record C at this point in the

2918
01:09:38,610 --> 01:09:38,620
right record C at this point in the
 

2919
01:09:38,620 --> 01:09:43,440
right record C at this point in the
chunk they all right C here now the

2920
01:09:43,440 --> 01:09:43,450
chunk they all right C here now the
 

2921
01:09:43,450 --> 01:09:45,030
chunk they all right C here now the
client for be the rule for a client for

2922
01:09:45,030 --> 01:09:45,040
client for be the rule for a client for
 

2923
01:09:45,040 --> 01:09:47,820
client for be the rule for a client for
B that for the client that gets us error

2924
01:09:47,820 --> 01:09:47,830
B that for the client that gets us error
 

2925
01:09:47,830 --> 01:09:50,430
B that for the client that gets us error
back from its request is that it will

2926
01:09:50,430 --> 01:09:50,440
back from its request is that it will
 

2927
01:09:50,440 --> 01:09:53,760
back from its request is that it will
resend the request so now the client

2928
01:09:53,760 --> 01:09:53,770
resend the request so now the client
 

2929
01:09:53,770 --> 01:09:56,010
resend the request so now the client
that asked to append record B will ask

2930
01:09:56,010 --> 01:09:56,020
that asked to append record B will ask
 

2931
01:09:56,020 --> 01:09:57,630
that asked to append record B will ask
again to a pen record B and this time

2932
01:09:57,630 --> 01:09:57,640
again to a pen record B and this time
 

2933
01:09:57,640 --> 01:10:00,330
again to a pen record B and this time
maybe there's no network losses and all

2934
01:10:00,330 --> 01:10:00,340
maybe there's no network losses and all
 

2935
01:10:00,340 --> 01:10:05,030
maybe there's no network losses and all
three replicas as a panel record be

2936
01:10:05,030 --> 01:10:05,040
three replicas as a panel record be
 

2937
01:10:05,040 --> 01:10:07,229
three replicas as a panel record be
right and they're all lives there I'll

2938
01:10:07,229 --> 01:10:07,239
right and they're all lives there I'll
 

2939
01:10:07,239 --> 01:10:09,860
right and they're all lives there I'll
have the most fresh version number and

2940
01:10:09,860 --> 01:10:09,870
have the most fresh version number and
 

2941
01:10:09,870 --> 01:10:13,140
have the most fresh version number and
now if a client reads

2942
01:10:13,140 --> 01:10:13,150
now if a client reads
 

2943
01:10:13,150 --> 01:10:17,810
now if a client reads
what they see depends on the track which

2944
01:10:17,810 --> 01:10:17,820

 

2945
01:10:17,820 --> 01:10:20,010

replicas they look at it's gonna see in

2946
01:10:20,010 --> 01:10:20,020
replicas they look at it's gonna see in
 

2947
01:10:20,020 --> 01:10:22,919
replicas they look at it's gonna see in
total all three of the records but it'll

2948
01:10:22,919 --> 01:10:22,929
total all three of the records but it'll
 

2949
01:10:22,929 --> 01:10:25,020
total all three of the records but it'll
see in different orders depending on

2950
01:10:25,020 --> 01:10:25,030
see in different orders depending on
 

2951
01:10:25,030 --> 01:10:28,740
see in different orders depending on
which replica reads it'll mean I'll see

2952
01:10:28,740 --> 01:10:28,750
which replica reads it'll mean I'll see
 

2953
01:10:28,750 --> 01:10:31,860
which replica reads it'll mean I'll see
a B C and then a repeat of B so if it

2954
01:10:31,860 --> 01:10:31,870
a B C and then a repeat of B so if it
 

2955
01:10:31,870 --> 01:10:33,720
a B C and then a repeat of B so if it
reads this replica it'll see B and then

2956
01:10:33,720 --> 01:10:33,730
reads this replica it'll see B and then
 

2957
01:10:33,730 --> 01:10:36,959
reads this replica it'll see B and then
C if it reads this replica it'll see a

2958
01:10:36,959 --> 01:10:36,969
C if it reads this replica it'll see a
 

2959
01:10:36,969 --> 01:10:39,330
C if it reads this replica it'll see a
and then a blank space in the file

2960
01:10:39,330 --> 01:10:39,340
and then a blank space in the file
 

2961
01:10:39,340 --> 01:10:41,910
and then a blank space in the file
padding and then C and then B so if you

2962
01:10:41,910 --> 01:10:41,920
padding and then C and then B so if you
 

2963
01:10:41,920 --> 01:10:44,189
padding and then C and then B so if you
read here you see C then B if you read

2964
01:10:44,189 --> 01:10:44,199
read here you see C then B if you read
 

2965
01:10:44,199 --> 01:10:47,310
read here you see C then B if you read
here you see B and then C so different

2966
01:10:47,310 --> 01:10:47,320
here you see B and then C so different
 

2967
01:10:47,320 --> 01:10:49,340
here you see B and then C so different
readers will see different results and

2968
01:10:49,340 --> 01:10:49,350
readers will see different results and
 

2969
01:10:49,350 --> 01:10:52,320
readers will see different results and
maybe the worst situation is it some

2970
01:10:52,320 --> 01:10:52,330
maybe the worst situation is it some
 

2971
01:10:52,330 --> 01:10:54,479
maybe the worst situation is it some
client gets an error back from the

2972
01:10:54,479 --> 01:10:54,489
client gets an error back from the
 

2973
01:10:54,489 --> 01:10:58,350
client gets an error back from the
primary because one of the secondaries

2974
01:10:58,350 --> 01:10:58,360
primary because one of the secondaries
 

2975
01:10:58,360 --> 01:11:00,149
primary because one of the secondaries
failed to do the append and then the

2976
01:11:00,149 --> 01:11:00,159
failed to do the append and then the
 

2977
01:11:00,159 --> 01:11:02,250
failed to do the append and then the
client dies before we sending the

2978
01:11:02,250 --> 01:11:02,260
client dies before we sending the
 

2979
01:11:02,260 --> 01:11:04,020
client dies before we sending the
request so then you might get a

2980
01:11:04,020 --> 01:11:04,030
request so then you might get a
 

2981
01:11:04,030 --> 01:11:07,020
request so then you might get a
situation where you have record D

2982
01:11:07,020 --> 01:11:07,030
situation where you have record D
 

2983
01:11:07,030 --> 01:11:11,880
situation where you have record D
showing up in some of the replicas and

2984
01:11:11,880 --> 01:11:11,890
showing up in some of the replicas and
 

2985
01:11:11,890 --> 01:11:13,740
showing up in some of the replicas and
completely not showing up anywhere in

2986
01:11:13,740 --> 01:11:13,750
completely not showing up anywhere in
 

2987
01:11:13,750 --> 01:11:16,410
completely not showing up anywhere in
the other replicas so you know under

2988
01:11:16,410 --> 01:11:16,420
the other replicas so you know under
 

2989
01:11:16,420 --> 01:11:19,649
the other replicas so you know under
this scheme we have good properties for

2990
01:11:19,649 --> 01:11:19,659
this scheme we have good properties for
 

2991
01:11:19,659 --> 01:11:23,610
this scheme we have good properties for
for appends that the primary sent back a

2992
01:11:23,610 --> 01:11:23,620
for appends that the primary sent back a
 

2993
01:11:23,620 --> 01:11:26,790
for appends that the primary sent back a
successful answer for and sort of not so

2994
01:11:26,790 --> 01:11:26,800
successful answer for and sort of not so
 

2995
01:11:26,800 --> 01:11:29,459
successful answer for and sort of not so
great properties for appends where the

2996
01:11:29,459 --> 01:11:29,469
great properties for appends where the
 

2997
01:11:29,469 --> 01:11:32,939
great properties for appends where the
primary sent back of failure and the

2998
01:11:32,939 --> 01:11:32,949
primary sent back of failure and the
 

2999
01:11:32,949 --> 01:11:35,520
primary sent back of failure and the
records the replicas just absolutely be

3000
01:11:35,520 --> 01:11:35,530
records the replicas just absolutely be
 

3001
01:11:35,530 --> 01:11:37,530
records the replicas just absolutely be
different all different sets of replicas

3002
01:11:37,530 --> 01:11:37,540
different all different sets of replicas
 

3003
01:11:37,540 --> 01:11:44,390
different all different sets of replicas
yes

3004
01:11:44,390 --> 01:11:44,400

 

3005
01:11:44,400 --> 01:11:46,650

my reading in the paper is that the

3006
01:11:46,650 --> 01:11:46,660
my reading in the paper is that the
 

3007
01:11:46,660 --> 01:11:49,080
my reading in the paper is that the
client starts at the very beginning of

3008
01:11:49,080 --> 01:11:49,090
client starts at the very beginning of
 

3009
01:11:49,090 --> 01:11:51,300
client starts at the very beginning of
the process and asked the master again

3010
01:11:51,300 --> 01:11:51,310
the process and asked the master again
 

3011
01:11:51,310 --> 01:11:54,180
the process and asked the master again
what's the last chunk in this file you

3012
01:11:54,180 --> 01:11:54,190
what's the last chunk in this file you
 

3013
01:11:54,190 --> 01:11:55,230
what's the last chunk in this file you
know because it might be might have

3014
01:11:55,230 --> 01:11:55,240
know because it might be might have
 

3015
01:11:55,240 --> 01:11:56,700
know because it might be might have
changed if other people are pending in

3016
01:11:56,700 --> 01:11:56,710
changed if other people are pending in
 

3017
01:11:56,710 --> 01:12:17,750
changed if other people are pending in
the file yes

3018
01:12:17,750 --> 01:12:17,760

 

3019
01:12:17,760 --> 01:12:20,280

so I can't you know I can't read the

3020
01:12:20,280 --> 01:12:20,290
so I can't you know I can't read the
 

3021
01:12:20,290 --> 01:12:22,710
so I can't you know I can't read the
designers mind so the observation is the

3022
01:12:22,710 --> 01:12:22,720
designers mind so the observation is the
 

3023
01:12:22,720 --> 01:12:24,750
designers mind so the observation is the
system could have been designed to keep

3024
01:12:24,750 --> 01:12:24,760
system could have been designed to keep
 

3025
01:12:24,760 --> 01:12:27,630
system could have been designed to keep
the replicas in precise sync it's

3026
01:12:27,630 --> 01:12:27,640
the replicas in precise sync it's
 

3027
01:12:27,640 --> 01:12:30,810
the replicas in precise sync it's
absolutely true and you will do it in

3028
01:12:30,810 --> 01:12:30,820
absolutely true and you will do it in
 

3029
01:12:30,820 --> 01:12:33,090
absolutely true and you will do it in
labs 2 & 3 so you guys are going to

3030
01:12:33,090 --> 01:12:33,100
labs 2 & 3 so you guys are going to
 

3031
01:12:33,100 --> 01:12:34,920
labs 2 & 3 so you guys are going to
design a system that does replication

3032
01:12:34,920 --> 01:12:34,930
design a system that does replication
 

3033
01:12:34,930 --> 01:12:36,870
design a system that does replication
that actually keeps the replicas in sync

3034
01:12:36,870 --> 01:12:36,880
that actually keeps the replicas in sync
 

3035
01:12:36,880 --> 01:12:38,480
that actually keeps the replicas in sync
and you'll learn you know there's some

3036
01:12:38,480 --> 01:12:38,490
and you'll learn you know there's some
 

3037
01:12:38,490 --> 01:12:41,010
and you'll learn you know there's some
various techniques various things you

3038
01:12:41,010 --> 01:12:41,020
various techniques various things you
 

3039
01:12:41,020 --> 01:12:43,170
various techniques various things you
have to do in order to do that and one

3040
01:12:43,170 --> 01:12:43,180
have to do in order to do that and one
 

3041
01:12:43,180 --> 01:12:46,140
have to do in order to do that and one
of them is that there just has to be

3042
01:12:46,140 --> 01:12:46,150
of them is that there just has to be
 

3043
01:12:46,150 --> 01:12:47,730
of them is that there just has to be
this rule if you want the replicas to

3044
01:12:47,730 --> 01:12:47,740
this rule if you want the replicas to
 

3045
01:12:47,740 --> 01:12:50,400
this rule if you want the replicas to
stay in sync it has to be this rule that

3046
01:12:50,400 --> 01:12:50,410
stay in sync it has to be this rule that
 

3047
01:12:50,410 --> 01:12:53,310
stay in sync it has to be this rule that
you can't have these partial operations

3048
01:12:53,310 --> 01:12:53,320
you can't have these partial operations
 

3049
01:12:53,320 --> 01:12:54,480
you can't have these partial operations
that are applied to only some and not

3050
01:12:54,480 --> 01:12:54,490
that are applied to only some and not
 

3051
01:12:54,490 --> 01:12:56,400
that are applied to only some and not
others and that means that there has to

3052
01:12:56,400 --> 01:12:56,410
others and that means that there has to
 

3053
01:12:56,410 --> 01:12:58,620
others and that means that there has to
be some mechanism to like where the

3054
01:12:58,620 --> 01:12:58,630
be some mechanism to like where the
 

3055
01:12:58,630 --> 01:13:00,120
be some mechanism to like where the
system even if the client dies where the

3056
01:13:00,120 --> 01:13:00,130
system even if the client dies where the
 

3057
01:13:00,130 --> 01:13:01,890
system even if the client dies where the
system says we don't wait a minute there

3058
01:13:01,890 --> 01:13:01,900
system says we don't wait a minute there
 

3059
01:13:01,900 --> 01:13:04,050
system says we don't wait a minute there
was this operation I haven't finished it

3060
01:13:04,050 --> 01:13:04,060
was this operation I haven't finished it
 

3061
01:13:04,060 --> 01:13:07,380
was this operation I haven't finished it
yet so you build systems in which the

3062
01:13:07,380 --> 01:13:07,390
yet so you build systems in which the
 

3063
01:13:07,390 --> 01:13:11,810
yet so you build systems in which the
primary actually make sure the backups

3064
01:13:11,810 --> 01:13:11,820
primary actually make sure the backups
 

3065
01:13:11,820 --> 01:13:29,450
primary actually make sure the backups
get every message

3066
01:13:29,450 --> 01:13:29,460

 

3067
01:13:29,460 --> 01:13:34,380

if the first right abhi failed you think

3068
01:13:34,380 --> 01:13:34,390
if the first right abhi failed you think
 

3069
01:13:34,390 --> 01:13:37,760
if the first right abhi failed you think
the sea should go with the beers

3070
01:13:37,760 --> 01:13:37,770

 

3071
01:13:37,770 --> 01:13:40,440

well it doesn't you may think it should

3072
01:13:40,440 --> 01:13:40,450
well it doesn't you may think it should
 

3073
01:13:40,450 --> 01:13:42,120
well it doesn't you may think it should
but the way the system actually operates

3074
01:13:42,120 --> 01:13:42,130
but the way the system actually operates
 

3075
01:13:42,130 --> 01:13:46,680
but the way the system actually operates
is that the primary will add C to the

3076
01:13:46,680 --> 01:13:46,690
is that the primary will add C to the
 

3077
01:13:46,690 --> 01:13:57,720
is that the primary will add C to the
end of the chunk and the after V yeah I

3078
01:13:57,720 --> 01:13:57,730
end of the chunk and the after V yeah I
 

3079
01:13:57,730 --> 01:13:59,880
end of the chunk and the after V yeah I
mean one reason for this is that at the

3080
01:13:59,880 --> 01:13:59,890
mean one reason for this is that at the
 

3081
01:13:59,890 --> 01:14:01,470
mean one reason for this is that at the
time the right Percy comes in the

3082
01:14:01,470 --> 01:14:01,480
time the right Percy comes in the
 

3083
01:14:01,480 --> 01:14:03,000
time the right Percy comes in the
primary may not actually know what the

3084
01:14:03,000 --> 01:14:03,010
primary may not actually know what the
 

3085
01:14:03,010 --> 01:14:05,700
primary may not actually know what the
fate of B was because we met multiple

3086
01:14:05,700 --> 01:14:05,710
fate of B was because we met multiple
 

3087
01:14:05,710 --> 01:14:07,500
fate of B was because we met multiple
clients submitting a pen's concurrently

3088
01:14:07,500 --> 01:14:07,510
clients submitting a pen's concurrently
 

3089
01:14:07,510 --> 01:14:10,590
clients submitting a pen's concurrently
and you know for high performance you

3090
01:14:10,590 --> 01:14:10,600
and you know for high performance you
 

3091
01:14:10,600 --> 01:14:14,880
and you know for high performance you
want the primary to start the append for

3092
01:14:14,880 --> 01:14:14,890
want the primary to start the append for
 

3093
01:14:14,890 --> 01:14:17,850
want the primary to start the append for
B first and then as soon as I can got

3094
01:14:17,850 --> 01:14:17,860
B first and then as soon as I can got
 

3095
01:14:17,860 --> 01:14:20,160
B first and then as soon as I can got
the next stop set tell everybody did you

3096
01:14:20,160 --> 01:14:20,170
the next stop set tell everybody did you
 

3097
01:14:20,170 --> 01:14:21,740
the next stop set tell everybody did you
see so that all this stuff happens in

3098
01:14:21,740 --> 01:14:21,750
see so that all this stuff happens in
 

3099
01:14:21,750 --> 01:14:25,260
see so that all this stuff happens in
parallel you know by slowing it down you

3100
01:14:25,260 --> 01:14:25,270
parallel you know by slowing it down you
 

3101
01:14:25,270 --> 01:14:31,740
parallel you know by slowing it down you
could you know the primary could sort of

3102
01:14:31,740 --> 01:14:31,750
could you know the primary could sort of
 

3103
01:14:31,750 --> 01:14:33,750
could you know the primary could sort of
decide that B it totally failed and then

3104
01:14:33,750 --> 01:14:33,760
decide that B it totally failed and then
 

3105
01:14:33,760 --> 01:14:35,550
decide that B it totally failed and then
send another round of messages saying

3106
01:14:35,550 --> 01:14:35,560
send another round of messages saying
 

3107
01:14:35,560 --> 01:14:39,960
send another round of messages saying
please undo the right of B and there'll

3108
01:14:39,960 --> 01:14:39,970
please undo the right of B and there'll
 

3109
01:14:39,970 --> 01:14:43,350
please undo the right of B and there'll
be more complex and slower I'm you know

3110
01:14:43,350 --> 01:14:43,360
be more complex and slower I'm you know
 

3111
01:14:43,360 --> 01:14:45,870
be more complex and slower I'm you know
again the the justification for this is

3112
01:14:45,870 --> 01:14:45,880
again the the justification for this is
 

3113
01:14:45,880 --> 01:14:48,720
again the the justification for this is
that the design is pretty simple it you

3114
01:14:48,720 --> 01:14:48,730
that the design is pretty simple it you
 

3115
01:14:48,730 --> 01:14:53,810
that the design is pretty simple it you
know it reveals some odd things to

3116
01:14:53,810 --> 01:14:53,820
know it reveals some odd things to
 

3117
01:14:53,820 --> 01:14:58,050
know it reveals some odd things to
applications and the hope was that

3118
01:14:58,050 --> 01:14:58,060
applications and the hope was that
 

3119
01:14:58,060 --> 01:14:59,670
applications and the hope was that
applications could be relatively easily

3120
01:14:59,670 --> 01:14:59,680
applications could be relatively easily
 

3121
01:14:59,680 --> 01:15:01,740
applications could be relatively easily
written to tolerate records being in

3122
01:15:01,740 --> 01:15:01,750
written to tolerate records being in
 

3123
01:15:01,750 --> 01:15:04,950
written to tolerate records being in
different orders or who knows what or if

3124
01:15:04,950 --> 01:15:04,960
different orders or who knows what or if
 

3125
01:15:04,960 --> 01:15:08,790
different orders or who knows what or if
they couldn't that applications could

3126
01:15:08,790 --> 01:15:08,800
they couldn't that applications could
 

3127
01:15:08,800 --> 01:15:11,070
they couldn't that applications could
either make their own arrangements for

3128
01:15:11,070 --> 01:15:11,080
either make their own arrangements for
 

3129
01:15:11,080 --> 01:15:13,290
either make their own arrangements for
picking an order themselves and writing

3130
01:15:13,290 --> 01:15:13,300
picking an order themselves and writing
 

3131
01:15:13,300 --> 01:15:14,850
picking an order themselves and writing
you know sequence numbers in the files

3132
01:15:14,850 --> 01:15:14,860
you know sequence numbers in the files
 

3133
01:15:14,860 --> 01:15:17,729
you know sequence numbers in the files
or something or you could just have a if

3134
01:15:17,729 --> 01:15:17,739
or something or you could just have a if
 

3135
01:15:17,739 --> 01:15:20,130
or something or you could just have a if
application really was very sensitive to

3136
01:15:20,130 --> 01:15:20,140
application really was very sensitive to
 

3137
01:15:20,140 --> 01:15:21,900
application really was very sensitive to
order you could just not have concurrent

3138
01:15:21,900 --> 01:15:21,910
order you could just not have concurrent
 

3139
01:15:21,910 --> 01:15:24,210
order you could just not have concurrent
depends from different clients to the

3140
01:15:24,210 --> 01:15:24,220
depends from different clients to the
 

3141
01:15:24,220 --> 01:15:27,510
depends from different clients to the
same file right you could just you know

3142
01:15:27,510 --> 01:15:27,520
same file right you could just you know
 

3143
01:15:27,520 --> 01:15:29,400
same file right you could just you know
close files where order is very

3144
01:15:29,400 --> 01:15:29,410
close files where order is very
 

3145
01:15:29,410 --> 01:15:31,380
close files where order is very
important like say it's a movie file you

3146
01:15:31,380 --> 01:15:31,390
important like say it's a movie file you
 

3147
01:15:31,390 --> 01:15:32,740
important like say it's a movie file you
know you don't want to scramble

3148
01:15:32,740 --> 01:15:32,750
know you don't want to scramble
 

3149
01:15:32,750 --> 01:15:35,830
know you don't want to scramble
bytes in a movie file you just write the

3150
01:15:35,830 --> 01:15:35,840
bytes in a movie file you just write the
 

3151
01:15:35,840 --> 01:15:37,540
bytes in a movie file you just write the
Moot file you write the movie to the

3152
01:15:37,540 --> 01:15:37,550
Moot file you write the movie to the
 

3153
01:15:37,550 --> 01:15:40,090
Moot file you write the movie to the
file by one client in sequential order

3154
01:15:40,090 --> 01:15:40,100
file by one client in sequential order
 

3155
01:15:40,100 --> 01:15:49,140
file by one client in sequential order
and not with concurrent record depends

3156
01:15:49,140 --> 01:15:49,150

 

3157
01:15:49,150 --> 01:15:56,670

okay all right

3158
01:15:56,670 --> 01:15:56,680
okay all right
 

3159
01:15:56,680 --> 01:16:04,390
okay all right
the somebody asked basically what would

3160
01:16:04,390 --> 01:16:04,400
the somebody asked basically what would
 

3161
01:16:04,400 --> 01:16:06,760
the somebody asked basically what would
it take to turn this design into one

3162
01:16:06,760 --> 01:16:06,770
it take to turn this design into one
 

3163
01:16:06,770 --> 01:16:08,110
it take to turn this design into one
which actually provided strong

3164
01:16:08,110 --> 01:16:08,120
which actually provided strong
 

3165
01:16:08,120 --> 01:16:11,950
which actually provided strong
consistency consistency closer to our

3166
01:16:11,950 --> 01:16:11,960
consistency consistency closer to our
 

3167
01:16:11,960 --> 01:16:13,780
consistency consistency closer to our
sort of single server model where

3168
01:16:13,780 --> 01:16:13,790
sort of single server model where
 

3169
01:16:13,790 --> 01:16:18,670
sort of single server model where
there's no surprises I don't actually

3170
01:16:18,670 --> 01:16:18,680
there's no surprises I don't actually
 

3171
01:16:18,680 --> 01:16:20,170
there's no surprises I don't actually
know because you know that requires an

3172
01:16:20,170 --> 01:16:20,180
know because you know that requires an
 

3173
01:16:20,180 --> 01:16:22,330
know because you know that requires an
entire new complex design it's not clear

3174
01:16:22,330 --> 01:16:22,340
entire new complex design it's not clear
 

3175
01:16:22,340 --> 01:16:24,550
entire new complex design it's not clear
how to mutate GFS to be that design but

3176
01:16:24,550 --> 01:16:24,560
how to mutate GFS to be that design but
 

3177
01:16:24,560 --> 01:16:26,320
how to mutate GFS to be that design but
I can list for you lists for you some

3178
01:16:26,320 --> 01:16:26,330
I can list for you lists for you some
 

3179
01:16:26,330 --> 01:16:27,430
I can list for you lists for you some
things that you would want to think

3180
01:16:27,430 --> 01:16:27,440
things that you would want to think
 

3181
01:16:27,440 --> 01:16:32,340
things that you would want to think
about if you wanted to upgrade GFS to a

3182
01:16:32,340 --> 01:16:32,350
about if you wanted to upgrade GFS to a
 

3183
01:16:32,350 --> 01:16:34,450
about if you wanted to upgrade GFS to a
assistance did have strong consistency

3184
01:16:34,450 --> 01:16:34,460
assistance did have strong consistency
 

3185
01:16:34,460 --> 01:16:37,360
assistance did have strong consistency
one is that you probably need the

3186
01:16:37,360 --> 01:16:37,370
one is that you probably need the
 

3187
01:16:37,370 --> 01:16:40,930
one is that you probably need the
primary to detect duplicate requests so

3188
01:16:40,930 --> 01:16:40,940
primary to detect duplicate requests so
 

3189
01:16:40,940 --> 01:16:43,450
primary to detect duplicate requests so
that when this second becomes in the

3190
01:16:43,450 --> 01:16:43,460
that when this second becomes in the
 

3191
01:16:43,460 --> 01:16:44,950
that when this second becomes in the
primary is aware that oh actually you

3192
01:16:44,950 --> 01:16:44,960
primary is aware that oh actually you
 

3193
01:16:44,960 --> 01:16:47,020
primary is aware that oh actually you
know we already saw that request earlier

3194
01:16:47,020 --> 01:16:47,030
know we already saw that request earlier
 

3195
01:16:47,030 --> 01:16:50,560
know we already saw that request earlier
and did it or didn't do it and to try to

3196
01:16:50,560 --> 01:16:50,570
and did it or didn't do it and to try to
 

3197
01:16:50,570 --> 01:16:52,150
and did it or didn't do it and to try to
make sure that B doesn't show up twice

3198
01:16:52,150 --> 01:16:52,160
make sure that B doesn't show up twice
 

3199
01:16:52,160 --> 01:16:54,130
make sure that B doesn't show up twice
in the file so one is you're gonna need

3200
01:16:54,130 --> 01:16:54,140
in the file so one is you're gonna need
 

3201
01:16:54,140 --> 01:16:59,560
in the file so one is you're gonna need
duplicate detection another issues you

3202
01:16:59,560 --> 01:16:59,570
duplicate detection another issues you
 

3203
01:16:59,570 --> 01:17:02,650
duplicate detection another issues you
probably if a secondary is acting a

3204
01:17:02,650 --> 01:17:02,660
probably if a secondary is acting a
 

3205
01:17:02,660 --> 01:17:04,990
probably if a secondary is acting a
secondary you really need to design the

3206
01:17:04,990 --> 01:17:05,000
secondary you really need to design the
 

3207
01:17:05,000 --> 01:17:06,910
secondary you really need to design the
system so that if the primary tells a

3208
01:17:06,910 --> 01:17:06,920
system so that if the primary tells a
 

3209
01:17:06,920 --> 01:17:08,170
system so that if the primary tells a
secondary to do something

3210
01:17:08,170 --> 01:17:08,180
secondary to do something
 

3211
01:17:08,180 --> 01:17:10,000
secondary to do something
the secondary actually does it and

3212
01:17:10,000 --> 01:17:10,010
the secondary actually does it and
 

3213
01:17:10,010 --> 01:17:12,550
the secondary actually does it and
doesn't just return error right for a

3214
01:17:12,550 --> 01:17:12,560
doesn't just return error right for a
 

3215
01:17:12,560 --> 01:17:15,250
doesn't just return error right for a
strictly consistent system having the

3216
01:17:15,250 --> 01:17:15,260
strictly consistent system having the
 

3217
01:17:15,260 --> 01:17:16,870
strictly consistent system having the
secondaries be able to just sort of blow

3218
01:17:16,870 --> 01:17:16,880
secondaries be able to just sort of blow
 

3219
01:17:16,880 --> 01:17:20,200
secondaries be able to just sort of blow
off primary requests with really no

3220
01:17:20,200 --> 01:17:20,210
off primary requests with really no
 

3221
01:17:20,210 --> 01:17:24,160
off primary requests with really no
compensation is not okay so I think the

3222
01:17:24,160 --> 01:17:24,170
compensation is not okay so I think the
 

3223
01:17:24,170 --> 01:17:25,720
compensation is not okay so I think the
secondaries have to accept requests and

3224
01:17:25,720 --> 01:17:25,730
secondaries have to accept requests and
 

3225
01:17:25,730 --> 01:17:28,450
secondaries have to accept requests and
execute them or if a secondary has some

3226
01:17:28,450 --> 01:17:28,460
execute them or if a secondary has some
 

3227
01:17:28,460 --> 01:17:30,040
execute them or if a secondary has some
sort of permanent damage like it's disk

3228
01:17:30,040 --> 01:17:30,050
sort of permanent damage like it's disk
 

3229
01:17:30,050 --> 01:17:32,170
sort of permanent damage like it's disk
got unplugged by mistake this you need

3230
01:17:32,170 --> 01:17:32,180
got unplugged by mistake this you need
 

3231
01:17:32,180 --> 01:17:34,150
got unplugged by mistake this you need
to have a mechanism to like take the

3232
01:17:34,150 --> 01:17:34,160
to have a mechanism to like take the
 

3233
01:17:34,160 --> 01:17:36,190
to have a mechanism to like take the
secondary out of the system so the

3234
01:17:36,190 --> 01:17:36,200
secondary out of the system so the
 

3235
01:17:36,200 --> 01:17:39,130
secondary out of the system so the
primary can proceed with the remaining

3236
01:17:39,130 --> 01:17:39,140
primary can proceed with the remaining
 

3237
01:17:39,140 --> 01:17:41,740
primary can proceed with the remaining
secondaries but GFS kind of doesn't

3238
01:17:41,740 --> 01:17:41,750
secondaries but GFS kind of doesn't
 

3239
01:17:41,750 --> 01:17:45,190
secondaries but GFS kind of doesn't
either at least not right away

3240
01:17:45,190 --> 01:17:45,200

 

3241
01:17:45,200 --> 01:17:49,340

and so that also means that when the

3242
01:17:49,340 --> 01:17:49,350
and so that also means that when the
 

3243
01:17:49,350 --> 01:17:50,900
and so that also means that when the
primary asks secondary's to append

3244
01:17:50,900 --> 01:17:50,910
primary asks secondary's to append
 

3245
01:17:50,910 --> 01:17:52,790
primary asks secondary's to append
something the secondaries have to be

3246
01:17:52,790 --> 01:17:52,800
something the secondaries have to be
 

3247
01:17:52,800 --> 01:17:54,800
something the secondaries have to be
careful not to expose that data to

3248
01:17:54,800 --> 01:17:54,810
careful not to expose that data to
 

3249
01:17:54,810 --> 01:17:57,590
careful not to expose that data to
readers until the primary is sure that

3250
01:17:57,590 --> 01:17:57,600
readers until the primary is sure that
 

3251
01:17:57,600 --> 01:17:59,240
readers until the primary is sure that
all the secondaries really will be able

3252
01:17:59,240 --> 01:17:59,250
all the secondaries really will be able
 

3253
01:17:59,250 --> 01:18:02,600
all the secondaries really will be able
to execute the append so you might need

3254
01:18:02,600 --> 01:18:02,610
to execute the append so you might need
 

3255
01:18:02,610 --> 01:18:05,390
to execute the append so you might need
sort of multiple phases in the rights of

3256
01:18:05,390 --> 01:18:05,400
sort of multiple phases in the rights of
 

3257
01:18:05,400 --> 01:18:06,890
sort of multiple phases in the rights of
first phase in which the primary asks

3258
01:18:06,890 --> 01:18:06,900
first phase in which the primary asks
 

3259
01:18:06,900 --> 01:18:09,020
first phase in which the primary asks
the secondaries look you know I really

3260
01:18:09,020 --> 01:18:09,030
the secondaries look you know I really
 

3261
01:18:09,030 --> 01:18:11,300
the secondaries look you know I really
like you to do this operation can you do

3262
01:18:11,300 --> 01:18:11,310
like you to do this operation can you do
 

3263
01:18:11,310 --> 01:18:13,550
like you to do this operation can you do
it but don't don't actually do it yet

3264
01:18:13,550 --> 01:18:13,560
it but don't don't actually do it yet
 

3265
01:18:13,560 --> 01:18:15,800
it but don't don't actually do it yet
and if all the secondaries answer with a

3266
01:18:15,800 --> 01:18:15,810
and if all the secondaries answer with a
 

3267
01:18:15,810 --> 01:18:17,660
and if all the secondaries answer with a
promise to be able to do the operation

3268
01:18:17,660 --> 01:18:17,670
promise to be able to do the operation
 

3269
01:18:17,670 --> 01:18:20,540
promise to be able to do the operation
only then the primary says alright

3270
01:18:20,540 --> 01:18:20,550
only then the primary says alright
 

3271
01:18:20,550 --> 01:18:22,070
only then the primary says alright
everybody go ahead and do that operation

3272
01:18:22,070 --> 01:18:22,080
everybody go ahead and do that operation
 

3273
01:18:22,080 --> 01:18:24,560
everybody go ahead and do that operation
you promised and people you know that's

3274
01:18:24,560 --> 01:18:24,570
you promised and people you know that's
 

3275
01:18:24,570 --> 01:18:27,200
you promised and people you know that's
the way a lot of real world systems

3276
01:18:27,200 --> 01:18:27,210
the way a lot of real world systems
 

3277
01:18:27,210 --> 01:18:28,940
the way a lot of real world systems
strong consistent systems work and that

3278
01:18:28,940 --> 01:18:28,950
strong consistent systems work and that
 

3279
01:18:28,950 --> 01:18:32,620
strong consistent systems work and that
trick it's called two-phase commit

3280
01:18:32,620 --> 01:18:32,630

 

3281
01:18:32,630 --> 01:18:34,580

another issue is that if the primary

3282
01:18:34,580 --> 01:18:34,590
another issue is that if the primary
 

3283
01:18:34,590 --> 01:18:38,360
another issue is that if the primary
crashes there will have been some last

3284
01:18:38,360 --> 01:18:38,370
crashes there will have been some last
 

3285
01:18:38,370 --> 01:18:40,400
crashes there will have been some last
set of operations that the primary had

3286
01:18:40,400 --> 01:18:40,410
set of operations that the primary had
 

3287
01:18:40,410 --> 01:18:44,330
set of operations that the primary had
launched started to the secondaries but

3288
01:18:44,330 --> 01:18:44,340
launched started to the secondaries but
 

3289
01:18:44,340 --> 01:18:46,880
launched started to the secondaries but
the primary crashed before it was sure

3290
01:18:46,880 --> 01:18:46,890
the primary crashed before it was sure
 

3291
01:18:46,890 --> 01:18:48,890
the primary crashed before it was sure
whether those all the secondaries got

3292
01:18:48,890 --> 01:18:48,900
whether those all the secondaries got
 

3293
01:18:48,900 --> 01:18:51,650
whether those all the secondaries got
there copied the operation or not so if

3294
01:18:51,650 --> 01:18:51,660
there copied the operation or not so if
 

3295
01:18:51,660 --> 01:18:54,500
there copied the operation or not so if
the primary crashes you know a new

3296
01:18:54,500 --> 01:18:54,510
the primary crashes you know a new
 

3297
01:18:54,510 --> 01:18:56,030
the primary crashes you know a new
primary one of the secondaries is going

3298
01:18:56,030 --> 01:18:56,040
primary one of the secondaries is going
 

3299
01:18:56,040 --> 01:18:57,770
primary one of the secondaries is going
to take over as primary but at that

3300
01:18:57,770 --> 01:18:57,780
to take over as primary but at that
 

3301
01:18:57,780 --> 01:19:01,190
to take over as primary but at that
point the second the new primary and the

3302
01:19:01,190 --> 01:19:01,200
point the second the new primary and the
 

3303
01:19:01,200 --> 01:19:03,230
point the second the new primary and the
remaining secondaries may differ in the

3304
01:19:03,230 --> 01:19:03,240
remaining secondaries may differ in the
 

3305
01:19:03,240 --> 01:19:05,570
remaining secondaries may differ in the
last few operations because maybe some

3306
01:19:05,570 --> 01:19:05,580
last few operations because maybe some
 

3307
01:19:05,580 --> 01:19:07,190
last few operations because maybe some
of them didn't get the message before

3308
01:19:07,190 --> 01:19:07,200
of them didn't get the message before
 

3309
01:19:07,200 --> 01:19:09,020
of them didn't get the message before
the primary crashed and so the new

3310
01:19:09,020 --> 01:19:09,030
the primary crashed and so the new
 

3311
01:19:09,030 --> 01:19:11,480
the primary crashed and so the new
primer has to start by explicitly

3312
01:19:11,480 --> 01:19:11,490
primer has to start by explicitly
 

3313
01:19:11,490 --> 01:19:15,290
primer has to start by explicitly
resynchronizing with the secondaries to

3314
01:19:15,290 --> 01:19:15,300
resynchronizing with the secondaries to
 

3315
01:19:15,300 --> 01:19:17,000
resynchronizing with the secondaries to
make sure that the sort of the tail of

3316
01:19:17,000 --> 01:19:17,010
make sure that the sort of the tail of
 

3317
01:19:17,010 --> 01:19:21,070
make sure that the sort of the tail of
their operation histories are the same

3318
01:19:21,070 --> 01:19:21,080

 

3319
01:19:21,080 --> 01:19:24,050

finally to deal with this problem of oh

3320
01:19:24,050 --> 01:19:24,060
finally to deal with this problem of oh
 

3321
01:19:24,060 --> 01:19:25,520
finally to deal with this problem of oh
you know there may be times when the

3322
01:19:25,520 --> 01:19:25,530
you know there may be times when the
 

3323
01:19:25,530 --> 01:19:28,490
you know there may be times when the
secondaries differ or the client may

3324
01:19:28,490 --> 01:19:28,500
secondaries differ or the client may
 

3325
01:19:28,500 --> 01:19:31,190
secondaries differ or the client may
have a slightly stale indication from

3326
01:19:31,190 --> 01:19:31,200
have a slightly stale indication from
 

3327
01:19:31,200 --> 01:19:32,990
have a slightly stale indication from
the master of which secondary to talk to

3328
01:19:32,990 --> 01:19:33,000
the master of which secondary to talk to
 

3329
01:19:33,000 --> 01:19:35,930
the master of which secondary to talk to
the system either needs to send all

3330
01:19:35,930 --> 01:19:35,940
the system either needs to send all
 

3331
01:19:35,940 --> 01:19:38,000
the system either needs to send all
client reads through the primary because

3332
01:19:38,000 --> 01:19:38,010
client reads through the primary because
 

3333
01:19:38,010 --> 01:19:41,480
client reads through the primary because
only the primary is likely to know which

3334
01:19:41,480 --> 01:19:41,490
only the primary is likely to know which
 

3335
01:19:41,490 --> 01:19:43,850
only the primary is likely to know which
operations have really happened or we

3336
01:19:43,850 --> 01:19:43,860
operations have really happened or we
 

3337
01:19:43,860 --> 01:19:45,560
operations have really happened or we
need a least system for the secondaries

3338
01:19:45,560 --> 01:19:45,570
need a least system for the secondaries
 

3339
01:19:45,570 --> 01:19:47,390
need a least system for the secondaries
just like we have for the primary so

3340
01:19:47,390 --> 01:19:47,400
just like we have for the primary so
 

3341
01:19:47,400 --> 01:19:50,690
just like we have for the primary so
that it's well understood that when

3342
01:19:50,690 --> 01:19:50,700
that it's well understood that when
 

3343
01:19:50,700 --> 01:19:55,020
that it's well understood that when
secondary Canon can't legally respond

3344
01:19:55,020 --> 01:19:55,030
secondary Canon can't legally respond
 

3345
01:19:55,030 --> 01:19:56,640
secondary Canon can't legally respond
a client and so these are the things I'm

3346
01:19:56,640 --> 01:19:56,650
a client and so these are the things I'm
 

3347
01:19:56,650 --> 01:19:58,560
a client and so these are the things I'm
aware of that would have to be fixed in

3348
01:19:58,560 --> 01:19:58,570
aware of that would have to be fixed in
 

3349
01:19:58,570 --> 01:20:00,540
aware of that would have to be fixed in
this system tor added complexity and

3350
01:20:00,540 --> 01:20:00,550
this system tor added complexity and
 

3351
01:20:00,550 --> 01:20:02,220
this system tor added complexity and
chitchat to make it have strong

3352
01:20:02,220 --> 01:20:02,230
chitchat to make it have strong
 

3353
01:20:02,230 --> 01:20:05,040
chitchat to make it have strong
consistency and you're actually the way

3354
01:20:05,040 --> 01:20:05,050
consistency and you're actually the way
 

3355
01:20:05,050 --> 01:20:08,010
consistency and you're actually the way
I got that list was by thinking about

3356
01:20:08,010 --> 01:20:08,020
I got that list was by thinking about
 

3357
01:20:08,020 --> 01:20:09,930
I got that list was by thinking about
the labs you're gonna end up doing all

3358
01:20:09,930 --> 01:20:09,940
the labs you're gonna end up doing all
 

3359
01:20:09,940 --> 01:20:12,089
the labs you're gonna end up doing all
the things I just talked about as part

3360
01:20:12,089 --> 01:20:12,099
the things I just talked about as part
 

3361
01:20:12,099 --> 01:20:13,979
the things I just talked about as part
of labs two and three to build a

3362
01:20:13,979 --> 01:20:13,989
of labs two and three to build a
 

3363
01:20:13,989 --> 01:20:18,930
of labs two and three to build a
strictly consistent system okay so let

3364
01:20:18,930 --> 01:20:18,940
strictly consistent system okay so let
 

3365
01:20:18,940 --> 01:20:21,089
strictly consistent system okay so let
me spend one minute on there's actually

3366
01:20:21,089 --> 01:20:21,099
me spend one minute on there's actually
 

3367
01:20:21,099 --> 01:20:23,069
me spend one minute on there's actually
I have a link in the notes to a sort of

3368
01:20:23,069 --> 01:20:23,079
I have a link in the notes to a sort of
 

3369
01:20:23,079 --> 01:20:25,830
I have a link in the notes to a sort of
retrospective interview about how well

3370
01:20:25,830 --> 01:20:25,840
retrospective interview about how well
 

3371
01:20:25,840 --> 01:20:28,379
retrospective interview about how well
GFS played out over the first five or

3372
01:20:28,379 --> 01:20:28,389
GFS played out over the first five or
 

3373
01:20:28,389 --> 01:20:32,760
GFS played out over the first five or
ten years of his life at Google so the

3374
01:20:32,760 --> 01:20:32,770
ten years of his life at Google so the
 

3375
01:20:32,770 --> 01:20:36,209
ten years of his life at Google so the
high-level summary is that the most is

3376
01:20:36,209 --> 01:20:36,219
high-level summary is that the most is
 

3377
01:20:36,219 --> 01:20:37,680
high-level summary is that the most is
that was tremendously successful and

3378
01:20:37,680 --> 01:20:37,690
that was tremendously successful and
 

3379
01:20:37,690 --> 01:20:40,560
that was tremendously successful and
many many Google applications used it in

3380
01:20:40,560 --> 01:20:40,570
many many Google applications used it in
 

3381
01:20:40,570 --> 01:20:42,990
many many Google applications used it in
a number of Google infrastructure was

3382
01:20:42,990 --> 01:20:43,000
a number of Google infrastructure was
 

3383
01:20:43,000 --> 01:20:45,240
a number of Google infrastructure was
built as a late like big file for

3384
01:20:45,240 --> 01:20:45,250
built as a late like big file for
 

3385
01:20:45,250 --> 01:20:47,399
built as a late like big file for
example BigTable I mean was built as a

3386
01:20:47,399 --> 01:20:47,409
example BigTable I mean was built as a
 

3387
01:20:47,409 --> 01:20:50,180
example BigTable I mean was built as a
layer on top of GFS and MapReduce also

3388
01:20:50,180 --> 01:20:50,190
layer on top of GFS and MapReduce also
 

3389
01:20:50,190 --> 01:20:54,540
layer on top of GFS and MapReduce also
so widely used within Google may be the

3390
01:20:54,540 --> 01:20:54,550
so widely used within Google may be the
 

3391
01:20:54,550 --> 01:20:57,450
so widely used within Google may be the
most serious limitation is that there

3392
01:20:57,450 --> 01:20:57,460
most serious limitation is that there
 

3393
01:20:57,460 --> 01:20:59,279
most serious limitation is that there
was a single master and the master had

3394
01:20:59,279 --> 01:20:59,289
was a single master and the master had
 

3395
01:20:59,289 --> 01:21:01,500
was a single master and the master had
to have a table entry for every file in

3396
01:21:01,500 --> 01:21:01,510
to have a table entry for every file in
 

3397
01:21:01,510 --> 01:21:04,500
to have a table entry for every file in
every chunk and that men does the GFS

3398
01:21:04,500 --> 01:21:04,510
every chunk and that men does the GFS
 

3399
01:21:04,510 --> 01:21:06,810
every chunk and that men does the GFS
use grew and they're about more and more

3400
01:21:06,810 --> 01:21:06,820
use grew and they're about more and more
 

3401
01:21:06,820 --> 01:21:08,640
use grew and they're about more and more
files the master just ran out of memory

3402
01:21:08,640 --> 01:21:08,650
files the master just ran out of memory
 

3403
01:21:08,650 --> 01:21:11,970
files the master just ran out of memory
ran out of RAM to store the files and

3404
01:21:11,970 --> 01:21:11,980
ran out of RAM to store the files and
 

3405
01:21:11,980 --> 01:21:13,680
ran out of RAM to store the files and
you know you can put more RAM on but

3406
01:21:13,680 --> 01:21:13,690
you know you can put more RAM on but
 

3407
01:21:13,690 --> 01:21:15,000
you know you can put more RAM on but
there's limits to how much RAM a single

3408
01:21:15,000 --> 01:21:15,010
there's limits to how much RAM a single
 

3409
01:21:15,010 --> 01:21:18,299
there's limits to how much RAM a single
machine can have and so that was the

3410
01:21:18,299 --> 01:21:18,309
machine can have and so that was the
 

3411
01:21:18,309 --> 01:21:19,589
machine can have and so that was the
most of the most immediate problem

3412
01:21:19,589 --> 01:21:19,599
most of the most immediate problem
 

3413
01:21:19,599 --> 01:21:24,149
most of the most immediate problem
people ran into in addition the load on

3414
01:21:24,149 --> 01:21:24,159
people ran into in addition the load on
 

3415
01:21:24,159 --> 01:21:25,859
people ran into in addition the load on
a single master from thousands of

3416
01:21:25,859 --> 01:21:25,869
a single master from thousands of
 

3417
01:21:25,869 --> 01:21:28,020
a single master from thousands of
clients started to be too much in the

3418
01:21:28,020 --> 01:21:28,030
clients started to be too much in the
 

3419
01:21:28,030 --> 01:21:29,640
clients started to be too much in the
master kernel they see if you can only

3420
01:21:29,640 --> 01:21:29,650
master kernel they see if you can only
 

3421
01:21:29,650 --> 01:21:30,930
master kernel they see if you can only
process however many hundreds of

3422
01:21:30,930 --> 01:21:30,940
process however many hundreds of
 

3423
01:21:30,940 --> 01:21:33,060
process however many hundreds of
requests per second especially the right

3424
01:21:33,060 --> 01:21:33,070
requests per second especially the right
 

3425
01:21:33,070 --> 01:21:35,729
requests per second especially the right
things to disk and pretty soon there got

3426
01:21:35,729 --> 01:21:35,739
things to disk and pretty soon there got
 

3427
01:21:35,739 --> 01:21:39,870
things to disk and pretty soon there got
to be too many clients another problem

3428
01:21:39,870 --> 01:21:39,880
to be too many clients another problem
 

3429
01:21:39,880 --> 01:21:41,399
to be too many clients another problem
with a some applications found it hard

3430
01:21:41,399 --> 01:21:41,409
with a some applications found it hard
 

3431
01:21:41,409 --> 01:21:44,250
with a some applications found it hard
to deal with this kind of sort of odd

3432
01:21:44,250 --> 01:21:44,260
to deal with this kind of sort of odd
 

3433
01:21:44,260 --> 01:21:47,490
to deal with this kind of sort of odd
semantics and a final problem is that

3434
01:21:47,490 --> 01:21:47,500
semantics and a final problem is that
 

3435
01:21:47,500 --> 01:21:49,589
semantics and a final problem is that
the master that was not an automatic

3436
01:21:49,589 --> 01:21:49,599
the master that was not an automatic
 

3437
01:21:49,599 --> 01:21:52,049
the master that was not an automatic
story for master failover

3438
01:21:52,049 --> 01:21:52,059
story for master failover
 

3439
01:21:52,059 --> 01:21:54,390
story for master failover
in the original in the GFS paper as we

3440
01:21:54,390 --> 01:21:54,400
in the original in the GFS paper as we
 

3441
01:21:54,400 --> 01:21:56,430
in the original in the GFS paper as we
read it like required human intervention

3442
01:21:56,430 --> 01:21:56,440
read it like required human intervention
 

3443
01:21:56,440 --> 01:21:59,160
read it like required human intervention
to deal with a master that had sort of

3444
01:21:59,160 --> 01:21:59,170
to deal with a master that had sort of
 

3445
01:21:59,170 --> 01:22:00,450
to deal with a master that had sort of
permanently crashed and needs to be

3446
01:22:00,450 --> 01:22:00,460
permanently crashed and needs to be
 

3447
01:22:00,460 --> 01:22:03,569
permanently crashed and needs to be
replaced and that could take tens of

3448
01:22:03,569 --> 01:22:03,579
replaced and that could take tens of
 

3449
01:22:03,579 --> 01:22:05,970
replaced and that could take tens of
minutes or more I was just too long for

3450
01:22:05,970 --> 01:22:05,980
minutes or more I was just too long for
 

3451
01:22:05,980 --> 01:22:09,350
minutes or more I was just too long for
failure recovery for some applications

3452
01:22:09,350 --> 01:22:09,360
failure recovery for some applications
 

3453
01:22:09,360 --> 01:22:13,620
failure recovery for some applications
okay excellent I'll see you on Thursday

3454
01:22:13,620 --> 01:22:13,630
okay excellent I'll see you on Thursday
 

3455
01:22:13,630 --> 01:22:15,960
okay excellent I'll see you on Thursday
and we'll hear more about all these

3456
01:22:15,960 --> 01:22:15,970
and we'll hear more about all these
 

3457
01:22:15,970 --> 01:22:19,290
and we'll hear more about all these
themes over the semester

