1
00:00:00,060 --> 00:00:02,360

I'd like to like to talk about farms day

2
00:00:02,360 --> 00:00:02,370
I'd like to like to talk about farms day
 

3
00:00:02,370 --> 00:00:06,140
I'd like to like to talk about farms day
and optimistic concurrency control which

4
00:00:06,140 --> 00:00:06,150
and optimistic concurrency control which
 

5
00:00:06,150 --> 00:00:07,700
and optimistic concurrency control which
is the main interesting technique that

6
00:00:07,700 --> 00:00:07,710
is the main interesting technique that
 

7
00:00:07,710 --> 00:00:10,850
is the main interesting technique that
uses the reason we're talking about farm

8
00:00:10,850 --> 00:00:10,860
uses the reason we're talking about farm
 

9
00:00:10,860 --> 00:00:14,450
uses the reason we're talking about farm
it's this the last paper in the series

10
00:00:14,450 --> 00:00:14,460
it's this the last paper in the series
 

11
00:00:14,460 --> 00:00:16,340
it's this the last paper in the series
about transactions and replication and

12
00:00:16,340 --> 00:00:16,350
about transactions and replication and
 

13
00:00:16,350 --> 00:00:19,400
about transactions and replication and
sharding and this is still an open

14
00:00:19,400 --> 00:00:19,410
sharding and this is still an open
 

15
00:00:19,410 --> 00:00:21,710
sharding and this is still an open
research area where people are totally

16
00:00:21,710 --> 00:00:21,720
research area where people are totally
 

17
00:00:21,720 --> 00:00:25,790
research area where people are totally
not satisfied with performance or in the

18
00:00:25,790 --> 00:00:25,800
not satisfied with performance or in the
 

19
00:00:25,800 --> 00:00:30,349
not satisfied with performance or in the
kind of performance versus consistency

20
00:00:30,349 --> 00:00:30,359
kind of performance versus consistency
 

21
00:00:30,359 --> 00:00:31,460
kind of performance versus consistency
trade-offs that are available and

22
00:00:31,460 --> 00:00:31,470
trade-offs that are available and
 

23
00:00:31,470 --> 00:00:32,659
trade-offs that are available and
they're still trying to do better

24
00:00:32,659 --> 00:00:32,669
they're still trying to do better
 

25
00:00:32,669 --> 00:00:34,790
they're still trying to do better
and in particular this particular paper

26
00:00:34,790 --> 00:00:34,800
and in particular this particular paper
 

27
00:00:34,800 --> 00:00:36,770
and in particular this particular paper
is motivated by the huge performance

28
00:00:36,770 --> 00:00:36,780
is motivated by the huge performance
 

29
00:00:36,780 --> 00:00:41,560
is motivated by the huge performance
potential of these new RDMA NICs

30
00:00:41,560 --> 00:00:41,570
potential of these new RDMA NICs
 

31
00:00:41,570 --> 00:00:43,790
potential of these new RDMA NICs
so you may be wondering since we just

32
00:00:43,790 --> 00:00:43,800
so you may be wondering since we just
 

33
00:00:43,800 --> 00:00:44,750
so you may be wondering since we just
read about spanner

34
00:00:44,750 --> 00:00:44,760
read about spanner
 

35
00:00:44,760 --> 00:00:47,990
read about spanner
how farm differs some spanner both of

36
00:00:47,990 --> 00:00:48,000
how farm differs some spanner both of
 

37
00:00:48,000 --> 00:00:49,369
how farm differs some spanner both of
them after all replicate and they use

38
00:00:49,369 --> 00:00:49,379
them after all replicate and they use
 

39
00:00:49,379 --> 00:00:51,650
them after all replicate and they use
two-phase commit for transactions of

40
00:00:51,650 --> 00:00:51,660
two-phase commit for transactions of
 

41
00:00:51,660 --> 00:00:54,010
two-phase commit for transactions of
that level they seem pretty similar

42
00:00:54,010 --> 00:00:54,020
that level they seem pretty similar
 

43
00:00:54,020 --> 00:00:56,840
that level they seem pretty similar
spanner as a is a deployed systems been

44
00:00:56,840 --> 00:00:56,850
spanner as a is a deployed systems been
 

45
00:00:56,850 --> 00:01:00,049
spanner as a is a deployed systems been
used a lot for a long time its main

46
00:01:00,049 --> 00:01:00,059
used a lot for a long time its main
 

47
00:01:00,059 --> 00:01:02,630
used a lot for a long time its main
focus is on Geographic replication that

48
00:01:02,630 --> 00:01:02,640
focus is on Geographic replication that
 

49
00:01:02,640 --> 00:01:04,549
focus is on Geographic replication that
is to be able to have copies on there

50
00:01:04,549 --> 00:01:04,559
is to be able to have copies on there
 

51
00:01:04,559 --> 00:01:06,920
is to be able to have copies on there
like east and west coasts and different

52
00:01:06,920 --> 00:01:06,930
like east and west coasts and different
 

53
00:01:06,930 --> 00:01:08,990
like east and west coasts and different
data centers and be able to have

54
00:01:08,990 --> 00:01:09,000
data centers and be able to have
 

55
00:01:09,000 --> 00:01:11,179
data centers and be able to have
reasonably efficient transactions that

56
00:01:11,179 --> 00:01:11,189
reasonably efficient transactions that
 

57
00:01:11,189 --> 00:01:13,789
reasonably efficient transactions that
involve pieces of data in lots of

58
00:01:13,789 --> 00:01:13,799
involve pieces of data in lots of
 

59
00:01:13,799 --> 00:01:16,580
involve pieces of data in lots of
different places and the most innovative

60
00:01:16,580 --> 00:01:16,590
different places and the most innovative
 

61
00:01:16,590 --> 00:01:18,800
different places and the most innovative
thing about it because in order to try

62
00:01:18,800 --> 00:01:18,810
thing about it because in order to try
 

63
00:01:18,810 --> 00:01:20,630
thing about it because in order to try
to solve the problem of how long it

64
00:01:20,630 --> 00:01:20,640
to solve the problem of how long it
 

65
00:01:20,640 --> 00:01:22,940
to solve the problem of how long it
takes to do two-phase commit over long

66
00:01:22,940 --> 00:01:22,950
takes to do two-phase commit over long
 

67
00:01:22,950 --> 00:01:26,109
takes to do two-phase commit over long
distances is that it has a special

68
00:01:26,109 --> 00:01:26,119
distances is that it has a special
 

69
00:01:26,119 --> 00:01:27,770
distances is that it has a special
optimization path for read-only

70
00:01:27,770 --> 00:01:27,780
optimization path for read-only
 

71
00:01:27,780 --> 00:01:32,179
optimization path for read-only
transactions using synchronized time and

72
00:01:32,179 --> 00:01:32,189
transactions using synchronized time and
 

73
00:01:32,189 --> 00:01:34,510
transactions using synchronized time and
the performance you get out of spanner

74
00:01:34,510 --> 00:01:34,520
the performance you get out of spanner
 

75
00:01:34,520 --> 00:01:36,670
the performance you get out of spanner
if you remember is that a read/write

76
00:01:36,670 --> 00:01:36,680
if you remember is that a read/write
 

77
00:01:36,680 --> 00:01:40,370
if you remember is that a read/write
transaction takes 10 to 100 milliseconds

78
00:01:40,370 --> 00:01:40,380
transaction takes 10 to 100 milliseconds
 

79
00:01:40,380 --> 00:01:42,499
transaction takes 10 to 100 milliseconds
depending on how close together the

80
00:01:42,499 --> 00:01:42,509
depending on how close together the
 

81
00:01:42,509 --> 00:01:46,160
depending on how close together the
different data centers are farm makes a

82
00:01:46,160 --> 00:01:46,170
different data centers are farm makes a
 

83
00:01:46,170 --> 00:01:49,069
different data centers are farm makes a
very different set of design decisions

84
00:01:49,069 --> 00:01:49,079
very different set of design decisions
 

85
00:01:49,079 --> 00:01:50,780
very different set of design decisions
and targets a different kind of workload

86
00:01:50,780 --> 00:01:50,790
and targets a different kind of workload
 

87
00:01:50,790 --> 00:01:52,700
and targets a different kind of workload
first of all it's a research prototype

88
00:01:52,700 --> 00:01:52,710
first of all it's a research prototype
 

89
00:01:52,710 --> 00:01:54,530
first of all it's a research prototype
so it's not by any means a finished

90
00:01:54,530 --> 00:01:54,540
so it's not by any means a finished
 

91
00:01:54,540 --> 00:01:57,380
so it's not by any means a finished
product and the goal is to explore the

92
00:01:57,380 --> 00:01:57,390
product and the goal is to explore the
 

93
00:01:57,390 --> 00:02:00,499
product and the goal is to explore the
potential of these new RDMA high speed

94
00:02:00,499 --> 00:02:00,509
potential of these new RDMA high speed
 

95
00:02:00,509 --> 00:02:04,249
potential of these new RDMA high speed
networking hardware so it's really still

96
00:02:04,249 --> 00:02:04,259
networking hardware so it's really still
 

97
00:02:04,259 --> 00:02:08,119
networking hardware so it's really still
an exploratory system it assumes that

98
00:02:08,119 --> 00:02:08,129
an exploratory system it assumes that
 

99
00:02:08,129 --> 00:02:09,609
an exploratory system it assumes that
all replicas are in the same data center

100
00:02:09,609 --> 00:02:09,619
all replicas are in the same data center
 

101
00:02:09,619 --> 00:02:11,330
all replicas are in the same data center
absolutely it doesn't wouldn't make

102
00:02:11,330 --> 00:02:11,340
absolutely it doesn't wouldn't make
 

103
00:02:11,340 --> 00:02:11,870
absolutely it doesn't wouldn't make
sense

104
00:02:11,870 --> 00:02:11,880
sense
 

105
00:02:11,880 --> 00:02:13,820
sense
the replicas were in even in different

106
00:02:13,820 --> 00:02:13,830
the replicas were in even in different
 

107
00:02:13,830 --> 00:02:15,590
the replicas were in even in different
data centers let alone on East Coast

108
00:02:15,590 --> 00:02:15,600
data centers let alone on East Coast
 

109
00:02:15,600 --> 00:02:18,350
data centers let alone on East Coast
versus West Coast so it's not trying to

110
00:02:18,350 --> 00:02:18,360
versus West Coast so it's not trying to
 

111
00:02:18,360 --> 00:02:20,630
versus West Coast so it's not trying to
solve a problem that spanner is about

112
00:02:20,630 --> 00:02:20,640
solve a problem that spanner is about
 

113
00:02:20,640 --> 00:02:22,010
solve a problem that spanner is about
what happens if an entire data center

114
00:02:22,010 --> 00:02:22,020
what happens if an entire data center
 

115
00:02:22,020 --> 00:02:23,780
what happens if an entire data center
goes down can I so get out my data

116
00:02:23,780 --> 00:02:23,790
goes down can I so get out my data
 

117
00:02:23,790 --> 00:02:25,910
goes down can I so get out my data
really that's does the extent that it

118
00:02:25,910 --> 00:02:25,920
really that's does the extent that it
 

119
00:02:25,920 --> 00:02:27,530
really that's does the extent that it
has fault tolerance is for individual

120
00:02:27,530 --> 00:02:27,540
has fault tolerance is for individual
 

121
00:02:27,540 --> 00:02:30,890
has fault tolerance is for individual
crashes or maybe try to recover after a

122
00:02:30,890 --> 00:02:30,900
crashes or maybe try to recover after a
 

123
00:02:30,900 --> 00:02:33,710
crashes or maybe try to recover after a
whole data center loses power and gets

124
00:02:33,710 --> 00:02:33,720
whole data center loses power and gets
 

125
00:02:33,720 --> 00:02:37,550
whole data center loses power and gets
restored again it uses this RDMA

126
00:02:37,550 --> 00:02:37,560
restored again it uses this RDMA
 

127
00:02:37,560 --> 00:02:39,200
restored again it uses this RDMA
technique which I'll talk about but

128
00:02:39,200 --> 00:02:39,210
technique which I'll talk about but
 

129
00:02:39,210 --> 00:02:41,030
technique which I'll talk about but
already may turns out to seriously

130
00:02:41,030 --> 00:02:41,040
already may turns out to seriously
 

131
00:02:41,040 --> 00:02:43,640
already may turns out to seriously
restrict the design options and because

132
00:02:43,640 --> 00:02:43,650
restrict the design options and because
 

133
00:02:43,650 --> 00:02:46,730
restrict the design options and because
of this farm is forced to use optimistic

134
00:02:46,730 --> 00:02:46,740
of this farm is forced to use optimistic
 

135
00:02:46,740 --> 00:02:49,970
of this farm is forced to use optimistic
concurrency control on the other hand

136
00:02:49,970 --> 00:02:49,980
concurrency control on the other hand
 

137
00:02:49,980 --> 00:02:52,580
concurrency control on the other hand
the performance they get is far far

138
00:02:52,580 --> 00:02:52,590
the performance they get is far far
 

139
00:02:52,590 --> 00:02:56,290
the performance they get is far far
higher than spanner farm can do a

140
00:02:56,290 --> 00:02:56,300
higher than spanner farm can do a
 

141
00:02:56,300 --> 00:02:58,760
higher than spanner farm can do a
transit a simple transaction in 58

142
00:02:58,760 --> 00:02:58,770
transit a simple transaction in 58
 

143
00:02:58,770 --> 00:03:00,890
transit a simple transaction in 58
microseconds and this is from figure 7

144
00:03:00,890 --> 00:03:00,900
microseconds and this is from figure 7
 

145
00:03:00,900 --> 00:03:03,740
microseconds and this is from figure 7
and section 6.3 so this is 58

146
00:03:03,740 --> 00:03:03,750
and section 6.3 so this is 58
 

147
00:03:03,750 --> 00:03:06,770
and section 6.3 so this is 58
microseconds versus to 10 milliseconds

148
00:03:06,770 --> 00:03:06,780
microseconds versus to 10 milliseconds
 

149
00:03:06,780 --> 00:03:10,160
microseconds versus to 10 milliseconds
that the spanner takes is that's about a

150
00:03:10,160 --> 00:03:10,170
that the spanner takes is that's about a
 

151
00:03:10,170 --> 00:03:12,950
that the spanner takes is that's about a
hundred times faster than spanner so

152
00:03:12,950 --> 00:03:12,960
hundred times faster than spanner so
 

153
00:03:12,960 --> 00:03:15,890
hundred times faster than spanner so
that's maybe the main huge differences

154
00:03:15,890 --> 00:03:15,900
that's maybe the main huge differences
 

155
00:03:15,900 --> 00:03:17,720
that's maybe the main huge differences
that farm us how much higher performance

156
00:03:17,720 --> 00:03:17,730
that farm us how much higher performance
 

157
00:03:17,730 --> 00:03:21,380
that farm us how much higher performance
but is not aimed at Geographic

158
00:03:21,380 --> 00:03:21,390
but is not aimed at Geographic
 

159
00:03:21,390 --> 00:03:26,630
but is not aimed at Geographic
replication so this you know farms

160
00:03:26,630 --> 00:03:26,640
replication so this you know farms
 

161
00:03:26,640 --> 00:03:28,820
replication so this you know farms
performance is extremely impressive like

162
00:03:28,820 --> 00:03:28,830
performance is extremely impressive like
 

163
00:03:28,830 --> 00:03:31,780
performance is extremely impressive like
how much faster than anything else

164
00:03:31,780 --> 00:03:31,790
how much faster than anything else
 

165
00:03:31,790 --> 00:03:33,710
how much faster than anything else
another way to look at it is that

166
00:03:33,710 --> 00:03:33,720
another way to look at it is that
 

167
00:03:33,720 --> 00:03:35,360
another way to look at it is that
spanner and farm target different

168
00:03:35,360 --> 00:03:35,370
spanner and farm target different
 

169
00:03:35,370 --> 00:03:37,460
spanner and farm target different
bottlenecks and span are the main

170
00:03:37,460 --> 00:03:37,470
bottlenecks and span are the main
 

171
00:03:37,470 --> 00:03:39,140
bottlenecks and span are the main
bottleneck the people worried about is

172
00:03:39,140 --> 00:03:39,150
bottleneck the people worried about is
 

173
00:03:39,150 --> 00:03:41,420
bottleneck the people worried about is
the speed of light and network speed of

174
00:03:41,420 --> 00:03:41,430
the speed of light and network speed of
 

175
00:03:41,430 --> 00:03:42,890
the speed of light and network speed of
light delays and network leaves between

176
00:03:42,890 --> 00:03:42,900
light delays and network leaves between
 

177
00:03:42,900 --> 00:03:46,550
light delays and network leaves between
data centers whereas in farm the main

178
00:03:46,550 --> 00:03:46,560
data centers whereas in farm the main
 

179
00:03:46,560 --> 00:03:50,120
data centers whereas in farm the main
bottlenecks that the design is worried

180
00:03:50,120 --> 00:03:50,130
bottlenecks that the design is worried
 

181
00:03:50,130 --> 00:03:52,550
bottlenecks that the design is worried
about is is CPU time on the server's

182
00:03:52,550 --> 00:03:52,560
about is is CPU time on the server's
 

183
00:03:52,560 --> 00:03:54,199
about is is CPU time on the server's
because they kind of wished away the

184
00:03:54,199 --> 00:03:54,209
because they kind of wished away the
 

185
00:03:54,209 --> 00:03:55,610
because they kind of wished away the
speed of light and network delays by

186
00:03:55,610 --> 00:03:55,620
speed of light and network delays by
 

187
00:03:55,620 --> 00:03:57,170
speed of light and network delays by
putting all the replicas in the same

188
00:03:57,170 --> 00:03:57,180
putting all the replicas in the same
 

189
00:03:57,180 --> 00:04:01,210
putting all the replicas in the same
data center all right

190
00:04:01,210 --> 00:04:01,220

 

191
00:04:01,220 --> 00:04:03,530

so sort of the background of how this

192
00:04:03,530 --> 00:04:03,540
so sort of the background of how this
 

193
00:04:03,540 --> 00:04:08,449
so sort of the background of how this
fits into the 684 sequence the setup and

194
00:04:08,449 --> 00:04:08,459
fits into the 684 sequence the setup and
 

195
00:04:08,459 --> 00:04:10,070
fits into the 684 sequence the setup and
farm is that you have it's all running

196
00:04:10,070 --> 00:04:10,080
farm is that you have it's all running
 

197
00:04:10,080 --> 00:04:16,030
farm is that you have it's all running
in one datacenter there's a sort of

198
00:04:16,030 --> 00:04:16,040

 

199
00:04:16,040 --> 00:04:18,770

configuration manager this which we've

200
00:04:18,770 --> 00:04:18,780
configuration manager this which we've
 

201
00:04:18,780 --> 00:04:21,110
configuration manager this which we've
seen before and the configuration

202
00:04:21,110 --> 00:04:21,120
seen before and the configuration
 

203
00:04:21,120 --> 00:04:24,200
seen before and the configuration
managers in charge of deciding which rep

204
00:04:24,200 --> 00:04:24,210
managers in charge of deciding which rep
 

205
00:04:24,210 --> 00:04:25,100
managers in charge of deciding which rep
which

206
00:04:25,100 --> 00:04:25,110
which
 

207
00:04:25,110 --> 00:04:26,869
which
servers should be the primary in the

208
00:04:26,869 --> 00:04:26,879
servers should be the primary in the
 

209
00:04:26,879 --> 00:04:30,469
servers should be the primary in the
backup before each shard of data and if

210
00:04:30,469 --> 00:04:30,479
backup before each shard of data and if
 

211
00:04:30,479 --> 00:04:31,550
backup before each shard of data and if
you read carefully you'll see that they

212
00:04:31,550 --> 00:04:31,560
you read carefully you'll see that they
 

213
00:04:31,560 --> 00:04:37,100
you read carefully you'll see that they
use zookeeper in order to help them

214
00:04:37,100 --> 00:04:37,110
use zookeeper in order to help them
 

215
00:04:37,110 --> 00:04:38,510
use zookeeper in order to help them
implement this configuration manager but

216
00:04:38,510 --> 00:04:38,520
implement this configuration manager but
 

217
00:04:38,520 --> 00:04:40,129
implement this configuration manager but
it's not not the focus of the paper at

218
00:04:40,129 --> 00:04:40,139
it's not not the focus of the paper at
 

219
00:04:40,139 --> 00:04:40,399
it's not not the focus of the paper at
all

220
00:04:40,399 --> 00:04:40,409
all
 

221
00:04:40,409 --> 00:04:42,529
all
instead the interesting thing is that

222
00:04:42,529 --> 00:04:42,539
instead the interesting thing is that
 

223
00:04:42,539 --> 00:04:44,659
instead the interesting thing is that
the data is sharded split up by key

224
00:04:44,659 --> 00:04:44,669
the data is sharded split up by key
 

225
00:04:44,669 --> 00:04:47,480
the data is sharded split up by key
across a bunch of primary backup payers

226
00:04:47,480 --> 00:04:47,490
across a bunch of primary backup payers
 

227
00:04:47,490 --> 00:04:50,119
across a bunch of primary backup payers
so I mean one shard goes on you know

228
00:04:50,119 --> 00:04:50,129
so I mean one shard goes on you know
 

229
00:04:50,129 --> 00:04:52,909
so I mean one shard goes on you know
primary one server primary one backup

230
00:04:52,909 --> 00:04:52,919
primary one server primary one backup
 

231
00:04:52,919 --> 00:04:55,909
primary one server primary one backup
one another short one primary to backup

232
00:04:55,909 --> 00:04:55,919
one another short one primary to backup
 

233
00:04:55,919 --> 00:04:59,869
one another short one primary to backup
two and so forth and that means that

234
00:04:59,869 --> 00:04:59,879
two and so forth and that means that
 

235
00:04:59,879 --> 00:05:01,730
two and so forth and that means that
anytime you update data you need to

236
00:05:01,730 --> 00:05:01,740
anytime you update data you need to
 

237
00:05:01,740 --> 00:05:03,860
anytime you update data you need to
update it both on the primary and on the

238
00:05:03,860 --> 00:05:03,870
update it both on the primary and on the
 

239
00:05:03,870 --> 00:05:06,649
update it both on the primary and on the
backup and these are not these primaries

240
00:05:06,649 --> 00:05:06,659
backup and these are not these primaries
 

241
00:05:06,659 --> 00:05:08,240
backup and these are not these primaries
these replicas are not maintained by

242
00:05:08,240 --> 00:05:08,250
these replicas are not maintained by
 

243
00:05:08,250 --> 00:05:11,749
these replicas are not maintained by
PACs or anything like it instead all the

244
00:05:11,749 --> 00:05:11,759
PACs or anything like it instead all the
 

245
00:05:11,759 --> 00:05:14,959
PACs or anything like it instead all the
replicas of the data are updated

246
00:05:14,959 --> 00:05:14,969
replicas of the data are updated
 

247
00:05:14,969 --> 00:05:16,820
replicas of the data are updated
whenever there's a change and if you

248
00:05:16,820 --> 00:05:16,830
whenever there's a change and if you
 

249
00:05:16,830 --> 00:05:18,170
whenever there's a change and if you
read you always have to read from the

250
00:05:18,170 --> 00:05:18,180
read you always have to read from the
 

251
00:05:18,180 --> 00:05:21,110
read you always have to read from the
primary the reason for this replication

252
00:05:21,110 --> 00:05:21,120
primary the reason for this replication
 

253
00:05:21,120 --> 00:05:24,200
primary the reason for this replication
of course is fault tolerance and the

254
00:05:24,200 --> 00:05:24,210
of course is fault tolerance and the
 

255
00:05:24,210 --> 00:05:26,149
of course is fault tolerance and the
kind of fault tolerance they get is that

256
00:05:26,149 --> 00:05:26,159
kind of fault tolerance they get is that
 

257
00:05:26,159 --> 00:05:29,029
kind of fault tolerance they get is that
as long as one replicas of a given shard

258
00:05:29,029 --> 00:05:29,039
as long as one replicas of a given shard
 

259
00:05:29,039 --> 00:05:31,519
as long as one replicas of a given shard
is available then that shard will be

260
00:05:31,519 --> 00:05:31,529
is available then that shard will be
 

261
00:05:31,529 --> 00:05:33,399
is available then that shard will be
available so they only require one

262
00:05:33,399 --> 00:05:33,409
available so they only require one
 

263
00:05:33,409 --> 00:05:37,610
available so they only require one
living replica not a majority and the

264
00:05:37,610 --> 00:05:37,620
living replica not a majority and the
 

265
00:05:37,620 --> 00:05:39,890
living replica not a majority and the
system as a whole if there's say a data

266
00:05:39,890 --> 00:05:39,900
system as a whole if there's say a data
 

267
00:05:39,900 --> 00:05:42,079
system as a whole if there's say a data
center white power failure it can

268
00:05:42,079 --> 00:05:42,089
center white power failure it can
 

269
00:05:42,089 --> 00:05:43,879
center white power failure it can
recover as long as there's at least one

270
00:05:43,879 --> 00:05:43,889
recover as long as there's at least one
 

271
00:05:43,889 --> 00:05:47,079
recover as long as there's at least one
replicas of every shard in the system

272
00:05:47,079 --> 00:05:47,089
replicas of every shard in the system
 

273
00:05:47,089 --> 00:05:49,550
replicas of every shard in the system
another way of putting that is if you

274
00:05:49,550 --> 00:05:49,560
another way of putting that is if you
 

275
00:05:49,560 --> 00:05:52,189
another way of putting that is if you
they have F plus one replicas then they

276
00:05:52,189 --> 00:05:52,199
they have F plus one replicas then they
 

277
00:05:52,199 --> 00:05:54,320
they have F plus one replicas then they
can tolerate up to F failures for that

278
00:05:54,320 --> 00:05:54,330
can tolerate up to F failures for that
 

279
00:05:54,330 --> 00:05:58,219
can tolerate up to F failures for that
shard in addition to the primary backup

280
00:05:58,219 --> 00:05:58,229
shard in addition to the primary backup
 

281
00:05:58,229 --> 00:06:00,850
shard in addition to the primary backup
copies of each sort of data there's

282
00:06:00,850 --> 00:06:00,860
copies of each sort of data there's
 

283
00:06:00,860 --> 00:06:04,760
copies of each sort of data there's
transaction code that runs it's maybe

284
00:06:04,760 --> 00:06:04,770
transaction code that runs it's maybe
 

285
00:06:04,770 --> 00:06:06,469
transaction code that runs it's maybe
most convenient to think of the

286
00:06:06,469 --> 00:06:06,479
most convenient to think of the
 

287
00:06:06,479 --> 00:06:07,939
most convenient to think of the
transaction code is running as separate

288
00:06:07,939 --> 00:06:07,949
transaction code is running as separate
 

289
00:06:07,949 --> 00:06:11,779
transaction code is running as separate
clients in fact they run the transaction

290
00:06:11,779 --> 00:06:11,789
clients in fact they run the transaction
 

291
00:06:11,789 --> 00:06:13,369
clients in fact they run the transaction
code in their experiments on the same

292
00:06:13,369 --> 00:06:13,379
code in their experiments on the same
 

293
00:06:13,379 --> 00:06:16,550
code in their experiments on the same
machines as the actual farm storage

294
00:06:16,550 --> 00:06:16,560
machines as the actual farm storage
 

295
00:06:16,560 --> 00:06:21,170
machines as the actual farm storage
servers but I'll mostly think of them as

296
00:06:21,170 --> 00:06:21,180
servers but I'll mostly think of them as
 

297
00:06:21,180 --> 00:06:24,260
servers but I'll mostly think of them as
as being a separate set of clients and

298
00:06:24,260 --> 00:06:24,270
as being a separate set of clients and
 

299
00:06:24,270 --> 00:06:27,110
as being a separate set of clients and
the clients are running transactions and

300
00:06:27,110 --> 00:06:27,120
the clients are running transactions and
 

301
00:06:27,120 --> 00:06:29,950
the clients are running transactions and
the transactions need to read and write

302
00:06:29,950 --> 00:06:29,960
the transactions need to read and write
 

303
00:06:29,960 --> 00:06:34,110
the transactions need to read and write
data objects that are stored in the

304
00:06:34,110 --> 00:06:34,120
data objects that are stored in the
 

305
00:06:34,120 --> 00:06:38,010
data objects that are stored in the
in the sharded servers in addition these

306
00:06:38,010 --> 00:06:38,020
in the sharded servers in addition these
 

307
00:06:38,020 --> 00:06:40,140
in the sharded servers in addition these
transaction these clients each client

308
00:06:40,140 --> 00:06:40,150
transaction these clients each client
 

309
00:06:40,150 --> 00:06:42,839
transaction these clients each client
not only runs the transactions but also

310
00:06:42,839 --> 00:06:42,849
not only runs the transactions but also
 

311
00:06:42,849 --> 00:06:45,869
not only runs the transactions but also
acts as that transaction coordinator for

312
00:06:45,869 --> 00:06:45,879
acts as that transaction coordinator for
 

313
00:06:45,879 --> 00:06:48,320
acts as that transaction coordinator for
two-phase commit

314
00:06:48,320 --> 00:06:48,330
two-phase commit
 

315
00:06:48,330 --> 00:06:52,049
two-phase commit
okay so it's the basic set up the way

316
00:06:52,049 --> 00:06:52,059
okay so it's the basic set up the way
 

317
00:06:52,059 --> 00:06:53,579
okay so it's the basic set up the way
they get performance because this really

318
00:06:53,579 --> 00:06:53,589
they get performance because this really
 

319
00:06:53,589 --> 00:06:55,409
they get performance because this really
this is a paper all about how you can

320
00:06:55,409 --> 00:06:55,419
this is a paper all about how you can
 

321
00:06:55,419 --> 00:06:57,659
this is a paper all about how you can
get high performance and still have

322
00:06:57,659 --> 00:06:57,669
get high performance and still have
 

323
00:06:57,669 --> 00:06:59,909
get high performance and still have
transactions one way they get high

324
00:06:59,909 --> 00:06:59,919
transactions one way they get high
 

325
00:06:59,919 --> 00:07:04,140
transactions one way they get high
performances with sharding these are the

326
00:07:04,140 --> 00:07:04,150
performances with sharding these are the
 

327
00:07:04,150 --> 00:07:09,179
performances with sharding these are the
ingredients in a sense the main way is

328
00:07:09,179 --> 00:07:09,189
ingredients in a sense the main way is
 

329
00:07:09,189 --> 00:07:12,209
ingredients in a sense the main way is
through sharding in experiments they

330
00:07:12,209 --> 00:07:12,219
through sharding in experiments they
 

331
00:07:12,219 --> 00:07:14,369
through sharding in experiments they
shard their data over 90 ways for 90

332
00:07:14,369 --> 00:07:14,379
shard their data over 90 ways for 90
 

333
00:07:14,379 --> 00:07:17,040
shard their data over 90 ways for 90
servers or maybe it's 45 ways and not

334
00:07:17,040 --> 00:07:17,050
servers or maybe it's 45 ways and not
 

335
00:07:17,050 --> 00:07:19,649
servers or maybe it's 45 ways and not
just if as long as the operations and

336
00:07:19,649 --> 00:07:19,659
just if as long as the operations and
 

337
00:07:19,659 --> 00:07:21,269
just if as long as the operations and
different shards are more or less

338
00:07:21,269 --> 00:07:21,279
different shards are more or less
 

339
00:07:21,279 --> 00:07:23,429
different shards are more or less
independent of each other that just gets

340
00:07:23,429 --> 00:07:23,439
independent of each other that just gets
 

341
00:07:23,439 --> 00:07:25,889
independent of each other that just gets
you an automatic 90 times speed up

342
00:07:25,889 --> 00:07:25,899
you an automatic 90 times speed up
 

343
00:07:25,899 --> 00:07:27,510
you an automatic 90 times speed up
because you can run whatever it is

344
00:07:27,510 --> 00:07:27,520
because you can run whatever it is
 

345
00:07:27,520 --> 00:07:30,689
because you can run whatever it is
you're running in parallel on 90 syrups

346
00:07:30,689 --> 00:07:30,699
you're running in parallel on 90 syrups
 

347
00:07:30,699 --> 00:07:34,189
you're running in parallel on 90 syrups
this huge went from shorter sharding um

348
00:07:34,189 --> 00:07:34,199
this huge went from shorter sharding um
 

349
00:07:34,199 --> 00:07:36,510
this huge went from shorter sharding um
another trick they play in order to get

350
00:07:36,510 --> 00:07:36,520
another trick they play in order to get
 

351
00:07:36,520 --> 00:07:38,159
another trick they play in order to get
good performance as the data all has to

352
00:07:38,159 --> 00:07:38,169
good performance as the data all has to
 

353
00:07:38,169 --> 00:07:41,909
good performance as the data all has to
fit in the RAM of the servers they don't

354
00:07:41,909 --> 00:07:41,919
fit in the RAM of the servers they don't
 

355
00:07:41,919 --> 00:07:44,339
fit in the RAM of the servers they don't
really store the data on disk

356
00:07:44,339 --> 00:07:44,349
really store the data on disk
 

357
00:07:44,349 --> 00:07:46,079
really store the data on disk
it all has to fit in RAM and that means

358
00:07:46,079 --> 00:07:46,089
it all has to fit in RAM and that means
 

359
00:07:46,089 --> 00:07:46,920
it all has to fit in RAM and that means
of course you can get out of pretty

360
00:07:46,920 --> 00:07:46,930
of course you can get out of pretty
 

361
00:07:46,930 --> 00:07:50,610
of course you can get out of pretty
quickly another way that they get high

362
00:07:50,610 --> 00:07:50,620
quickly another way that they get high
 

363
00:07:50,620 --> 00:07:53,279
quickly another way that they get high
performance is they need to tolerate

364
00:07:53,279 --> 00:07:53,289
performance is they need to tolerate
 

365
00:07:53,289 --> 00:07:56,189
performance is they need to tolerate
power failures which means that they

366
00:07:56,189 --> 00:07:56,199
power failures which means that they
 

367
00:07:56,199 --> 00:07:57,779
power failures which means that they
can't just be using RAM because they

368
00:07:57,779 --> 00:07:57,789
can't just be using RAM because they
 

369
00:07:57,789 --> 00:07:59,489
can't just be using RAM because they
need to recover the data after a power

370
00:07:59,489 --> 00:07:59,499
need to recover the data after a power
 

371
00:07:59,499 --> 00:08:02,100
need to recover the data after a power
failure and RAM loses contents on a

372
00:08:02,100 --> 00:08:02,110
failure and RAM loses contents on a
 

373
00:08:02,110 --> 00:08:04,579
failure and RAM loses contents on a
power failure so they have a clever

374
00:08:04,579 --> 00:08:04,589
power failure so they have a clever
 

375
00:08:04,589 --> 00:08:09,179
power failure so they have a clever
non-volatile Ram scheme for having the

376
00:08:09,179 --> 00:08:09,189
non-volatile Ram scheme for having the
 

377
00:08:09,189 --> 00:08:11,010
non-volatile Ram scheme for having the
contents of RAM the data survived power

378
00:08:11,010 --> 00:08:11,020
contents of RAM the data survived power
 

379
00:08:11,020 --> 00:08:14,010
contents of RAM the data survived power
failures this is in contrast to storing

380
00:08:14,010 --> 00:08:14,020
failures this is in contrast to storing
 

381
00:08:14,020 --> 00:08:16,350
failures this is in contrast to storing
the data persistently on disk i'm is

382
00:08:16,350 --> 00:08:16,360
the data persistently on disk i'm is
 

383
00:08:16,360 --> 00:08:20,070
the data persistently on disk i'm is
much faster than disk um another trick

384
00:08:20,070 --> 00:08:20,080
much faster than disk um another trick
 

385
00:08:20,080 --> 00:08:22,170
much faster than disk um another trick
they play is they use this RDMA

386
00:08:22,170 --> 00:08:22,180
they play is they use this RDMA
 

387
00:08:22,180 --> 00:08:25,290
they play is they use this RDMA
technique which essentially clever

388
00:08:25,290 --> 00:08:25,300
technique which essentially clever
 

389
00:08:25,300 --> 00:08:31,279
technique which essentially clever
network interface cards that allow that

390
00:08:31,279 --> 00:08:31,289
network interface cards that allow that
 

391
00:08:31,289 --> 00:08:34,469
network interface cards that allow that
accept packets that instruct that then

392
00:08:34,469 --> 00:08:34,479
accept packets that instruct that then
 

393
00:08:34,479 --> 00:08:35,909
accept packets that instruct that then
that we're interface card to directly

394
00:08:35,909 --> 00:08:35,919
that we're interface card to directly
 

395
00:08:35,919 --> 00:08:37,259
that we're interface card to directly
read and write the memory of the server

396
00:08:37,259 --> 00:08:37,269
read and write the memory of the server
 

397
00:08:37,269 --> 00:08:42,689
read and write the memory of the server
without interrupting the server I know

398
00:08:42,689 --> 00:08:42,699
without interrupting the server I know
 

399
00:08:42,699 --> 00:08:45,300
without interrupting the server I know
that trick they play is what you often

400
00:08:45,300 --> 00:08:45,310
that trick they play is what you often
 

401
00:08:45,310 --> 00:08:48,670
that trick they play is what you often
call kernel bypass

402
00:08:48,670 --> 00:08:48,680

 

403
00:08:48,680 --> 00:08:54,250

which means that the application level

404
00:08:54,250 --> 00:08:54,260
which means that the application level
 

405
00:08:54,260 --> 00:08:58,780
which means that the application level
code can directly access the network

406
00:08:58,780 --> 00:08:58,790
code can directly access the network
 

407
00:08:58,790 --> 00:09:00,160
code can directly access the network
interface card without getting the

408
00:09:00,160 --> 00:09:00,170
interface card without getting the
 

409
00:09:00,170 --> 00:09:02,530
interface card without getting the
kernel involved okay so these are all

410
00:09:02,530 --> 00:09:02,540
kernel involved okay so these are all
 

411
00:09:02,540 --> 00:09:05,470
kernel involved okay so these are all
the sort of clever tricks we're looking

412
00:09:05,470 --> 00:09:05,480
the sort of clever tricks we're looking
 

413
00:09:05,480 --> 00:09:07,510
the sort of clever tricks we're looking
at out pour it that they used to get

414
00:09:07,510 --> 00:09:07,520
at out pour it that they used to get
 

415
00:09:07,520 --> 00:09:09,850
at out pour it that they used to get
high performance and I'll talk about

416
00:09:09,850 --> 00:09:09,860
high performance and I'll talk about
 

417
00:09:09,860 --> 00:09:11,260
high performance and I'll talk about
we've already talked about sharding a

418
00:09:11,260 --> 00:09:11,270
we've already talked about sharding a
 

419
00:09:11,270 --> 00:09:13,720
we've already talked about sharding a
lot but I'll talk about the rest in this

420
00:09:13,720 --> 00:09:13,730
lot but I'll talk about the rest in this
 

421
00:09:13,730 --> 00:09:15,420
lot but I'll talk about the rest in this
lecture

422
00:09:15,420 --> 00:09:15,430
lecture
 

423
00:09:15,430 --> 00:09:19,210
lecture
okay so first I'll talk about

424
00:09:19,210 --> 00:09:19,220
okay so first I'll talk about
 

425
00:09:19,220 --> 00:09:21,550
okay so first I'll talk about
non-volatile Ram I mean this is really a

426
00:09:21,550 --> 00:09:21,560
non-volatile Ram I mean this is really a
 

427
00:09:21,560 --> 00:09:27,190
non-volatile Ram I mean this is really a
topic that doesn't doesn't really affect

428
00:09:27,190 --> 00:09:27,200
topic that doesn't doesn't really affect
 

429
00:09:27,200 --> 00:09:31,300
topic that doesn't doesn't really affect
the rest of the design directly as I

430
00:09:31,300 --> 00:09:31,310
the rest of the design directly as I
 

431
00:09:31,310 --> 00:09:34,390
the rest of the design directly as I
said all the data and for farm is stored

432
00:09:34,390 --> 00:09:34,400
said all the data and for farm is stored
 

433
00:09:34,400 --> 00:09:37,180
said all the data and for farm is stored
in RAM when you update it when a client

434
00:09:37,180 --> 00:09:37,190
in RAM when you update it when a client
 

435
00:09:37,190 --> 00:09:38,590
in RAM when you update it when a client
transaction updates a piece of data what

436
00:09:38,590 --> 00:09:38,600
transaction updates a piece of data what
 

437
00:09:38,600 --> 00:09:39,790
transaction updates a piece of data what
that really means is it reaches out to

438
00:09:39,790 --> 00:09:39,800
that really means is it reaches out to
 

439
00:09:39,800 --> 00:09:41,560
that really means is it reaches out to
the relevant servers that store the data

440
00:09:41,560 --> 00:09:41,570
the relevant servers that store the data
 

441
00:09:41,570 --> 00:09:43,750
the relevant servers that store the data
and causes those servers to modify the

442
00:09:43,750 --> 00:09:43,760
and causes those servers to modify the
 

443
00:09:43,760 --> 00:09:46,690
and causes those servers to modify the
whatever object is the transaction is

444
00:09:46,690 --> 00:09:46,700
whatever object is the transaction is
 

445
00:09:46,700 --> 00:09:49,360
whatever object is the transaction is
modifying to object modify it right in

446
00:09:49,360 --> 00:09:49,370
modifying to object modify it right in
 

447
00:09:49,370 --> 00:09:51,760
modifying to object modify it right in
RAM and that's as far as the writes get

448
00:09:51,760 --> 00:09:51,770
RAM and that's as far as the writes get
 

449
00:09:51,770 --> 00:09:53,530
RAM and that's as far as the writes get
they don't go to disk and this is you

450
00:09:53,530 --> 00:09:53,540
they don't go to disk and this is you
 

451
00:09:53,540 --> 00:09:54,610
they don't go to disk and this is you
know contrast to your raft

452
00:09:54,610 --> 00:09:54,620
know contrast to your raft
 

453
00:09:54,620 --> 00:09:56,949
know contrast to your raft
implementations for example which spent

454
00:09:56,949 --> 00:09:56,959
implementations for example which spent
 

455
00:09:56,959 --> 00:09:59,560
implementations for example which spent
a lot of time persisting data to disk

456
00:09:59,560 --> 00:09:59,570
a lot of time persisting data to disk
 

457
00:09:59,570 --> 00:10:04,300
a lot of time persisting data to disk
there's no persisting and in farm this

458
00:10:04,300 --> 00:10:04,310
there's no persisting and in farm this
 

459
00:10:04,310 --> 00:10:06,579
there's no persisting and in farm this
is a big wind writing stuff in RAM write

460
00:10:06,579 --> 00:10:06,589
is a big wind writing stuff in RAM write
 

461
00:10:06,589 --> 00:10:07,870
is a big wind writing stuff in RAM write
a write to ram takes about 200

462
00:10:07,870 --> 00:10:07,880
a write to ram takes about 200
 

463
00:10:07,880 --> 00:10:09,519
a write to ram takes about 200
nanoseconds whereas a raid even to a

464
00:10:09,519 --> 00:10:09,529
nanoseconds whereas a raid even to a
 

465
00:10:09,529 --> 00:10:11,920
nanoseconds whereas a raid even to a
solid state drive which is pretty fast a

466
00:10:11,920 --> 00:10:11,930
solid state drive which is pretty fast a
 

467
00:10:11,930 --> 00:10:14,470
solid state drive which is pretty fast a
right to a stall seek drive takes about

468
00:10:14,470 --> 00:10:14,480
right to a stall seek drive takes about
 

469
00:10:14,480 --> 00:10:17,320
right to a stall seek drive takes about
a hundred microseconds and a write to

470
00:10:17,320 --> 00:10:17,330
a hundred microseconds and a write to
 

471
00:10:17,330 --> 00:10:18,430
a hundred microseconds and a write to
our hard drive takes about ten

472
00:10:18,430 --> 00:10:18,440
our hard drive takes about ten
 

473
00:10:18,440 --> 00:10:21,070
our hard drive takes about ten
milliseconds so being able to write to

474
00:10:21,070 --> 00:10:21,080
milliseconds so being able to write to
 

475
00:10:21,080 --> 00:10:24,310
milliseconds so being able to write to
ram is worth many many orders of

476
00:10:24,310 --> 00:10:24,320
ram is worth many many orders of
 

477
00:10:24,320 --> 00:10:26,260
ram is worth many many orders of
magnitude and speed for transactions

478
00:10:26,260 --> 00:10:26,270
magnitude and speed for transactions
 

479
00:10:26,270 --> 00:10:27,579
magnitude and speed for transactions
that modify things but of course iran

480
00:10:27,579 --> 00:10:27,589
that modify things but of course iran
 

481
00:10:27,589 --> 00:10:30,760
that modify things but of course iran
loses its content and a power failure so

482
00:10:30,760 --> 00:10:30,770
loses its content and a power failure so
 

483
00:10:30,770 --> 00:10:34,170
loses its content and a power failure so
it's not persistent by itself as a side

484
00:10:34,170 --> 00:10:34,180
it's not persistent by itself as a side
 

485
00:10:34,180 --> 00:10:37,980
it's not persistent by itself as a side
you might think that writing

486
00:10:37,980 --> 00:10:37,990
you might think that writing
 

487
00:10:37,990 --> 00:10:41,050
you might think that writing
modifications to the RAM of multiple

488
00:10:41,050 --> 00:10:41,060
modifications to the RAM of multiple
 

489
00:10:41,060 --> 00:10:43,600
modifications to the RAM of multiple
servers that if you have replica servers

490
00:10:43,600 --> 00:10:43,610
servers that if you have replica servers
 

491
00:10:43,610 --> 00:10:45,250
servers that if you have replica servers
and you update all the replicas that

492
00:10:45,250 --> 00:10:45,260
and you update all the replicas that
 

493
00:10:45,260 --> 00:10:48,070
and you update all the replicas that
that might be persistent enough and so

494
00:10:48,070 --> 00:10:48,080
that might be persistent enough and so
 

495
00:10:48,080 --> 00:10:50,170
that might be persistent enough and so
after all if you have F 1 F +1 replicas

496
00:10:50,170 --> 00:10:50,180
after all if you have F 1 F +1 replicas
 

497
00:10:50,180 --> 00:10:53,140
after all if you have F 1 F +1 replicas
you can tolerate up to F failures and

498
00:10:53,140 --> 00:10:53,150
you can tolerate up to F failures and
 

499
00:10:53,150 --> 00:10:55,510
you can tolerate up to F failures and
the reason why just simply writing to

500
00:10:55,510 --> 00:10:55,520
the reason why just simply writing to
 

501
00:10:55,520 --> 00:10:57,340
the reason why just simply writing to
Ram on multiple servers is not good

502
00:10:57,340 --> 00:10:57,350
Ram on multiple servers is not good
 

503
00:10:57,350 --> 00:10:59,980
Ram on multiple servers is not good
enough is that a site-wide power failure

504
00:10:59,980 --> 00:10:59,990
enough is that a site-wide power failure
 

505
00:10:59,990 --> 00:11:00,860
enough is that a site-wide power failure
will destroy

506
00:11:00,860 --> 00:11:00,870
will destroy
 

507
00:11:00,870 --> 00:11:06,140
will destroy
all of your servers and thus violating

508
00:11:06,140 --> 00:11:06,150
all of your servers and thus violating
 

509
00:11:06,150 --> 00:11:09,019
all of your servers and thus violating
the assumption that the failures are in

510
00:11:09,019 --> 00:11:09,029
the assumption that the failures are in
 

511
00:11:09,029 --> 00:11:11,210
the assumption that the failures are in
different servers are independent so we

512
00:11:11,210 --> 00:11:11,220
different servers are independent so we
 

513
00:11:11,220 --> 00:11:12,800
different servers are independent so we
need a scheme that it's gonna work even

514
00:11:12,800 --> 00:11:12,810
need a scheme that it's gonna work even
 

515
00:11:12,810 --> 00:11:16,760
need a scheme that it's gonna work even
if power fails to the entire data center

516
00:11:16,760 --> 00:11:16,770
if power fails to the entire data center
 

517
00:11:16,770 --> 00:11:24,200
if power fails to the entire data center
so what what forum does is it it puts a

518
00:11:24,200 --> 00:11:24,210
so what what forum does is it it puts a
 

519
00:11:24,210 --> 00:11:26,480
so what what forum does is it it puts a
battery a big battery in every rack and

520
00:11:26,480 --> 00:11:26,490
battery a big battery in every rack and
 

521
00:11:26,490 --> 00:11:28,220
battery a big battery in every rack and
runs the power supply system through the

522
00:11:28,220 --> 00:11:28,230
runs the power supply system through the
 

523
00:11:28,230 --> 00:11:31,040
runs the power supply system through the
batteries so the batteries automatically

524
00:11:31,040 --> 00:11:31,050
batteries so the batteries automatically
 

525
00:11:31,050 --> 00:11:32,960
batteries so the batteries automatically
take over if there's a power failure and

526
00:11:32,960 --> 00:11:32,970
take over if there's a power failure and
 

527
00:11:32,970 --> 00:11:34,880
take over if there's a power failure and
keep all their machines running at least

528
00:11:34,880 --> 00:11:34,890
keep all their machines running at least
 

529
00:11:34,890 --> 00:11:37,820
keep all their machines running at least
until the battery fails but of course

530
00:11:37,820 --> 00:11:37,830
until the battery fails but of course
 

531
00:11:37,830 --> 00:11:39,620
until the battery fails but of course
you know the battery is not very big it

532
00:11:39,620 --> 00:11:39,630
you know the battery is not very big it
 

533
00:11:39,630 --> 00:11:41,480
you know the battery is not very big it
may only be able to run their their

534
00:11:41,480 --> 00:11:41,490
may only be able to run their their
 

535
00:11:41,490 --> 00:11:44,090
may only be able to run their their
machines for say 10 minutes or something

536
00:11:44,090 --> 00:11:44,100
machines for say 10 minutes or something
 

537
00:11:44,100 --> 00:11:45,890
machines for say 10 minutes or something
so the battery by itself is not enough

538
00:11:45,890 --> 00:11:45,900
so the battery by itself is not enough
 

539
00:11:45,900 --> 00:11:47,750
so the battery by itself is not enough
to make this the system be able to

540
00:11:47,750 --> 00:11:47,760
to make this the system be able to
 

541
00:11:47,760 --> 00:11:50,750
to make this the system be able to
withstand a lengthy power failure so

542
00:11:50,750 --> 00:11:50,760
withstand a lengthy power failure so
 

543
00:11:50,760 --> 00:11:53,570
withstand a lengthy power failure so
instead the battery system when it sees

544
00:11:53,570 --> 00:11:53,580
instead the battery system when it sees
 

545
00:11:53,580 --> 00:11:56,450
instead the battery system when it sees
that the main power is failed the

546
00:11:56,450 --> 00:11:56,460
that the main power is failed the
 

547
00:11:56,460 --> 00:11:57,620
that the main power is failed the
battery system while it keeps the

548
00:11:57,620 --> 00:11:57,630
battery system while it keeps the
 

549
00:11:57,630 --> 00:12:00,320
battery system while it keeps the
server's Marling also alerts the

550
00:12:00,320 --> 00:12:00,330
server's Marling also alerts the
 

551
00:12:00,330 --> 00:12:02,630
server's Marling also alerts the
server's all the servers and with some

552
00:12:02,630 --> 00:12:02,640
server's all the servers and with some
 

553
00:12:02,640 --> 00:12:04,490
server's all the servers and with some
kind of interrupt or message telling

554
00:12:04,490 --> 00:12:04,500
kind of interrupt or message telling
 

555
00:12:04,500 --> 00:12:06,470
kind of interrupt or message telling
them look the powers just failed you

556
00:12:06,470 --> 00:12:06,480
them look the powers just failed you
 

557
00:12:06,480 --> 00:12:09,010
them look the powers just failed you
know you only got 10 minutes left before

558
00:12:09,010 --> 00:12:09,020
know you only got 10 minutes left before
 

559
00:12:09,020 --> 00:12:12,140
know you only got 10 minutes left before
the batteries fail also so at that point

560
00:12:12,140 --> 00:12:12,150
the batteries fail also so at that point
 

561
00:12:12,150 --> 00:12:16,160
the batteries fail also so at that point
the software on farms servers copies all

562
00:12:16,160 --> 00:12:16,170
the software on farms servers copies all
 

563
00:12:16,170 --> 00:12:18,560
the software on farms servers copies all
of rain active stops all processing it

564
00:12:18,560 --> 00:12:18,570
of rain active stops all processing it
 

565
00:12:18,570 --> 00:12:21,620
of rain active stops all processing it
for farm first and then copies each

566
00:12:21,620 --> 00:12:21,630
for farm first and then copies each
 

567
00:12:21,630 --> 00:12:23,810
for farm first and then copies each
server copies all of its RAM to a

568
00:12:23,810 --> 00:12:23,820
server copies all of its RAM to a
 

569
00:12:23,820 --> 00:12:25,640
server copies all of its RAM to a
solid-state drive attached to that

570
00:12:25,640 --> 00:12:25,650
solid-state drive attached to that
 

571
00:12:25,650 --> 00:12:27,920
solid-state drive attached to that
server I'm what wished could take a

572
00:12:27,920 --> 00:12:27,930
server I'm what wished could take a
 

573
00:12:27,930 --> 00:12:30,079
server I'm what wished could take a
couple minutes and once all the RAM is

574
00:12:30,079 --> 00:12:30,089
couple minutes and once all the RAM is
 

575
00:12:30,089 --> 00:12:32,090
couple minutes and once all the RAM is
copied to the solid-state drive then the

576
00:12:32,090 --> 00:12:32,100
copied to the solid-state drive then the
 

577
00:12:32,100 --> 00:12:33,590
copied to the solid-state drive then the
machine shuts itself down and turns

578
00:12:33,590 --> 00:12:33,600
machine shuts itself down and turns
 

579
00:12:33,600 --> 00:12:37,400
machine shuts itself down and turns
itself off so if all goes well there's a

580
00:12:37,400 --> 00:12:37,410
itself off so if all goes well there's a
 

581
00:12:37,410 --> 00:12:39,860
itself off so if all goes well there's a
site-wide power failure all the machines

582
00:12:39,860 --> 00:12:39,870
site-wide power failure all the machines
 

583
00:12:39,870 --> 00:12:43,490
site-wide power failure all the machines
save their RAM to disk when the power

584
00:12:43,490 --> 00:12:43,500
save their RAM to disk when the power
 

585
00:12:43,500 --> 00:12:45,170
save their RAM to disk when the power
comes back up in the datacenter all the

586
00:12:45,170 --> 00:12:45,180
comes back up in the datacenter all the
 

587
00:12:45,180 --> 00:12:49,150
comes back up in the datacenter all the
machines will when they reboot will read

588
00:12:49,150 --> 00:12:49,160
machines will when they reboot will read
 

589
00:12:49,160 --> 00:12:51,530
machines will when they reboot will read
the memory image that was saved on disk

590
00:12:51,530 --> 00:12:51,540
the memory image that was saved on disk
 

591
00:12:51,540 --> 00:12:54,560
the memory image that was saved on disk
restored into RAM and but there's some

592
00:12:54,560 --> 00:12:54,570
restored into RAM and but there's some
 

593
00:12:54,570 --> 00:12:57,410
restored into RAM and but there's some
recovery that has to go on but basically

594
00:12:57,410 --> 00:12:57,420
recovery that has to go on but basically
 

595
00:12:57,420 --> 00:12:58,910
recovery that has to go on but basically
they won't have lost any of their

596
00:12:58,910 --> 00:12:58,920
they won't have lost any of their
 

597
00:12:58,920 --> 00:13:00,560
they won't have lost any of their
persistent state due to the power

598
00:13:00,560 --> 00:13:00,570
persistent state due to the power
 

599
00:13:00,570 --> 00:13:03,710
persistent state due to the power
failure and so what that really means is

600
00:13:03,710 --> 00:13:03,720
failure and so what that really means is
 

601
00:13:03,720 --> 00:13:07,300
failure and so what that really means is
that the farm is using conventional Ram

602
00:13:07,300 --> 00:13:07,310
that the farm is using conventional Ram
 

603
00:13:07,310 --> 00:13:10,460
that the farm is using conventional Ram
but it's essentially made the RAM

604
00:13:10,460 --> 00:13:10,470
but it's essentially made the RAM
 

605
00:13:10,470 --> 00:13:13,190
but it's essentially made the RAM
non-volatile being able to survive power

606
00:13:13,190 --> 00:13:13,200
non-volatile being able to survive power
 

607
00:13:13,200 --> 00:13:14,329
non-volatile being able to survive power
failures with the

608
00:13:14,329 --> 00:13:14,339
failures with the
 

609
00:13:14,339 --> 00:13:17,329
failures with the
this trick of using a battery having a

610
00:13:17,329 --> 00:13:17,339
this trick of using a battery having a
 

611
00:13:17,339 --> 00:13:18,769
this trick of using a battery having a
battery alert the server having the

612
00:13:18,769 --> 00:13:18,779
battery alert the server having the
 

613
00:13:18,779 --> 00:13:21,650
battery alert the server having the
server store the RAM content solid-state

614
00:13:21,650 --> 00:13:21,660
server store the RAM content solid-state
 

615
00:13:21,660 --> 00:13:26,150
server store the RAM content solid-state
drives any questions about the nvram

616
00:13:26,150 --> 00:13:26,160
drives any questions about the nvram
 

617
00:13:26,160 --> 00:13:33,499
drives any questions about the nvram
scheme alright this is a is a useful

618
00:13:33,499 --> 00:13:33,509
scheme alright this is a is a useful
 

619
00:13:33,509 --> 00:13:37,910
scheme alright this is a is a useful
trick but it is worthwhile keeping mind

620
00:13:37,910 --> 00:13:37,920
trick but it is worthwhile keeping mind
 

621
00:13:37,920 --> 00:13:40,549
trick but it is worthwhile keeping mind
that it really only helps if there's

622
00:13:40,549 --> 00:13:40,559
that it really only helps if there's
 

623
00:13:40,559 --> 00:13:44,600
that it really only helps if there's
power failures that is if the you know

624
00:13:44,600 --> 00:13:44,610
power failures that is if the you know
 

625
00:13:44,610 --> 00:13:46,489
power failures that is if the you know
the whole sequence of events only it

626
00:13:46,489 --> 00:13:46,499
the whole sequence of events only it
 

627
00:13:46,499 --> 00:13:47,720
the whole sequence of events only it
gets set in train when the battery

628
00:13:47,720 --> 00:13:47,730
gets set in train when the battery
 

629
00:13:47,730 --> 00:13:50,629
gets set in train when the battery
notices that the main power is failed if

630
00:13:50,629 --> 00:13:50,639
notices that the main power is failed if
 

631
00:13:50,639 --> 00:13:51,710
notices that the main power is failed if
there's some other reason

632
00:13:51,710 --> 00:13:51,720
there's some other reason
 

633
00:13:51,720 --> 00:13:53,739
there's some other reason
causing the server to fail like

634
00:13:53,739 --> 00:13:53,749
causing the server to fail like
 

635
00:13:53,749 --> 00:13:55,610
causing the server to fail like
something goes wrong with the hardware

636
00:13:55,610 --> 00:13:55,620
something goes wrong with the hardware
 

637
00:13:55,620 --> 00:13:57,110
something goes wrong with the hardware
or there's a bug in the software that

638
00:13:57,110 --> 00:13:57,120
or there's a bug in the software that
 

639
00:13:57,120 --> 00:14:00,590
or there's a bug in the software that
causes a crash those crashes the

640
00:14:00,590 --> 00:14:00,600
causes a crash those crashes the
 

641
00:14:00,600 --> 00:14:02,660
causes a crash those crashes the
non-volatile Ram system is just nothing

642
00:14:02,660 --> 00:14:02,670
non-volatile Ram system is just nothing
 

643
00:14:02,670 --> 00:14:04,220
non-volatile Ram system is just nothing
to do with those crashes those crashes

644
00:14:04,220 --> 00:14:04,230
to do with those crashes those crashes
 

645
00:14:04,230 --> 00:14:06,799
to do with those crashes those crashes
will cause the machine to reboot and

646
00:14:06,799 --> 00:14:06,809
will cause the machine to reboot and
 

647
00:14:06,809 --> 00:14:08,960
will cause the machine to reboot and
lose the contents of its RAM and it

648
00:14:08,960 --> 00:14:08,970
lose the contents of its RAM and it
 

649
00:14:08,970 --> 00:14:10,460
lose the contents of its RAM and it
won't be able to recover them so this

650
00:14:10,460 --> 00:14:10,470
won't be able to recover them so this
 

651
00:14:10,470 --> 00:14:13,999
won't be able to recover them so this
NVRAM scheme is good for power failures

652
00:14:13,999 --> 00:14:14,009
NVRAM scheme is good for power failures
 

653
00:14:14,009 --> 00:14:15,650
NVRAM scheme is good for power failures
but not other crashes and so that's why

654
00:14:15,650 --> 00:14:15,660
but not other crashes and so that's why
 

655
00:14:15,660 --> 00:14:19,309
but not other crashes and so that's why
in addition to the NVRAM farm also has

656
00:14:19,309 --> 00:14:19,319
in addition to the NVRAM farm also has
 

657
00:14:19,319 --> 00:14:21,710
in addition to the NVRAM farm also has
multiple copies multiple replicas of

658
00:14:21,710 --> 00:14:21,720
multiple copies multiple replicas of
 

659
00:14:21,720 --> 00:14:26,509
multiple copies multiple replicas of
each shard all right so this NVRAM

660
00:14:26,509 --> 00:14:26,519
each shard all right so this NVRAM
 

661
00:14:26,519 --> 00:14:28,720
each shard all right so this NVRAM
scheme essentially eliminates

662
00:14:28,720 --> 00:14:28,730
scheme essentially eliminates
 

663
00:14:28,730 --> 00:14:32,480
scheme essentially eliminates
persistence rates as a bottleneck in the

664
00:14:32,480 --> 00:14:32,490
persistence rates as a bottleneck in the
 

665
00:14:32,490 --> 00:14:35,150
persistence rates as a bottleneck in the
performance of the system leaving only

666
00:14:35,150 --> 00:14:35,160
performance of the system leaving only
 

667
00:14:35,160 --> 00:14:37,249
performance of the system leaving only
as performance bottlenecks the network

668
00:14:37,249 --> 00:14:37,259
as performance bottlenecks the network
 

669
00:14:37,259 --> 00:14:39,110
as performance bottlenecks the network
and the CPU which is what we'll talk

670
00:14:39,110 --> 00:14:39,120
and the CPU which is what we'll talk
 

671
00:14:39,120 --> 00:14:43,759
and the CPU which is what we'll talk
about next ok so there's a question if

672
00:14:43,759 --> 00:14:43,769
about next ok so there's a question if
 

673
00:14:43,769 --> 00:14:49,669
about next ok so there's a question if
the datacenter power fails and farm lose

674
00:14:49,669 --> 00:14:49,679
the datacenter power fails and farm lose
 

675
00:14:49,679 --> 00:14:52,160
the datacenter power fails and farm lose
everything for solid-state drive would

676
00:14:52,160 --> 00:14:52,170
everything for solid-state drive would
 

677
00:14:52,170 --> 00:14:53,749
everything for solid-state drive would
it be possible to carry all the data to

678
00:14:53,749 --> 00:14:53,759
it be possible to carry all the data to
 

679
00:14:53,759 --> 00:14:55,400
it be possible to carry all the data to
a different data center and continue

680
00:14:55,400 --> 00:14:55,410
a different data center and continue
 

681
00:14:55,410 --> 00:15:00,999
a different data center and continue
operation there in principle absolutely

682
00:15:00,999 --> 00:15:01,009
operation there in principle absolutely
 

683
00:15:01,009 --> 00:15:05,059
operation there in principle absolutely
in practice I think would be would all

684
00:15:05,059 --> 00:15:05,069
in practice I think would be would all
 

685
00:15:05,069 --> 00:15:07,220
in practice I think would be would all
certainly be easier to restore power to

686
00:15:07,220 --> 00:15:07,230
certainly be easier to restore power to
 

687
00:15:07,230 --> 00:15:10,579
certainly be easier to restore power to
the data center then to move the drives

688
00:15:10,579 --> 00:15:10,589
the data center then to move the drives
 

689
00:15:10,589 --> 00:15:12,230
the data center then to move the drives
the problem is there's no power and the

690
00:15:12,230 --> 00:15:12,240
the problem is there's no power and the
 

691
00:15:12,240 --> 00:15:14,509
the problem is there's no power and the
power in the dated old data center so

692
00:15:14,509 --> 00:15:14,519
power in the dated old data center so
 

693
00:15:14,519 --> 00:15:16,220
power in the dated old data center so
you'd have to physically move the drives

694
00:15:16,220 --> 00:15:16,230
you'd have to physically move the drives
 

695
00:15:16,230 --> 00:15:19,009
you'd have to physically move the drives
and the computers maybe just the drives

696
00:15:19,009 --> 00:15:19,019
and the computers maybe just the drives
 

697
00:15:19,019 --> 00:15:21,379
and the computers maybe just the drives
to the new data center so this was if

698
00:15:21,379 --> 00:15:21,389
to the new data center so this was if
 

699
00:15:21,389 --> 00:15:23,480
to the new data center so this was if
you wanted to do this it might be

700
00:15:23,480 --> 00:15:23,490
you wanted to do this it might be
 

701
00:15:23,490 --> 00:15:27,269
you wanted to do this it might be
possible but it's certainly not

702
00:15:27,269 --> 00:15:27,279
possible but it's certainly not
 

703
00:15:27,279 --> 00:15:29,069
possible but it's certainly not
it's not what the farm designers had in

704
00:15:29,069 --> 00:15:29,079
it's not what the farm designers had in
 

705
00:15:29,079 --> 00:15:33,290
it's not what the farm designers had in
mind they assumed the power be restored

706
00:15:33,290 --> 00:15:33,300

 

707
00:15:33,300 --> 00:15:38,579

okay so that's NVRAM and at this point

708
00:15:38,579 --> 00:15:38,589
okay so that's NVRAM and at this point
 

709
00:15:38,589 --> 00:15:40,920
okay so that's NVRAM and at this point
we can just ignore nvram for the rest of

710
00:15:40,920 --> 00:15:40,930
we can just ignore nvram for the rest of
 

711
00:15:40,930 --> 00:15:45,239
we can just ignore nvram for the rest of
the design it doesn't it doesn't really

712
00:15:45,239 --> 00:15:45,249
the design it doesn't it doesn't really
 

713
00:15:45,249 --> 00:15:46,530
the design it doesn't it doesn't really
interact with the rest of the design

714
00:15:46,530 --> 00:15:46,540
interact with the rest of the design
 

715
00:15:46,540 --> 00:15:48,900
interact with the rest of the design
except that we know we're have to worry

716
00:15:48,900 --> 00:15:48,910
except that we know we're have to worry
 

717
00:15:48,910 --> 00:15:54,259
except that we know we're have to worry
about writing data to disk all right so

718
00:15:54,259 --> 00:15:54,269
about writing data to disk all right so
 

719
00:15:54,269 --> 00:15:56,610
about writing data to disk all right so
as I mentioned the remaining bottlenecks

720
00:15:56,610 --> 00:15:56,620
as I mentioned the remaining bottlenecks
 

721
00:15:56,620 --> 00:15:59,280
as I mentioned the remaining bottlenecks
once you eliminate having a great data

722
00:15:59,280 --> 00:15:59,290
once you eliminate having a great data
 

723
00:15:59,290 --> 00:16:00,869
once you eliminate having a great data
to disk for persistence in remaining

724
00:16:00,869 --> 00:16:00,879
to disk for persistence in remaining
 

725
00:16:00,879 --> 00:16:02,759
to disk for persistence in remaining
bottlenecks have to do with the CPU and

726
00:16:02,759 --> 00:16:02,769
bottlenecks have to do with the CPU and
 

727
00:16:02,769 --> 00:16:07,350
bottlenecks have to do with the CPU and
the network in fact in farman and indeed

728
00:16:07,350 --> 00:16:07,360
the network in fact in farman and indeed
 

729
00:16:07,360 --> 00:16:09,210
the network in fact in farman and indeed
a lot of the systems that i've been

730
00:16:09,210 --> 00:16:09,220
a lot of the systems that i've been
 

731
00:16:09,220 --> 00:16:13,499
a lot of the systems that i've been
involved with the a huge bottleneck has

732
00:16:13,499 --> 00:16:13,509
involved with the a huge bottleneck has
 

733
00:16:13,509 --> 00:16:16,410
involved with the a huge bottleneck has
been the cpu time required to deal with

734
00:16:16,410 --> 00:16:16,420
been the cpu time required to deal with
 

735
00:16:16,420 --> 00:16:18,540
been the cpu time required to deal with
network interactions so now we're can

736
00:16:18,540 --> 00:16:18,550
network interactions so now we're can
 

737
00:16:18,550 --> 00:16:21,299
network interactions so now we're can
CPU are kind of joint bottlenecks here

738
00:16:21,299 --> 00:16:21,309
CPU are kind of joint bottlenecks here
 

739
00:16:21,309 --> 00:16:23,460
CPU are kind of joint bottlenecks here
farm doesn't have any kind of speed of

740
00:16:23,460 --> 00:16:23,470
farm doesn't have any kind of speed of
 

741
00:16:23,470 --> 00:16:27,540
farm doesn't have any kind of speed of
light network problems it just has the

742
00:16:27,540 --> 00:16:27,550
light network problems it just has the
 

743
00:16:27,550 --> 00:16:29,999
light network problems it just has the
problems or it just spends a lot of time

744
00:16:29,999 --> 00:16:30,009
problems or it just spends a lot of time
 

745
00:16:30,009 --> 00:16:31,679
problems or it just spends a lot of time
eliminating bottlenecks having to do is

746
00:16:31,679 --> 00:16:31,689
eliminating bottlenecks having to do is
 

747
00:16:31,689 --> 00:16:34,049
eliminating bottlenecks having to do is
getting network data into and out of the

748
00:16:34,049 --> 00:16:34,059
getting network data into and out of the
 

749
00:16:34,059 --> 00:16:38,299
getting network data into and out of the
computers so first as a background I

750
00:16:38,299 --> 00:16:38,309
computers so first as a background I
 

751
00:16:38,309 --> 00:16:40,889
computers so first as a background I
want to lay out what the conventional

752
00:16:40,889 --> 00:16:40,899
want to lay out what the conventional
 

753
00:16:40,899 --> 00:16:43,170
want to lay out what the conventional
architecture is for getting things like

754
00:16:43,170 --> 00:16:43,180
architecture is for getting things like
 

755
00:16:43,180 --> 00:16:46,019
architecture is for getting things like
remote procedure call packets between

756
00:16:46,019 --> 00:16:46,029
remote procedure call packets between
 

757
00:16:46,029 --> 00:16:51,600
remote procedure call packets between
applications and on different computers

758
00:16:51,600 --> 00:16:51,610
applications and on different computers
 

759
00:16:51,610 --> 00:16:54,299
applications and on different computers
just so that can we have an idea of why

760
00:16:54,299 --> 00:16:54,309
just so that can we have an idea of why
 

761
00:16:54,309 --> 00:16:56,939
just so that can we have an idea of why
this approach that farm takes is more

762
00:16:56,939 --> 00:16:56,949
this approach that farm takes is more
 

763
00:16:56,949 --> 00:16:58,920
this approach that farm takes is more
efficient so typically what's going on

764
00:16:58,920 --> 00:16:58,930
efficient so typically what's going on
 

765
00:16:58,930 --> 00:17:03,210
efficient so typically what's going on
is on one computer that maybe wants to

766
00:17:03,210 --> 00:17:03,220
is on one computer that maybe wants to
 

767
00:17:03,220 --> 00:17:05,490
is on one computer that maybe wants to
send a procedure call message you might

768
00:17:05,490 --> 00:17:05,500
send a procedure call message you might
 

769
00:17:05,500 --> 00:17:09,419
send a procedure call message you might
have an application and then the

770
00:17:09,419 --> 00:17:09,429
have an application and then the
 

771
00:17:09,429 --> 00:17:11,240
have an application and then the
application is running in user space

772
00:17:11,240 --> 00:17:11,250
application is running in user space
 

773
00:17:11,250 --> 00:17:15,480
application is running in user space
there's a user kernel boundary here the

774
00:17:15,480 --> 00:17:15,490
there's a user kernel boundary here the
 

775
00:17:15,490 --> 00:17:17,100
there's a user kernel boundary here the
application makes system calls into the

776
00:17:17,100 --> 00:17:17,110
application makes system calls into the
 

777
00:17:17,110 --> 00:17:19,350
application makes system calls into the
kernel which are not particularly cheap

778
00:17:19,350 --> 00:17:19,360
kernel which are not particularly cheap
 

779
00:17:19,360 --> 00:17:22,590
kernel which are not particularly cheap
in order to send data and then there's a

780
00:17:22,590 --> 00:17:22,600
in order to send data and then there's a
 

781
00:17:22,600 --> 00:17:24,329
in order to send data and then there's a
whole stack of software inside the

782
00:17:24,329 --> 00:17:24,339
whole stack of software inside the
 

783
00:17:24,339 --> 00:17:26,130
whole stack of software inside the
kernel involved is sending data over the

784
00:17:26,130 --> 00:17:26,140
kernel involved is sending data over the
 

785
00:17:26,140 --> 00:17:29,610
kernel involved is sending data over the
network there might be what's usually

786
00:17:29,610 --> 00:17:29,620
network there might be what's usually
 

787
00:17:29,620 --> 00:17:32,549
network there might be what's usually
called a socket layer that does

788
00:17:32,549 --> 00:17:32,559
called a socket layer that does
 

789
00:17:32,559 --> 00:17:36,060
called a socket layer that does
buffering which involves copying the

790
00:17:36,060 --> 00:17:36,070
buffering which involves copying the
 

791
00:17:36,070 --> 00:17:38,580
buffering which involves copying the
data which takes time there's typically

792
00:17:38,580 --> 00:17:38,590
data which takes time there's typically
 

793
00:17:38,590 --> 00:17:40,220
data which takes time there's typically
a complex TCP

794
00:17:40,220 --> 00:17:40,230
a complex TCP
 

795
00:17:40,230 --> 00:17:42,590
a complex TCP
the protocol stack that knows all about

796
00:17:42,590 --> 00:17:42,600
the protocol stack that knows all about
 

797
00:17:42,600 --> 00:17:45,049
the protocol stack that knows all about
things like retransmitting and sequence

798
00:17:45,049 --> 00:17:45,059
things like retransmitting and sequence
 

799
00:17:45,059 --> 00:17:49,120
things like retransmitting and sequence
numbers and check sums and flow control

800
00:17:49,120 --> 00:17:49,130
numbers and check sums and flow control
 

801
00:17:49,130 --> 00:17:51,640
numbers and check sums and flow control
there's quite a bit of processing there

802
00:17:51,640 --> 00:17:51,650
there's quite a bit of processing there
 

803
00:17:51,650 --> 00:17:54,500
there's quite a bit of processing there
at the bottom there's a piece of

804
00:17:54,500 --> 00:17:54,510
at the bottom there's a piece of
 

805
00:17:54,510 --> 00:17:57,289
at the bottom there's a piece of
hardware called the network interface

806
00:17:57,289 --> 00:17:57,299
hardware called the network interface
 

807
00:17:57,299 --> 00:18:00,500
hardware called the network interface
card which is has a bunch of registers

808
00:18:00,500 --> 00:18:00,510
card which is has a bunch of registers
 

809
00:18:00,510 --> 00:18:04,820
card which is has a bunch of registers
that the kernel can talk to to configure

810
00:18:04,820 --> 00:18:04,830
that the kernel can talk to to configure
 

811
00:18:04,830 --> 00:18:07,220
that the kernel can talk to to configure
it and it has hardware required to send

812
00:18:07,220 --> 00:18:07,230
it and it has hardware required to send
 

813
00:18:07,230 --> 00:18:09,250
it and it has hardware required to send
bits out over the cable onto the network

814
00:18:09,250 --> 00:18:09,260
bits out over the cable onto the network
 

815
00:18:09,260 --> 00:18:11,750
bits out over the cable onto the network
and so there's some sort of network

816
00:18:11,750 --> 00:18:11,760
and so there's some sort of network
 

817
00:18:11,760 --> 00:18:15,070
and so there's some sort of network
interface card driver in the kernel and

818
00:18:15,070 --> 00:18:15,080
interface card driver in the kernel and
 

819
00:18:15,080 --> 00:18:18,169
interface card driver in the kernel and
then all self respecting that we're

820
00:18:18,169 --> 00:18:18,179
then all self respecting that we're
 

821
00:18:18,179 --> 00:18:19,909
then all self respecting that we're
gonna price cards use direct memory

822
00:18:19,909 --> 00:18:19,919
gonna price cards use direct memory
 

823
00:18:19,919 --> 00:18:22,100
gonna price cards use direct memory
access to move packets into and out of

824
00:18:22,100 --> 00:18:22,110
access to move packets into and out of
 

825
00:18:22,110 --> 00:18:23,960
access to move packets into and out of
host memory so there's going to be

826
00:18:23,960 --> 00:18:23,970
host memory so there's going to be
 

827
00:18:23,970 --> 00:18:26,900
host memory so there's going to be
things like queues of packets that the

828
00:18:26,900 --> 00:18:26,910
things like queues of packets that the
 

829
00:18:26,910 --> 00:18:28,909
things like queues of packets that the
network interfaces card has D made into

830
00:18:28,909 --> 00:18:28,919
network interfaces card has D made into
 

831
00:18:28,919 --> 00:18:30,620
network interfaces card has D made into
memory the waiting for the kernel to

832
00:18:30,620 --> 00:18:30,630
memory the waiting for the kernel to
 

833
00:18:30,630 --> 00:18:33,620
memory the waiting for the kernel to
read and outgoing hues the packets that

834
00:18:33,620 --> 00:18:33,630
read and outgoing hues the packets that
 

835
00:18:33,630 --> 00:18:34,730
read and outgoing hues the packets that
the kernel would like then that we're

836
00:18:34,730 --> 00:18:34,740
the kernel would like then that we're
 

837
00:18:34,740 --> 00:18:36,830
the kernel would like then that we're
going to face to car to send as soon as

838
00:18:36,830 --> 00:18:36,840
going to face to car to send as soon as
 

839
00:18:36,840 --> 00:18:39,380
going to face to car to send as soon as
convenient all right so you want to send

840
00:18:39,380 --> 00:18:39,390
convenient all right so you want to send
 

841
00:18:39,390 --> 00:18:41,690
convenient all right so you want to send
a message like an RPC request let's go

842
00:18:41,690 --> 00:18:41,700
a message like an RPC request let's go
 

843
00:18:41,700 --> 00:18:43,039
a message like an RPC request let's go
down from the application through the

844
00:18:43,039 --> 00:18:43,049
down from the application through the
 

845
00:18:43,049 --> 00:18:45,230
down from the application through the
stack network interface card sends the

846
00:18:45,230 --> 00:18:45,240
stack network interface card sends the
 

847
00:18:45,240 --> 00:18:48,380
stack network interface card sends the
bits out on a cable and then there's the

848
00:18:48,380 --> 00:18:48,390
bits out on a cable and then there's the
 

849
00:18:48,390 --> 00:18:51,830
bits out on a cable and then there's the
reverse stack on the other side isn't

850
00:18:51,830 --> 00:18:51,840
reverse stack on the other side isn't
 

851
00:18:51,840 --> 00:18:55,940
reverse stack on the other side isn't
network interface Hardware here in the

852
00:18:55,940 --> 00:18:55,950
network interface Hardware here in the
 

853
00:18:55,950 --> 00:18:57,260
network interface Hardware here in the
kernel then organ or face might

854
00:18:57,260 --> 00:18:57,270
kernel then organ or face might
 

855
00:18:57,270 --> 00:19:00,049
kernel then organ or face might
interrupt the kernel kernel runs driver

856
00:19:00,049 --> 00:19:00,059
interrupt the kernel kernel runs driver
 

857
00:19:00,059 --> 00:19:02,840
interrupt the kernel kernel runs driver
Code which hands packets to the TCP

858
00:19:02,840 --> 00:19:02,850
Code which hands packets to the TCP
 

859
00:19:02,850 --> 00:19:06,159
Code which hands packets to the TCP
protocol which writes them into buffers

860
00:19:06,159 --> 00:19:06,169
protocol which writes them into buffers
 

861
00:19:06,169 --> 00:19:08,620
protocol which writes them into buffers
waiting for the application to read them

862
00:19:08,620 --> 00:19:08,630
waiting for the application to read them
 

863
00:19:08,630 --> 00:19:10,820
waiting for the application to read them
at some point the application gets

864
00:19:10,820 --> 00:19:10,830
at some point the application gets
 

865
00:19:10,830 --> 00:19:12,409
at some point the application gets
around reading them makes system calls

866
00:19:12,409 --> 00:19:12,419
around reading them makes system calls
 

867
00:19:12,419 --> 00:19:15,380
around reading them makes system calls
into the kernel copies the data out of

868
00:19:15,380 --> 00:19:15,390
into the kernel copies the data out of
 

869
00:19:15,390 --> 00:19:19,430
into the kernel copies the data out of
these buffers into user space this is a

870
00:19:19,430 --> 00:19:19,440
these buffers into user space this is a
 

871
00:19:19,440 --> 00:19:21,970
these buffers into user space this is a
lot of software it's a lot of processing

872
00:19:21,970 --> 00:19:21,980
lot of software it's a lot of processing
 

873
00:19:21,980 --> 00:19:24,620
lot of software it's a lot of processing
and a lot of fairly expensive CPU

874
00:19:24,620 --> 00:19:24,630
and a lot of fairly expensive CPU
 

875
00:19:24,630 --> 00:19:26,090
and a lot of fairly expensive CPU
operations like system calls and

876
00:19:26,090 --> 00:19:26,100
operations like system calls and
 

877
00:19:26,100 --> 00:19:29,659
operations like system calls and
interrupts and copying data as a result

878
00:19:29,659 --> 00:19:29,669
interrupts and copying data as a result
 

879
00:19:29,669 --> 00:19:32,810
interrupts and copying data as a result
so classical Network communication is

880
00:19:32,810 --> 00:19:32,820
so classical Network communication is
 

881
00:19:32,820 --> 00:19:35,330
so classical Network communication is
relatively slow it's quite hard to build

882
00:19:35,330 --> 00:19:35,340
relatively slow it's quite hard to build
 

883
00:19:35,340 --> 00:19:37,460
relatively slow it's quite hard to build
an RPC system with the kind of

884
00:19:37,460 --> 00:19:37,470
an RPC system with the kind of
 

885
00:19:37,470 --> 00:19:39,350
an RPC system with the kind of
traditional architecture that can

886
00:19:39,350 --> 00:19:39,360
traditional architecture that can
 

887
00:19:39,360 --> 00:19:41,720
traditional architecture that can
deliver more than say a few hundred

888
00:19:41,720 --> 00:19:41,730
deliver more than say a few hundred
 

889
00:19:41,730 --> 00:19:45,380
deliver more than say a few hundred
thousand or BC messages per second and

890
00:19:45,380 --> 00:19:45,390
thousand or BC messages per second and
 

891
00:19:45,390 --> 00:19:47,240
thousand or BC messages per second and
that might seem like a lot but it's

892
00:19:47,240 --> 00:19:47,250
that might seem like a lot but it's
 

893
00:19:47,250 --> 00:19:49,490
that might seem like a lot but it's
orders of magnitude too few for the kind

894
00:19:49,490 --> 00:19:49,500
orders of magnitude too few for the kind
 

895
00:19:49,500 --> 00:19:51,380
orders of magnitude too few for the kind
of performance that farm is trying to

896
00:19:51,380 --> 00:19:51,390
of performance that farm is trying to
 

897
00:19:51,390 --> 00:19:53,280
of performance that farm is trying to
target and in general that

898
00:19:53,280 --> 00:19:53,290
target and in general that
 

899
00:19:53,290 --> 00:19:54,840
target and in general that
couple hundred thousand our pcs per

900
00:19:54,840 --> 00:19:54,850
couple hundred thousand our pcs per
 

901
00:19:54,850 --> 00:19:58,800
couple hundred thousand our pcs per
second is far far less than the speed

902
00:19:58,800 --> 00:19:58,810
second is far far less than the speed
 

903
00:19:58,810 --> 00:20:01,290
second is far far less than the speed
that the actual network hardware like

904
00:20:01,290 --> 00:20:01,300
that the actual network hardware like
 

905
00:20:01,300 --> 00:20:03,120
that the actual network hardware like
Network wire in the network interface

906
00:20:03,120 --> 00:20:03,130
Network wire in the network interface
 

907
00:20:03,130 --> 00:20:05,100
Network wire in the network interface
card is capable of typically these

908
00:20:05,100 --> 00:20:05,110
card is capable of typically these
 

909
00:20:05,110 --> 00:20:07,380
card is capable of typically these
cables run at things like 10 gigabits

910
00:20:07,380 --> 00:20:07,390
cables run at things like 10 gigabits
 

911
00:20:07,390 --> 00:20:11,130
cables run at things like 10 gigabits
per second it's very very hard to write

912
00:20:11,130 --> 00:20:11,140
per second it's very very hard to write
 

913
00:20:11,140 --> 00:20:12,960
per second it's very very hard to write
our PC software that can generate small

914
00:20:12,960 --> 00:20:12,970
our PC software that can generate small
 

915
00:20:12,970 --> 00:20:16,620
our PC software that can generate small
messages of the kind that databases

916
00:20:16,620 --> 00:20:16,630
messages of the kind that databases
 

917
00:20:16,630 --> 00:20:18,750
messages of the kind that databases
often need to use it's very hard to

918
00:20:18,750 --> 00:20:18,760
often need to use it's very hard to
 

919
00:20:18,760 --> 00:20:20,580
often need to use it's very hard to
write software in this style that can

920
00:20:20,580 --> 00:20:20,590
write software in this style that can
 

921
00:20:20,590 --> 00:20:24,270
write software in this style that can
generate or absorb anything like 10

922
00:20:24,270 --> 00:20:24,280
generate or absorb anything like 10
 

923
00:20:24,280 --> 00:20:30,390
generate or absorb anything like 10
gigabits per second of messages that's

924
00:20:30,390 --> 00:20:30,400
gigabits per second of messages that's
 

925
00:20:30,400 --> 00:20:32,070
gigabits per second of messages that's
millions maybe tens of millions of

926
00:20:32,070 --> 00:20:32,080
millions maybe tens of millions of
 

927
00:20:32,080 --> 00:20:34,380
millions maybe tens of millions of
messages per second ok so this is the

928
00:20:34,380 --> 00:20:34,390
messages per second ok so this is the
 

929
00:20:34,390 --> 00:20:37,650
messages per second ok so this is the
plan that farm doesn't use and a sort of

930
00:20:37,650 --> 00:20:37,660
plan that farm doesn't use and a sort of
 

931
00:20:37,660 --> 00:20:45,600
plan that farm doesn't use and a sort of
a reaction to to this plan instead farm

932
00:20:45,600 --> 00:20:45,610
a reaction to to this plan instead farm
 

933
00:20:45,610 --> 00:20:52,020
a reaction to to this plan instead farm
uses - - ideas to reduce the costs of

934
00:20:52,020 --> 00:20:52,030
uses - - ideas to reduce the costs of
 

935
00:20:52,030 --> 00:20:55,320
uses - - ideas to reduce the costs of
pushing packets around the first one

936
00:20:55,320 --> 00:20:55,330
pushing packets around the first one
 

937
00:20:55,330 --> 00:21:01,470
pushing packets around the first one
I'll call kernel bypass and the idea

938
00:21:01,470 --> 00:21:01,480
I'll call kernel bypass and the idea
 

939
00:21:01,480 --> 00:21:05,000
I'll call kernel bypass and the idea
here is that instead of the application

940
00:21:05,000 --> 00:21:05,010
here is that instead of the application
 

941
00:21:05,010 --> 00:21:06,870
here is that instead of the application
sending all its data down through a

942
00:21:06,870 --> 00:21:06,880
sending all its data down through a
 

943
00:21:06,880 --> 00:21:15,450
sending all its data down through a
complex stack of kernel code instead the

944
00:21:15,450 --> 00:21:15,460
complex stack of kernel code instead the
 

945
00:21:15,460 --> 00:21:18,120
complex stack of kernel code instead the
application the kernel configures the

946
00:21:18,120 --> 00:21:18,130
application the kernel configures the
 

947
00:21:18,130 --> 00:21:21,360
application the kernel configures the
protection machinery in the computer to

948
00:21:21,360 --> 00:21:21,370
protection machinery in the computer to
 

949
00:21:21,370 --> 00:21:24,300
protection machinery in the computer to
allow the application direct access to

950
00:21:24,300 --> 00:21:24,310
allow the application direct access to
 

951
00:21:24,310 --> 00:21:26,400
allow the application direct access to
network interface card so the

952
00:21:26,400 --> 00:21:26,410
network interface card so the
 

953
00:21:26,410 --> 00:21:28,050
network interface card so the
application can actually reach out and

954
00:21:28,050 --> 00:21:28,060
application can actually reach out and
 

955
00:21:28,060 --> 00:21:30,630
application can actually reach out and
touch the network interfaces registers

956
00:21:30,630 --> 00:21:30,640
touch the network interfaces registers
 

957
00:21:30,640 --> 00:21:33,330
touch the network interfaces registers
and tell it what to do in addition the

958
00:21:33,330 --> 00:21:33,340
and tell it what to do in addition the
 

959
00:21:33,340 --> 00:21:35,540
and tell it what to do in addition the
network interface card when it DMAs

960
00:21:35,540 --> 00:21:35,550
network interface card when it DMAs
 

961
00:21:35,550 --> 00:21:38,760
network interface card when it DMAs
and this kernel bypass scheme it DNA's

962
00:21:38,760 --> 00:21:38,770
and this kernel bypass scheme it DNA's
 

963
00:21:38,770 --> 00:21:41,040
and this kernel bypass scheme it DNA's
directly into application memory where

964
00:21:41,040 --> 00:21:41,050
directly into application memory where
 

965
00:21:41,050 --> 00:21:42,690
directly into application memory where
the application can see the bytes

966
00:21:42,690 --> 00:21:42,700
the application can see the bytes
 

967
00:21:42,700 --> 00:21:46,200
the application can see the bytes
arriving directly without kernel

968
00:21:46,200 --> 00:21:46,210
arriving directly without kernel
 

969
00:21:46,210 --> 00:21:47,640
arriving directly without kernel
intervention and when the application

970
00:21:47,640 --> 00:21:47,650
intervention and when the application
 

971
00:21:47,650 --> 00:21:49,920
intervention and when the application
needs to send data the application can

972
00:21:49,920 --> 00:21:49,930
needs to send data the application can
 

973
00:21:49,930 --> 00:21:53,610
needs to send data the application can
create queues that the network interface

974
00:21:53,610 --> 00:21:53,620
create queues that the network interface
 

975
00:21:53,620 --> 00:21:56,820
create queues that the network interface
card can directly read with DMA and send

976
00:21:56,820 --> 00:21:56,830
card can directly read with DMA and send
 

977
00:21:56,830 --> 00:21:58,350
card can directly read with DMA and send
out over the wire so now we've

978
00:21:58,350 --> 00:21:58,360
out over the wire so now we've
 

979
00:21:58,360 --> 00:22:01,290
out over the wire so now we've
completely eliminated all the kernel

980
00:22:01,290 --> 00:22:01,300
completely eliminated all the kernel
 

981
00:22:01,300 --> 00:22:03,270
completely eliminated all the kernel
code involved in networking kernels just

982
00:22:03,270 --> 00:22:03,280
code involved in networking kernels just
 

983
00:22:03,280 --> 00:22:04,590
code involved in networking kernels just
not involved there's no system calls

984
00:22:04,590 --> 00:22:04,600
not involved there's no system calls
 

985
00:22:04,600 --> 00:22:06,130
not involved there's no system calls
there's no interrupts

986
00:22:06,130 --> 00:22:06,140
there's no interrupts
 

987
00:22:06,140 --> 00:22:08,110
there's no interrupts
the application just directly reason why

988
00:22:08,110 --> 00:22:08,120
the application just directly reason why
 

989
00:22:08,120 --> 00:22:09,520
the application just directly reason why
it's memory that the network interface

990
00:22:09,520 --> 00:22:09,530
it's memory that the network interface
 

991
00:22:09,530 --> 00:22:11,410
it's memory that the network interface
card sees and of course the same thing

992
00:22:11,410 --> 00:22:11,420
card sees and of course the same thing
 

993
00:22:11,420 --> 00:22:21,910
card sees and of course the same thing
on the other side and this is a this is

994
00:22:21,910 --> 00:22:21,920
on the other side and this is a this is
 

995
00:22:21,920 --> 00:22:25,120
on the other side and this is a this is
an idea that is actually was not

996
00:22:25,120 --> 00:22:25,130
an idea that is actually was not
 

997
00:22:25,130 --> 00:22:27,940
an idea that is actually was not
possible years ago with network

998
00:22:27,940 --> 00:22:27,950
possible years ago with network
 

999
00:22:27,950 --> 00:22:30,580
possible years ago with network
interface cards but most modern serious

1000
00:22:30,580 --> 00:22:30,590
interface cards but most modern serious
 

1001
00:22:30,590 --> 00:22:33,190
interface cards but most modern serious
network interface cards okay can be set

1002
00:22:33,190 --> 00:22:33,200
network interface cards okay can be set
 

1003
00:22:33,200 --> 00:22:34,810
network interface cards okay can be set
up to do this it does however require

1004
00:22:34,810 --> 00:22:34,820
up to do this it does however require
 

1005
00:22:34,820 --> 00:22:37,240
up to do this it does however require
that the application you know you know

1006
00:22:37,240 --> 00:22:37,250
that the application you know you know
 

1007
00:22:37,250 --> 00:22:39,700
that the application you know you know
all those things that TCP was doing for

1008
00:22:39,700 --> 00:22:39,710
all those things that TCP was doing for
 

1009
00:22:39,710 --> 00:22:43,270
all those things that TCP was doing for
you like check sums or retransmission

1010
00:22:43,270 --> 00:22:43,280
you like check sums or retransmission
 

1011
00:22:43,280 --> 00:22:46,270
you like check sums or retransmission
the application would now be in charge

1012
00:22:46,270 --> 00:22:46,280
the application would now be in charge
 

1013
00:22:46,280 --> 00:22:49,180
the application would now be in charge
if we wanted to do this you can actually

1014
00:22:49,180 --> 00:22:49,190
if we wanted to do this you can actually
 

1015
00:22:49,190 --> 00:22:55,500
if we wanted to do this you can actually
do this yourself kernel bypass using a

1016
00:22:55,500 --> 00:22:55,510
do this yourself kernel bypass using a
 

1017
00:22:55,510 --> 00:22:57,520
do this yourself kernel bypass using a
toolkit that you can find on the way up

1018
00:22:57,520 --> 00:22:57,530
toolkit that you can find on the way up
 

1019
00:22:57,530 --> 00:22:57,960
toolkit that you can find on the way up
called

1020
00:22:57,960 --> 00:22:57,970
called
 

1021
00:22:57,970 --> 00:23:02,050
called
DP DK and it's relatively easy to use

1022
00:23:02,050 --> 00:23:02,060
DP DK and it's relatively easy to use
 

1023
00:23:02,060 --> 00:23:04,810
DP DK and it's relatively easy to use
and allows people to write extremely

1024
00:23:04,810 --> 00:23:04,820
and allows people to write extremely
 

1025
00:23:04,820 --> 00:23:08,610
and allows people to write extremely
high performance networking applications

1026
00:23:08,610 --> 00:23:08,620
high performance networking applications
 

1027
00:23:08,620 --> 00:23:12,700
high performance networking applications
but and so so form does use this it's

1028
00:23:12,700 --> 00:23:12,710
but and so so form does use this it's
 

1029
00:23:12,710 --> 00:23:14,170
but and so so form does use this it's
applications directly you talk to the

1030
00:23:14,170 --> 00:23:14,180
applications directly you talk to the
 

1031
00:23:14,180 --> 00:23:15,670
applications directly you talk to the
neck the neck DM ace things right into

1032
00:23:15,670 --> 00:23:15,680
neck the neck DM ace things right into
 

1033
00:23:15,680 --> 00:23:19,840
neck the neck DM ace things right into
application memory we have a student

1034
00:23:19,840 --> 00:23:19,850
application memory we have a student
 

1035
00:23:19,850 --> 00:23:22,900
application memory we have a student
question I'm sorry yes does this mean

1036
00:23:22,900 --> 00:23:22,910
question I'm sorry yes does this mean
 

1037
00:23:22,910 --> 00:23:24,280
question I'm sorry yes does this mean
that farm machines run a modified

1038
00:23:24,280 --> 00:23:24,290
that farm machines run a modified
 

1039
00:23:24,290 --> 00:23:31,360
that farm machines run a modified
operating system well I I don't know the

1040
00:23:31,360 --> 00:23:31,370
operating system well I I don't know the
 

1041
00:23:31,370 --> 00:23:32,740
operating system well I I don't know the
actual answer that question I believe

1042
00:23:32,740 --> 00:23:32,750
actual answer that question I believe
 

1043
00:23:32,750 --> 00:23:36,490
actual answer that question I believe
farm is runs on Windows some form of

1044
00:23:36,490 --> 00:23:36,500
farm is runs on Windows some form of
 

1045
00:23:36,500 --> 00:23:38,110
farm is runs on Windows some form of
Windows whether or not they had to

1046
00:23:38,110 --> 00:23:38,120
Windows whether or not they had to
 

1047
00:23:38,120 --> 00:23:44,230
Windows whether or not they had to
modify Windows I do not know in the sort

1048
00:23:44,230 --> 00:23:44,240
modify Windows I do not know in the sort
 

1049
00:23:44,240 --> 00:23:46,930
modify Windows I do not know in the sort
of Linux world in Linux world there's

1050
00:23:46,930 --> 00:23:46,940
of Linux world in Linux world there's
 

1051
00:23:46,940 --> 00:23:48,940
of Linux world in Linux world there's
already full support for this

1052
00:23:48,940 --> 00:23:48,950
already full support for this
 

1053
00:23:48,950 --> 00:23:50,680
already full support for this
it does require kernel intervention

1054
00:23:50,680 --> 00:23:50,690
it does require kernel intervention
 

1055
00:23:50,690 --> 00:23:54,370
it does require kernel intervention
because the kernel has to be willing to

1056
00:23:54,370 --> 00:23:54,380
because the kernel has to be willing to
 

1057
00:23:54,380 --> 00:23:56,590
because the kernel has to be willing to
give ordinarily application code cannot

1058
00:23:56,590 --> 00:23:56,600
give ordinarily application code cannot
 

1059
00:23:56,600 --> 00:23:58,740
give ordinarily application code cannot
do anything directly with devices so

1060
00:23:58,740 --> 00:23:58,750
do anything directly with devices so
 

1061
00:23:58,750 --> 00:24:01,510
do anything directly with devices so
Linux has had to be modified to allow

1062
00:24:01,510 --> 00:24:01,520
Linux has had to be modified to allow
 

1063
00:24:01,520 --> 00:24:05,880
Linux has had to be modified to allow
the allow the kernel to delegate

1064
00:24:05,880 --> 00:24:05,890
the allow the kernel to delegate
 

1065
00:24:05,890 --> 00:24:08,650
the allow the kernel to delegate
hardware access to applications so it

1066
00:24:08,650 --> 00:24:08,660
hardware access to applications so it
 

1067
00:24:08,660 --> 00:24:12,400
hardware access to applications so it
does require kernel modifications those

1068
00:24:12,400 --> 00:24:12,410
does require kernel modifications those
 

1069
00:24:12,410 --> 00:24:13,660
does require kernel modifications those
monitor occasions are already in Linux

1070
00:24:13,660 --> 00:24:13,670
monitor occasions are already in Linux
 

1071
00:24:13,670 --> 00:24:16,180
monitor occasions are already in Linux
and maybe already in Windows also in

1072
00:24:16,180 --> 00:24:16,190
and maybe already in Windows also in
 

1073
00:24:16,190 --> 00:24:18,409
and maybe already in Windows also in
addition though this

1074
00:24:18,409 --> 00:24:18,419
addition though this
 

1075
00:24:18,419 --> 00:24:21,350
addition though this
on fairly intelligent Knicks because of

1076
00:24:21,350 --> 00:24:21,360
on fairly intelligent Knicks because of
 

1077
00:24:21,360 --> 00:24:22,370
on fairly intelligent Knicks because of
course you're going to have multiple

1078
00:24:22,370 --> 00:24:22,380
course you're going to have multiple
 

1079
00:24:22,380 --> 00:24:23,930
course you're going to have multiple
applications that want to play this game

1080
00:24:23,930 --> 00:24:23,940
applications that want to play this game
 

1081
00:24:23,940 --> 00:24:25,759
applications that want to play this game
with a network interface card and so

1082
00:24:25,759 --> 00:24:25,769
with a network interface card and so
 

1083
00:24:25,769 --> 00:24:27,889
with a network interface card and so
modern NICs actually know about talking

1084
00:24:27,889 --> 00:24:27,899
modern NICs actually know about talking
 

1085
00:24:27,899 --> 00:24:30,380
modern NICs actually know about talking
to multiple distinct cues so that you

1086
00:24:30,380 --> 00:24:30,390
to multiple distinct cues so that you
 

1087
00:24:30,390 --> 00:24:32,029
to multiple distinct cues so that you
can have multiple applications each with

1088
00:24:32,029 --> 00:24:32,039
can have multiple applications each with
 

1089
00:24:32,039 --> 00:24:33,860
can have multiple applications each with
its own set of cues and the the Nick

1090
00:24:33,860 --> 00:24:33,870
its own set of cues and the the Nick
 

1091
00:24:33,870 --> 00:24:36,259
its own set of cues and the the Nick
knows about so it did it has required

1092
00:24:36,259 --> 00:24:36,269
knows about so it did it has required
 

1093
00:24:36,269 --> 00:24:41,450
knows about so it did it has required
modification of a lot of things okay

1094
00:24:41,450 --> 00:24:41,460
modification of a lot of things okay
 

1095
00:24:41,460 --> 00:24:47,180
modification of a lot of things okay
so sort of step one is is Colonel bypass

1096
00:24:47,180 --> 00:24:47,190
so sort of step one is is Colonel bypass
 

1097
00:24:47,190 --> 00:24:50,299
so sort of step one is is Colonel bypass
idea step two is even cleverer next and

1098
00:24:50,299 --> 00:24:50,309
idea step two is even cleverer next and
 

1099
00:24:50,309 --> 00:24:51,529
idea step two is even cleverer next and
now we're starting to get into hardware

1100
00:24:51,529 --> 00:24:51,539
now we're starting to get into hardware
 

1101
00:24:51,539 --> 00:24:54,909
now we're starting to get into hardware
that is not in wide use of the moment

1102
00:24:54,909 --> 00:24:54,919
that is not in wide use of the moment
 

1103
00:24:54,919 --> 00:24:59,029
that is not in wide use of the moment
you can buy it commercially but it's not

1104
00:24:59,029 --> 00:24:59,039
you can buy it commercially but it's not
 

1105
00:24:59,039 --> 00:25:03,100
you can buy it commercially but it's not
the default is this RDMA scheme which is

1106
00:25:03,100 --> 00:25:03,110
the default is this RDMA scheme which is
 

1107
00:25:03,110 --> 00:25:11,919
the default is this RDMA scheme which is
remote direct memory access and here

1108
00:25:11,919 --> 00:25:11,929
remote direct memory access and here
 

1109
00:25:11,929 --> 00:25:18,590
remote direct memory access and here
this is sort of special kind of network

1110
00:25:18,590 --> 00:25:18,600
this is sort of special kind of network
 

1111
00:25:18,600 --> 00:25:21,220
this is sort of special kind of network
interface cards that support remote

1112
00:25:21,220 --> 00:25:21,230
interface cards that support remote
 

1113
00:25:21,230 --> 00:25:28,460
interface cards that support remote
support our DMA so now we have an RDM a

1114
00:25:28,460 --> 00:25:28,470
support our DMA so now we have an RDM a
 

1115
00:25:28,470 --> 00:25:35,560
support our DMA so now we have an RDM a
neck both sides have to have these

1116
00:25:35,560 --> 00:25:35,570

 

1117
00:25:35,570 --> 00:25:38,389

special network interface cards so I'm

1118
00:25:38,389 --> 00:25:38,399
special network interface cards so I'm
 

1119
00:25:38,399 --> 00:25:39,889
special network interface cards so I'm
drawing these is connected by a cable in

1120
00:25:39,889 --> 00:25:39,899
drawing these is connected by a cable in
 

1121
00:25:39,899 --> 00:25:43,909
drawing these is connected by a cable in
fact always there's a switch here that

1122
00:25:43,909 --> 00:25:43,919
fact always there's a switch here that
 

1123
00:25:43,919 --> 00:25:47,470
fact always there's a switch here that
has connections to many different

1124
00:25:47,470 --> 00:25:47,480
has connections to many different
 

1125
00:25:47,480 --> 00:25:50,360
has connections to many different
servers and allows any server to talk to

1126
00:25:50,360 --> 00:25:50,370
servers and allows any server to talk to
 

1127
00:25:50,370 --> 00:25:52,100
servers and allows any server to talk to
any server okay so we have these RDMA

1128
00:25:52,100 --> 00:25:52,110
any server okay so we have these RDMA
 

1129
00:25:52,110 --> 00:25:55,190
any server okay so we have these RDMA
necks and we had again we have the

1130
00:25:55,190 --> 00:25:55,200
necks and we had again we have the
 

1131
00:25:55,200 --> 00:25:56,810
necks and we had again we have the
applications and application assist

1132
00:25:56,810 --> 00:25:56,820
applications and application assist
 

1133
00:25:56,820 --> 00:26:02,000
applications and application assist
memory and now though the application

1134
00:26:02,000 --> 00:26:02,010
memory and now though the application
 

1135
00:26:02,010 --> 00:26:06,549
memory and now though the application
can essentially send a special message

1136
00:26:06,549 --> 00:26:06,559
can essentially send a special message
 

1137
00:26:06,559 --> 00:26:10,250
can essentially send a special message
through the neck that asks so we have a

1138
00:26:10,250 --> 00:26:10,260
through the neck that asks so we have a
 

1139
00:26:10,260 --> 00:26:13,610
through the neck that asks so we have a
an application on the source host and

1140
00:26:13,610 --> 00:26:13,620
an application on the source host and
 

1141
00:26:13,620 --> 00:26:15,970
an application on the source host and
maybe we wouldn't call this the

1142
00:26:15,970 --> 00:26:15,980
maybe we wouldn't call this the
 

1143
00:26:15,980 --> 00:26:18,740
maybe we wouldn't call this the
destination host can send a special

1144
00:26:18,740 --> 00:26:18,750
destination host can send a special
 

1145
00:26:18,750 --> 00:26:22,100
destination host can send a special
message through the our DMA system that

1146
00:26:22,100 --> 00:26:22,110
message through the our DMA system that
 

1147
00:26:22,110 --> 00:26:24,889
message through the our DMA system that
tells this network interface card to

1148
00:26:24,889 --> 00:26:24,899
tells this network interface card to
 

1149
00:26:24,899 --> 00:26:28,909
tells this network interface card to
directly read or write a byte some bytes

1150
00:26:28,909 --> 00:26:28,919
directly read or write a byte some bytes
 

1151
00:26:28,919 --> 00:26:30,440
directly read or write a byte some bytes
of memory probably a cache line of

1152
00:26:30,440 --> 00:26:30,450
of memory probably a cache line of
 

1153
00:26:30,450 --> 00:26:32,180
of memory probably a cache line of
memory in

1154
00:26:32,180 --> 00:26:32,190
memory in
 

1155
00:26:32,190 --> 00:26:33,980
memory in
the target applications address space

1156
00:26:33,980 --> 00:26:33,990
the target applications address space
 

1157
00:26:33,990 --> 00:26:36,560
the target applications address space
directly so hardware and software on the

1158
00:26:36,560 --> 00:26:36,570
directly so hardware and software on the
 

1159
00:26:36,570 --> 00:26:38,210
directly so hardware and software on the
network interface controller are doing a

1160
00:26:38,210 --> 00:26:38,220
network interface controller are doing a
 

1161
00:26:38,220 --> 00:26:40,310
network interface controller are doing a
read and write read or write of the

1162
00:26:40,310 --> 00:26:40,320
read and write read or write of the
 

1163
00:26:40,320 --> 00:26:41,810
read and write read or write of the
application target applications memory

1164
00:26:41,810 --> 00:26:41,820
application target applications memory
 

1165
00:26:41,820 --> 00:26:44,720
application target applications memory
directly and then so we have a sort of

1166
00:26:44,720 --> 00:26:44,730
directly and then so we have a sort of
 

1167
00:26:44,730 --> 00:26:47,690
directly and then so we have a sort of
request going here that causes the read

1168
00:26:47,690 --> 00:26:47,700
request going here that causes the read
 

1169
00:26:47,700 --> 00:26:49,759
request going here that causes the read
or write and then sending the result

1170
00:26:49,759 --> 00:26:49,769
or write and then sending the result
 

1171
00:26:49,769 --> 00:26:55,330
or write and then sending the result
back to really two other incoming queue

1172
00:26:55,330 --> 00:26:55,340
back to really two other incoming queue
 

1173
00:26:55,340 --> 00:26:58,850
back to really two other incoming queue
on the source application and the cool

1174
00:26:58,850 --> 00:26:58,860
on the source application and the cool
 

1175
00:26:58,860 --> 00:27:01,220
on the source application and the cool
thing about this is that this computer's

1176
00:27:01,220 --> 00:27:01,230
thing about this is that this computer's
 

1177
00:27:01,230 --> 00:27:03,649
thing about this is that this computer's
the CPU this application didn't know

1178
00:27:03,649 --> 00:27:03,659
the CPU this application didn't know
 

1179
00:27:03,659 --> 00:27:06,440
the CPU this application didn't know
anything about the read or write the

1180
00:27:06,440 --> 00:27:06,450
anything about the read or write the
 

1181
00:27:06,450 --> 00:27:09,519
anything about the read or write the
read or write is executed completely in

1182
00:27:09,519 --> 00:27:09,529
read or write is executed completely in
 

1183
00:27:09,529 --> 00:27:11,990
read or write is executed completely in
firmware in the network interface card

1184
00:27:11,990 --> 00:27:12,000
firmware in the network interface card
 

1185
00:27:12,000 --> 00:27:13,789
firmware in the network interface card
so it's not there's no interrupts here

1186
00:27:13,789 --> 00:27:13,799
so it's not there's no interrupts here
 

1187
00:27:13,799 --> 00:27:15,320
so it's not there's no interrupts here
the application didn't have to think

1188
00:27:15,320 --> 00:27:15,330
the application didn't have to think
 

1189
00:27:15,330 --> 00:27:16,700
the application didn't have to think
about the request or think about

1190
00:27:16,700 --> 00:27:16,710
about the request or think about
 

1191
00:27:16,710 --> 00:27:18,919
about the request or think about
replying network interface card just

1192
00:27:18,919 --> 00:27:18,929
replying network interface card just
 

1193
00:27:18,929 --> 00:27:20,330
replying network interface card just
reads or writes a memory and sends a

1194
00:27:20,330 --> 00:27:20,340
reads or writes a memory and sends a
 

1195
00:27:20,340 --> 00:27:22,869
reads or writes a memory and sends a
result back to the source application

1196
00:27:22,869 --> 00:27:22,879
result back to the source application
 

1197
00:27:22,879 --> 00:27:25,460
result back to the source application
and this is much much lower overhead way

1198
00:27:25,460 --> 00:27:25,470
and this is much much lower overhead way
 

1199
00:27:25,470 --> 00:27:27,980
and this is much much lower overhead way
of getting at of all you need to do is

1200
00:27:27,980 --> 00:27:27,990
of getting at of all you need to do is
 

1201
00:27:27,990 --> 00:27:30,409
of getting at of all you need to do is
read or write memory and stuff in the

1202
00:27:30,409 --> 00:27:30,419
read or write memory and stuff in the
 

1203
00:27:30,419 --> 00:27:32,480
read or write memory and stuff in the
RAM of the target application this is a

1204
00:27:32,480 --> 00:27:32,490
RAM of the target application this is a
 

1205
00:27:32,490 --> 00:27:35,389
RAM of the target application this is a
much faster way of doing a simple read

1206
00:27:35,389 --> 00:27:35,399
much faster way of doing a simple read
 

1207
00:27:35,399 --> 00:27:37,759
much faster way of doing a simple read
or write than sending in our PC call

1208
00:27:37,759 --> 00:27:37,769
or write than sending in our PC call
 

1209
00:27:37,769 --> 00:27:42,759
or write than sending in our PC call
even with magic kernel bypass networking

1210
00:27:42,759 --> 00:27:42,769
even with magic kernel bypass networking
 

1211
00:27:42,769 --> 00:27:46,369
even with magic kernel bypass networking
it's a question does this mean that

1212
00:27:46,369 --> 00:27:46,379
it's a question does this mean that
 

1213
00:27:46,379 --> 00:27:48,950
it's a question does this mean that
already may always require kernel bypass

1214
00:27:48,950 --> 00:27:48,960
already may always require kernel bypass
 

1215
00:27:48,960 --> 00:27:54,379
already may always require kernel bypass
to work at all you know I don't know the

1216
00:27:54,379 --> 00:27:54,389
to work at all you know I don't know the
 

1217
00:27:54,389 --> 00:27:56,810
to work at all you know I don't know the
answer to that I think I've only ever

1218
00:27:56,810 --> 00:27:56,820
answer to that I think I've only ever
 

1219
00:27:56,820 --> 00:27:59,240
answer to that I think I've only ever
heard it used in conjunction with kernel

1220
00:27:59,240 --> 00:27:59,250
heard it used in conjunction with kernel
 

1221
00:27:59,250 --> 00:28:02,060
heard it used in conjunction with kernel
bypass cuz you know the people who are

1222
00:28:02,060 --> 00:28:02,070
bypass cuz you know the people who are
 

1223
00:28:02,070 --> 00:28:04,070
bypass cuz you know the people who are
interested in any of this or are

1224
00:28:04,070 --> 00:28:04,080
interested in any of this or are
 

1225
00:28:04,080 --> 00:28:07,039
interested in any of this or are
interested in it only for tremendous

1226
00:28:07,039 --> 00:28:07,049
interested in it only for tremendous
 

1227
00:28:07,049 --> 00:28:10,180
interested in it only for tremendous
performance and I think you would waste

1228
00:28:10,180 --> 00:28:10,190
performance and I think you would waste
 

1229
00:28:10,190 --> 00:28:12,529
performance and I think you would waste
you throw away a lot of the performance

1230
00:28:12,529 --> 00:28:12,539
you throw away a lot of the performance
 

1231
00:28:12,539 --> 00:28:14,269
you throw away a lot of the performance
I'm guessing you throw away a lot of the

1232
00:28:14,269 --> 00:28:14,279
I'm guessing you throw away a lot of the
 

1233
00:28:14,279 --> 00:28:16,610
I'm guessing you throw away a lot of the
performance win if you had to send the

1234
00:28:16,610 --> 00:28:16,620
performance win if you had to send the
 

1235
00:28:16,620 --> 00:28:22,249
performance win if you had to send the
requests through the kernel okay another

1236
00:28:22,249 --> 00:28:22,259
requests through the kernel okay another
 

1237
00:28:22,259 --> 00:28:31,640
requests through the kernel okay another
question that the the question notes

1238
00:28:31,640 --> 00:28:31,650
question that the the question notes
 

1239
00:28:31,650 --> 00:28:34,400
question that the the question notes
TCP software's TCP supports in order

1240
00:28:34,400 --> 00:28:34,410
TCP software's TCP supports in order
 

1241
00:28:34,410 --> 00:28:36,860
TCP software's TCP supports in order
delivery duplicate detection and a lot

1242
00:28:36,860 --> 00:28:36,870
delivery duplicate detection and a lot
 

1243
00:28:36,870 --> 00:28:38,960
delivery duplicate detection and a lot
of other excellent properties which you

1244
00:28:38,960 --> 00:28:38,970
of other excellent properties which you
 

1245
00:28:38,970 --> 00:28:41,780
of other excellent properties which you
actually need and so it would actually

1246
00:28:41,780 --> 00:28:41,790
actually need and so it would actually
 

1247
00:28:41,790 --> 00:28:44,060
actually need and so it would actually
be extremely awkward if this setup

1248
00:28:44,060 --> 00:28:44,070
be extremely awkward if this setup
 

1249
00:28:44,070 --> 00:28:48,530
be extremely awkward if this setup
sacrificed reliable delivery or in order

1250
00:28:48,530 --> 00:28:48,540
sacrificed reliable delivery or in order
 

1251
00:28:48,540 --> 00:28:50,690
sacrificed reliable delivery or in order
delivery and so the answer the question

1252
00:28:50,690 --> 00:28:50,700
delivery and so the answer the question
 

1253
00:28:50,700 --> 00:28:53,000
delivery and so the answer the question
is actually these are DMA NICs run their

1254
00:28:53,000 --> 00:28:53,010
is actually these are DMA NICs run their
 

1255
00:28:53,010 --> 00:28:56,450
is actually these are DMA NICs run their
own reliable sequenced protocol that's

1256
00:28:56,450 --> 00:28:56,460
own reliable sequenced protocol that's
 

1257
00:28:56,460 --> 00:28:59,630
own reliable sequenced protocol that's
like TCP although not TCP between the

1258
00:28:59,630 --> 00:28:59,640
like TCP although not TCP between the
 

1259
00:28:59,640 --> 00:29:02,780
like TCP although not TCP between the
necks and so when you ask your already

1260
00:29:02,780 --> 00:29:02,790
necks and so when you ask your already
 

1261
00:29:02,790 --> 00:29:04,760
necks and so when you ask your already
am a neck to do a read or write it'll

1262
00:29:04,760 --> 00:29:04,770
am a neck to do a read or write it'll
 

1263
00:29:04,770 --> 00:29:08,000
am a neck to do a read or write it'll
keep you transmitting until if the you

1264
00:29:08,000 --> 00:29:08,010
keep you transmitting until if the you
 

1265
00:29:08,010 --> 00:29:09,470
keep you transmitting until if the you
know if the request is lost and keep

1266
00:29:09,470 --> 00:29:09,480
know if the request is lost and keep
 

1267
00:29:09,480 --> 00:29:10,520
know if the request is lost and keep
reassurance meaning till it gets a

1268
00:29:10,520 --> 00:29:10,530
reassurance meaning till it gets a
 

1269
00:29:10,530 --> 00:29:12,800
reassurance meaning till it gets a
response and it actually tells the

1270
00:29:12,800 --> 00:29:12,810
response and it actually tells the
 

1271
00:29:12,810 --> 00:29:15,530
response and it actually tells the
originating software did the request

1272
00:29:15,530 --> 00:29:15,540
originating software did the request
 

1273
00:29:15,540 --> 00:29:17,120
originating software did the request
succeed or not so you get an

1274
00:29:17,120 --> 00:29:17,130
succeed or not so you get an
 

1275
00:29:17,130 --> 00:29:20,210
succeed or not so you get an
acknowledgment back finally so yeah you

1276
00:29:20,210 --> 00:29:20,220
acknowledgment back finally so yeah you
 

1277
00:29:20,220 --> 00:29:22,480
acknowledgment back finally so yeah you
know in fact have to sacrifice

1278
00:29:22,480 --> 00:29:22,490
know in fact have to sacrifice
 

1279
00:29:22,490 --> 00:29:25,700
know in fact have to sacrifice
most of TCP is good properties now this

1280
00:29:25,700 --> 00:29:25,710
most of TCP is good properties now this
 

1281
00:29:25,710 --> 00:29:28,520
most of TCP is good properties now this
stuff only works over a local network I

1282
00:29:28,520 --> 00:29:28,530
stuff only works over a local network I
 

1283
00:29:28,530 --> 00:29:32,000
stuff only works over a local network I
don't believe our DMA would be

1284
00:29:32,000 --> 00:29:32,010
don't believe our DMA would be
 

1285
00:29:32,010 --> 00:29:34,550
don't believe our DMA would be
satisfactory like between distant data

1286
00:29:34,550 --> 00:29:34,560
satisfactory like between distant data
 

1287
00:29:34,560 --> 00:29:38,930
satisfactory like between distant data
centers so there's all tuned up for very

1288
00:29:38,930 --> 00:29:38,940
centers so there's all tuned up for very
 

1289
00:29:38,940 --> 00:29:45,310
centers so there's all tuned up for very
low speed of light access okay a

1290
00:29:45,310 --> 00:29:45,320
low speed of light access okay a
 

1291
00:29:45,320 --> 00:29:47,960
low speed of light access okay a
particular piece of jargon that the

1292
00:29:47,960 --> 00:29:47,970
particular piece of jargon that the
 

1293
00:29:47,970 --> 00:29:56,140
particular piece of jargon that the
paper uses is one-sided our DMA and

1294
00:29:56,140 --> 00:29:56,150
paper uses is one-sided our DMA and
 

1295
00:29:56,150 --> 00:29:57,860
paper uses is one-sided our DMA and
that's basically what I've just

1296
00:29:57,860 --> 00:29:57,870
that's basically what I've just
 

1297
00:29:57,870 --> 00:30:01,550
that's basically what I've just
mentioned when application uses our DMA

1298
00:30:01,550 --> 00:30:01,560
mentioned when application uses our DMA
 

1299
00:30:01,560 --> 00:30:02,690
mentioned when application uses our DMA
to read or write the memory of another

1300
00:30:02,690 --> 00:30:02,700
to read or write the memory of another
 

1301
00:30:02,700 --> 00:30:06,670
to read or write the memory of another
that's one site our DMA now in fact farm

1302
00:30:06,670 --> 00:30:06,680
that's one site our DMA now in fact farm
 

1303
00:30:06,680 --> 00:30:13,220
that's one site our DMA now in fact farm
uses our DMA to send messages in an RPC

1304
00:30:13,220 --> 00:30:13,230
uses our DMA to send messages in an RPC
 

1305
00:30:13,230 --> 00:30:15,860
uses our DMA to send messages in an RPC
like protocol so in fact sometimes farm

1306
00:30:15,860 --> 00:30:15,870
like protocol so in fact sometimes farm
 

1307
00:30:15,870 --> 00:30:18,290
like protocol so in fact sometimes farm
directly reads with one sided our DMA

1308
00:30:18,290 --> 00:30:18,300
directly reads with one sided our DMA
 

1309
00:30:18,300 --> 00:30:20,600
directly reads with one sided our DMA
but sometimes what farm is using our DMA

1310
00:30:20,600 --> 00:30:20,610
but sometimes what farm is using our DMA
 

1311
00:30:20,610 --> 00:30:23,810
but sometimes what farm is using our DMA
for is to append a message to an

1312
00:30:23,810 --> 00:30:23,820
for is to append a message to an
 

1313
00:30:23,820 --> 00:30:26,330
for is to append a message to an
incoming message queue inside the target

1314
00:30:26,330 --> 00:30:26,340
incoming message queue inside the target
 

1315
00:30:26,340 --> 00:30:27,800
incoming message queue inside the target
so sometimes what the what the

1316
00:30:27,800 --> 00:30:27,810
so sometimes what the what the
 

1317
00:30:27,810 --> 00:30:31,580
so sometimes what the what the
well actually always with writes what

1318
00:30:31,580 --> 00:30:31,590
well actually always with writes what
 

1319
00:30:31,590 --> 00:30:33,440
well actually always with writes what
farm is actually doing is using our DMA

1320
00:30:33,440 --> 00:30:33,450
farm is actually doing is using our DMA
 

1321
00:30:33,450 --> 00:30:38,030
farm is actually doing is using our DMA
to write to append a new message to an

1322
00:30:38,030 --> 00:30:38,040
to write to append a new message to an
 

1323
00:30:38,040 --> 00:30:40,460
to write to append a new message to an
incoming queue in the target which the

1324
00:30:40,460 --> 00:30:40,470
incoming queue in the target which the
 

1325
00:30:40,470 --> 00:30:42,170
incoming queue in the target which the
target will pull since there's nobody

1326
00:30:42,170 --> 00:30:42,180
target will pull since there's nobody
 

1327
00:30:42,180 --> 00:30:45,169
target will pull since there's nobody
interrupts here the way target

1328
00:30:45,169 --> 00:30:45,179
interrupts here the way target
 

1329
00:30:45,179 --> 00:30:47,629
interrupts here the way target
the way the destination of a message

1330
00:30:47,629 --> 00:30:47,639
the way the destination of a message
 

1331
00:30:47,639 --> 00:30:49,519
the way the destination of a message
like this knows I got the messages that

1332
00:30:49,519 --> 00:30:49,529
like this knows I got the messages that
 

1333
00:30:49,529 --> 00:30:52,279
like this knows I got the messages that
periodically checks one of these keys

1334
00:30:52,279 --> 00:30:52,289
periodically checks one of these keys
 

1335
00:30:52,289 --> 00:30:53,599
periodically checks one of these keys
queues and memory to see how have I

1336
00:30:53,599 --> 00:30:53,609
queues and memory to see how have I
 

1337
00:30:53,609 --> 00:30:55,629
queues and memory to see how have I
gotten a recent message from anyone

1338
00:30:55,629 --> 00:30:55,639
gotten a recent message from anyone
 

1339
00:30:55,639 --> 00:30:58,070
gotten a recent message from anyone
okay so once I did already MA is just to

1340
00:30:58,070 --> 00:30:58,080
okay so once I did already MA is just to
 

1341
00:30:58,080 --> 00:31:00,139
okay so once I did already MA is just to
read or write but using our DMA to send

1342
00:31:00,139 --> 00:31:00,149
read or write but using our DMA to send
 

1343
00:31:00,149 --> 00:31:02,209
read or write but using our DMA to send
a message or append either to a message

1344
00:31:02,209 --> 00:31:02,219
a message or append either to a message
 

1345
00:31:02,219 --> 00:31:03,409
a message or append either to a message
queue or to a log

1346
00:31:03,409 --> 00:31:03,419
queue or to a log
 

1347
00:31:03,419 --> 00:31:06,379
queue or to a log
sometimes farm appends messages or log

1348
00:31:06,379 --> 00:31:06,389
sometimes farm appends messages or log
 

1349
00:31:06,389 --> 00:31:09,049
sometimes farm appends messages or log
entries to a log and another server also

1350
00:31:09,049 --> 00:31:09,059
entries to a log and another server also
 

1351
00:31:09,059 --> 00:31:11,419
entries to a log and another server also
uses our DMA and you know this memory

1352
00:31:11,419 --> 00:31:11,429
uses our DMA and you know this memory
 

1353
00:31:11,429 --> 00:31:15,039
uses our DMA and you know this memory
that's being written into is all

1354
00:31:15,039 --> 00:31:15,049
that's being written into is all
 

1355
00:31:15,049 --> 00:31:17,239
that's being written into is all
non-volatile so all of it the message

1356
00:31:17,239 --> 00:31:17,249
non-volatile so all of it the message
 

1357
00:31:17,249 --> 00:31:20,180
non-volatile so all of it the message
queues it's all written to disk if

1358
00:31:20,180 --> 00:31:20,190
queues it's all written to disk if
 

1359
00:31:20,190 --> 00:31:24,739
queues it's all written to disk if
there's a power failure the performance

1360
00:31:24,739 --> 00:31:24,749
there's a power failure the performance
 

1361
00:31:24,749 --> 00:31:29,930
there's a power failure the performance
of this is the figure 2 shows that you

1362
00:31:29,930 --> 00:31:29,940
of this is the figure 2 shows that you
 

1363
00:31:29,940 --> 00:31:34,159
of this is the figure 2 shows that you
can get 10 million small our DMA reads

1364
00:31:34,159 --> 00:31:34,169
can get 10 million small our DMA reads
 

1365
00:31:34,169 --> 00:31:37,570
can get 10 million small our DMA reads
and writes per second which is fantastic

1366
00:31:37,570 --> 00:31:37,580
and writes per second which is fantastic
 

1367
00:31:37,580 --> 00:31:40,729
and writes per second which is fantastic
far far faster than you can send

1368
00:31:40,729 --> 00:31:40,739
far far faster than you can send
 

1369
00:31:40,739 --> 00:31:43,969
far far faster than you can send
messages like our pcs using TCP and the

1370
00:31:43,969 --> 00:31:43,979
messages like our pcs using TCP and the
 

1371
00:31:43,979 --> 00:31:46,129
messages like our pcs using TCP and the
latency of using our DMA to do a simple

1372
00:31:46,129 --> 00:31:46,139
latency of using our DMA to do a simple
 

1373
00:31:46,139 --> 00:31:48,969
latency of using our DMA to do a simple
read or write is about 5 microseconds so

1374
00:31:48,969 --> 00:31:48,979
read or write is about 5 microseconds so
 

1375
00:31:48,979 --> 00:31:54,019
read or write is about 5 microseconds so
again this is you know very very short 5

1376
00:31:54,019 --> 00:31:54,029
again this is you know very very short 5
 

1377
00:31:54,029 --> 00:31:56,659
again this is you know very very short 5
microseconds is it's slower than

1378
00:31:56,659 --> 00:31:56,669
microseconds is it's slower than
 

1379
00:31:56,669 --> 00:31:59,779
microseconds is it's slower than
accessing your own local memory but it's

1380
00:31:59,779 --> 00:31:59,789
accessing your own local memory but it's
 

1381
00:31:59,789 --> 00:32:01,369
accessing your own local memory but it's
faster than sort of anything else people

1382
00:32:01,369 --> 00:32:01,379
faster than sort of anything else people
 

1383
00:32:01,379 --> 00:32:05,619
faster than sort of anything else people
do in networks ok so this is sort of a

1384
00:32:05,619 --> 00:32:05,629
do in networks ok so this is sort of a
 

1385
00:32:05,629 --> 00:32:07,940
do in networks ok so this is sort of a
promise there's this fabulous our DMA

1386
00:32:07,940 --> 00:32:07,950
promise there's this fabulous our DMA
 

1387
00:32:07,950 --> 00:32:10,070
promise there's this fabulous our DMA
technology that came out a while ago

1388
00:32:10,070 --> 00:32:10,080
technology that came out a while ago
 

1389
00:32:10,080 --> 00:32:11,899
technology that came out a while ago
that at the farm people wanted to

1390
00:32:11,899 --> 00:32:11,909
that at the farm people wanted to
 

1391
00:32:11,909 --> 00:32:15,589
that at the farm people wanted to
exploit you know the coolest possible

1392
00:32:15,589 --> 00:32:15,599
exploit you know the coolest possible
 

1393
00:32:15,599 --> 00:32:17,209
exploit you know the coolest possible
thing that you could imagine doing with

1394
00:32:17,209 --> 00:32:17,219
thing that you could imagine doing with
 

1395
00:32:17,219 --> 00:32:20,810
thing that you could imagine doing with
this is using our DMA one sign it

1396
00:32:20,810 --> 00:32:20,820
this is using our DMA one sign it
 

1397
00:32:20,820 --> 00:32:23,479
this is using our DMA one sign it
already am a reason rights to directly

1398
00:32:23,479 --> 00:32:23,489
already am a reason rights to directly
 

1399
00:32:23,489 --> 00:32:26,180
already am a reason rights to directly
do all the reason writes a records

1400
00:32:26,180 --> 00:32:26,190
do all the reason writes a records
 

1401
00:32:26,190 --> 00:32:28,549
do all the reason writes a records
stored in database servers memory so

1402
00:32:28,549 --> 00:32:28,559
stored in database servers memory so
 

1403
00:32:28,559 --> 00:32:29,779
stored in database servers memory so
wouldn't be fantastic if we could just

1404
00:32:29,779 --> 00:32:29,789
wouldn't be fantastic if we could just
 

1405
00:32:29,789 --> 00:32:32,629
wouldn't be fantastic if we could just
never talk to the database server CPU or

1406
00:32:32,629 --> 00:32:32,639
never talk to the database server CPU or
 

1407
00:32:32,639 --> 00:32:34,879
never talk to the database server CPU or
software but just get at the data that

1408
00:32:34,879 --> 00:32:34,889
software but just get at the data that
 

1409
00:32:34,889 --> 00:32:37,099
software but just get at the data that
we need you know in five microseconds a

1410
00:32:37,099 --> 00:32:37,109
we need you know in five microseconds a
 

1411
00:32:37,109 --> 00:32:40,729
we need you know in five microseconds a
pop using direct one-sided our DMA

1412
00:32:40,729 --> 00:32:40,739
pop using direct one-sided our DMA
 

1413
00:32:40,739 --> 00:32:43,249
pop using direct one-sided our DMA
Reiser writes so in a sense this paper

1414
00:32:43,249 --> 00:32:43,259
Reiser writes so in a sense this paper
 

1415
00:32:43,259 --> 00:32:45,739
Reiser writes so in a sense this paper
is about you know you you start there

1416
00:32:45,739 --> 00:32:45,749
is about you know you you start there
 

1417
00:32:45,749 --> 00:32:49,009
is about you know you you start there
what do you have to do to actually build

1418
00:32:49,009 --> 00:32:49,019
what do you have to do to actually build
 

1419
00:32:49,019 --> 00:32:52,999
what do you have to do to actually build
something useful so an interesting

1420
00:32:52,999 --> 00:32:53,009
something useful so an interesting
 

1421
00:32:53,009 --> 00:32:56,229
something useful so an interesting
question by the way is could you in fact

1422
00:32:56,229 --> 00:32:56,239
question by the way is could you in fact
 

1423
00:32:56,239 --> 00:32:58,400
question by the way is could you in fact
implement transactions

1424
00:32:58,400 --> 00:32:58,410
implement transactions
 

1425
00:32:58,410 --> 00:33:01,610
implement transactions
using one-sided RDMA that is you know

1426
00:33:01,610 --> 00:33:01,620
using one-sided RDMA that is you know
 

1427
00:33:01,620 --> 00:33:03,530
using one-sided RDMA that is you know
anything we wanted to read or write data

1428
00:33:03,530 --> 00:33:03,540
anything we wanted to read or write data
 

1429
00:33:03,540 --> 00:33:07,010
anything we wanted to read or write data
in server the only use already may and

1430
00:33:07,010 --> 00:33:07,020
in server the only use already may and
 

1431
00:33:07,020 --> 00:33:10,100
in server the only use already may and
never actually send messages that have

1432
00:33:10,100 --> 00:33:10,110
never actually send messages that have
 

1433
00:33:10,110 --> 00:33:13,750
never actually send messages that have
to be interpreted by the server software

1434
00:33:13,750 --> 00:33:13,760
to be interpreted by the server software
 

1435
00:33:13,760 --> 00:33:16,820
to be interpreted by the server software
it's worth thinking about

1436
00:33:16,820 --> 00:33:16,830
it's worth thinking about
 

1437
00:33:16,830 --> 00:33:19,940
it's worth thinking about
in a sense farm is answering that

1438
00:33:19,940 --> 00:33:19,950
in a sense farm is answering that
 

1439
00:33:19,950 --> 00:33:22,640
in a sense farm is answering that
question with a no because that's not

1440
00:33:22,640 --> 00:33:22,650
question with a no because that's not
 

1441
00:33:22,650 --> 00:33:25,940
question with a no because that's not
really how farm works but but it is

1442
00:33:25,940 --> 00:33:25,950
really how farm works but but it is
 

1443
00:33:25,950 --> 00:33:28,100
really how farm works but but it is
absolutely worth thinking how come

1444
00:33:28,100 --> 00:33:28,110
absolutely worth thinking how come
 

1445
00:33:28,110 --> 00:33:31,760
absolutely worth thinking how come
pure one-sided RDMA couldn't be made to

1446
00:33:31,760 --> 00:33:31,770
pure one-sided RDMA couldn't be made to
 

1447
00:33:31,770 --> 00:33:37,610
pure one-sided RDMA couldn't be made to
work alright so the challenges to using

1448
00:33:37,610 --> 00:33:37,620
work alright so the challenges to using
 

1449
00:33:37,620 --> 00:33:42,470
work alright so the challenges to using
our DMA in a transactional system that

1450
00:33:42,470 --> 00:33:42,480
our DMA in a transactional system that
 

1451
00:33:42,480 --> 00:33:46,880
our DMA in a transactional system that
has replication and sharding so that

1452
00:33:46,880 --> 00:33:46,890
has replication and sharding so that
 

1453
00:33:46,890 --> 00:33:48,950
has replication and sharding so that
that's the challenge we have is how to

1454
00:33:48,950 --> 00:33:48,960
that's the challenge we have is how to
 

1455
00:33:48,960 --> 00:33:50,450
that's the challenge we have is how to
combine already made with transactions

1456
00:33:50,450 --> 00:33:50,460
combine already made with transactions
 

1457
00:33:50,460 --> 00:33:52,730
combine already made with transactions
charting and replication because you

1458
00:33:52,730 --> 00:33:52,740
charting and replication because you
 

1459
00:33:52,740 --> 00:33:54,350
charting and replication because you
need to have sharding and transactions

1460
00:33:54,350 --> 00:33:54,360
need to have sharding and transactions
 

1461
00:33:54,360 --> 00:33:56,930
need to have sharding and transactions
replication to have a seriously useful

1462
00:33:56,930 --> 00:33:56,940
replication to have a seriously useful
 

1463
00:33:56,940 --> 00:33:59,750
replication to have a seriously useful
database system it turns out that all

1464
00:33:59,750 --> 00:33:59,760
database system it turns out that all
 

1465
00:33:59,760 --> 00:34:02,240
database system it turns out that all
the protocols we've seen so far for

1466
00:34:02,240 --> 00:34:02,250
the protocols we've seen so far for
 

1467
00:34:02,250 --> 00:34:04,310
the protocols we've seen so far for
doing transactions replication require

1468
00:34:04,310 --> 00:34:04,320
doing transactions replication require
 

1469
00:34:04,320 --> 00:34:06,800
doing transactions replication require
active participation by the server

1470
00:34:06,800 --> 00:34:06,810
active participation by the server
 

1471
00:34:06,810 --> 00:34:11,659
active participation by the server
software that is the server has to be in

1472
00:34:11,659 --> 00:34:11,669
software that is the server has to be in
 

1473
00:34:11,669 --> 00:34:13,100
software that is the server has to be in
all the protocols we've seen so far the

1474
00:34:13,100 --> 00:34:13,110
all the protocols we've seen so far the
 

1475
00:34:13,110 --> 00:34:15,140
all the protocols we've seen so far the
server's actively involved in helping

1476
00:34:15,140 --> 00:34:15,150
server's actively involved in helping
 

1477
00:34:15,150 --> 00:34:17,360
server's actively involved in helping
the clients get at read or write the

1478
00:34:17,360 --> 00:34:17,370
the clients get at read or write the
 

1479
00:34:17,370 --> 00:34:21,260
the clients get at read or write the
data so for example in the two-phase

1480
00:34:21,260 --> 00:34:21,270
data so for example in the two-phase
 

1481
00:34:21,270 --> 00:34:23,960
data so for example in the two-phase
commit schemes we've seen the server has

1482
00:34:23,960 --> 00:34:23,970
commit schemes we've seen the server has
 

1483
00:34:23,970 --> 00:34:25,790
commit schemes we've seen the server has
to do things like decide whether a

1484
00:34:25,790 --> 00:34:25,800
to do things like decide whether a
 

1485
00:34:25,800 --> 00:34:27,950
to do things like decide whether a
record is locked and if it's not walk

1486
00:34:27,950 --> 00:34:27,960
record is locked and if it's not walk
 

1487
00:34:27,960 --> 00:34:31,520
record is locked and if it's not walk
set the lock on it right it's not clear

1488
00:34:31,520 --> 00:34:31,530
set the lock on it right it's not clear
 

1489
00:34:31,530 --> 00:34:35,570
set the lock on it right it's not clear
how you could do that with our DMA the

1490
00:34:35,570 --> 00:34:35,580
how you could do that with our DMA the
 

1491
00:34:35,580 --> 00:34:37,340
how you could do that with our DMA the
server has to do things like in spanner

1492
00:34:37,340 --> 00:34:37,350
server has to do things like in spanner
 

1493
00:34:37,350 --> 00:34:39,050
server has to do things like in spanner
you know there's all these versions it

1494
00:34:39,050 --> 00:34:39,060
you know there's all these versions it
 

1495
00:34:39,060 --> 00:34:40,460
you know there's all these versions it
was the server that was thinking about

1496
00:34:40,460 --> 00:34:40,470
was the server that was thinking about
 

1497
00:34:40,470 --> 00:34:43,130
was the server that was thinking about
how to find the latest version similarly

1498
00:34:43,130 --> 00:34:43,140
how to find the latest version similarly
 

1499
00:34:43,140 --> 00:34:45,350
how to find the latest version similarly
if we have transactions in two-phase

1500
00:34:45,350 --> 00:34:45,360
if we have transactions in two-phase
 

1501
00:34:45,360 --> 00:34:45,890
if we have transactions in two-phase
commit

1502
00:34:45,890 --> 00:34:45,900
commit
 

1503
00:34:45,900 --> 00:34:47,990
commit
data on the server it's not just data

1504
00:34:47,990 --> 00:34:48,000
data on the server it's not just data
 

1505
00:34:48,000 --> 00:34:50,360
data on the server it's not just data
there's committed data there's data

1506
00:34:50,360 --> 00:34:50,370
there's committed data there's data
 

1507
00:34:50,370 --> 00:34:52,490
there's committed data there's data
that's been written but hasn't committed

1508
00:34:52,490 --> 00:34:52,500
that's been written but hasn't committed
 

1509
00:34:52,500 --> 00:34:54,919
that's been written but hasn't committed
yet and again traditionally it's the

1510
00:34:54,919 --> 00:34:54,929
yet and again traditionally it's the
 

1511
00:34:54,929 --> 00:34:58,510
yet and again traditionally it's the
server that sorts out whether data

1512
00:34:58,510 --> 00:34:58,520
server that sorts out whether data
 

1513
00:34:58,520 --> 00:35:00,800
server that sorts out whether data
recently updated data is committed yet

1514
00:35:00,800 --> 00:35:00,810
recently updated data is committed yet
 

1515
00:35:00,810 --> 00:35:01,940
recently updated data is committed yet
and that's to sort of protect the

1516
00:35:01,940 --> 00:35:01,950
and that's to sort of protect the
 

1517
00:35:01,950 --> 00:35:03,890
and that's to sort of protect the
clients from you know prevent them from

1518
00:35:03,890 --> 00:35:03,900
clients from you know prevent them from
 

1519
00:35:03,900 --> 00:35:06,830
clients from you know prevent them from
seeing data that's locked or not yet

1520
00:35:06,830 --> 00:35:06,840
seeing data that's locked or not yet
 

1521
00:35:06,840 --> 00:35:08,840
seeing data that's locked or not yet
known to be committed and what that

1522
00:35:08,840 --> 00:35:08,850
known to be committed and what that
 

1523
00:35:08,850 --> 00:35:10,580
known to be committed and what that
means is that without some clever

1524
00:35:10,580 --> 00:35:10,590
means is that without some clever
 

1525
00:35:10,590 --> 00:35:12,140
means is that without some clever
thought

1526
00:35:12,140 --> 00:35:12,150
thought
 

1527
00:35:12,150 --> 00:35:15,410
thought
RDMA or one-sided pure use of our DME

1528
00:35:15,410 --> 00:35:15,420
RDMA or one-sided pure use of our DME
 

1529
00:35:15,420 --> 00:35:18,540
RDMA or one-sided pure use of our DME
one-sided RDMA doesn't seem to be

1530
00:35:18,540 --> 00:35:18,550
one-sided RDMA doesn't seem to be
 

1531
00:35:18,550 --> 00:35:21,059
one-sided RDMA doesn't seem to be
immediately compatible with transactions

1532
00:35:21,059 --> 00:35:21,069
immediately compatible with transactions
 

1533
00:35:21,069 --> 00:35:26,400
immediately compatible with transactions
and replication and indeed farm while

1534
00:35:26,400 --> 00:35:26,410
and replication and indeed farm while
 

1535
00:35:26,410 --> 00:35:29,309
and replication and indeed farm while
farm does use one-sided it reads to get

1536
00:35:29,309 --> 00:35:29,319
farm does use one-sided it reads to get
 

1537
00:35:29,319 --> 00:35:32,010
farm does use one-sided it reads to get
out directly at data in the database it

1538
00:35:32,010 --> 00:35:32,020
out directly at data in the database it
 

1539
00:35:32,020 --> 00:35:34,980
out directly at data in the database it
is not not able to use one-sided rights

1540
00:35:34,980 --> 00:35:34,990
is not not able to use one-sided rights
 

1541
00:35:34,990 --> 00:35:43,290
is not not able to use one-sided rights
to modify the data okay so this leads us

1542
00:35:43,290 --> 00:35:43,300
to modify the data okay so this leads us
 

1543
00:35:43,300 --> 00:35:46,680
to modify the data okay so this leads us
to optimistic concurrency control it

1544
00:35:46,680 --> 00:35:46,690
to optimistic concurrency control it
 

1545
00:35:46,690 --> 00:35:54,210
to optimistic concurrency control it
turns out that the main trick in a sense

1546
00:35:54,210 --> 00:35:54,220
turns out that the main trick in a sense
 

1547
00:35:54,220 --> 00:35:59,400
turns out that the main trick in a sense
that farm uses to allow it both use RDMA

1548
00:35:59,400 --> 00:35:59,410
that farm uses to allow it both use RDMA
 

1549
00:35:59,410 --> 00:36:02,150
that farm uses to allow it both use RDMA
and get transactions is by using

1550
00:36:02,150 --> 00:36:02,160
and get transactions is by using
 

1551
00:36:02,160 --> 00:36:05,849
and get transactions is by using
optimistic concurrency control so if you

1552
00:36:05,849 --> 00:36:05,859
optimistic concurrency control so if you
 

1553
00:36:05,859 --> 00:36:12,589
optimistic concurrency control so if you
remember I mentioned earlier that

1554
00:36:12,589 --> 00:36:12,599
remember I mentioned earlier that
 

1555
00:36:12,599 --> 00:36:14,760
remember I mentioned earlier that
concurrency control schemes are kind of

1556
00:36:14,760 --> 00:36:14,770
concurrency control schemes are kind of
 

1557
00:36:14,770 --> 00:36:18,950
concurrency control schemes are kind of
divided into two broad categories

1558
00:36:18,950 --> 00:36:18,960

 

1559
00:36:18,960 --> 00:36:23,670

pessimistic and optimistic pessimistic

1560
00:36:23,670 --> 00:36:23,680
pessimistic and optimistic pessimistic
 

1561
00:36:23,680 --> 00:36:28,349
pessimistic and optimistic pessimistic
schemes use locks and the idea is that

1562
00:36:28,349 --> 00:36:28,359
schemes use locks and the idea is that
 

1563
00:36:28,359 --> 00:36:30,120
schemes use locks and the idea is that
if you have a transaction that's gonna

1564
00:36:30,120 --> 00:36:30,130
if you have a transaction that's gonna
 

1565
00:36:30,130 --> 00:36:32,400
if you have a transaction that's gonna
read or write some data before you can

1566
00:36:32,400 --> 00:36:32,410
read or write some data before you can
 

1567
00:36:32,410 --> 00:36:34,049
read or write some data before you can
read or write the data or look at it at

1568
00:36:34,049 --> 00:36:34,059
read or write the data or look at it at
 

1569
00:36:34,059 --> 00:36:36,720
read or write the data or look at it at
all it must acquire a lock and it must

1570
00:36:36,720 --> 00:36:36,730
all it must acquire a lock and it must
 

1571
00:36:36,730 --> 00:36:41,220
all it must acquire a lock and it must
wait for the lock and so you read about

1572
00:36:41,220 --> 00:36:41,230
wait for the lock and so you read about
 

1573
00:36:41,230 --> 00:36:45,329
wait for the lock and so you read about
two-phase locking for example in that

1574
00:36:45,329 --> 00:36:45,339
two-phase locking for example in that
 

1575
00:36:45,339 --> 00:36:48,390
two-phase locking for example in that
reading from 633 so before you use data

1576
00:36:48,390 --> 00:36:48,400
reading from 633 so before you use data
 

1577
00:36:48,400 --> 00:36:50,849
reading from 633 so before you use data
you have to lock it and you hold the

1578
00:36:50,849 --> 00:36:50,859
you have to lock it and you hold the
 

1579
00:36:50,859 --> 00:36:52,549
you have to lock it and you hold the
lock for the entire duration of the

1580
00:36:52,549 --> 00:36:52,559
lock for the entire duration of the
 

1581
00:36:52,559 --> 00:36:54,720
lock for the entire duration of the
transaction and only if the transaction

1582
00:36:54,720 --> 00:36:54,730
transaction and only if the transaction
 

1583
00:36:54,730 --> 00:36:56,520
transaction and only if the transaction
commits or aborts do you release the

1584
00:36:56,520 --> 00:36:56,530
commits or aborts do you release the
 

1585
00:36:56,530 --> 00:37:01,230
commits or aborts do you release the
lock and if there's conflicts because

1586
00:37:01,230 --> 00:37:01,240
lock and if there's conflicts because
 

1587
00:37:01,240 --> 00:37:05,370
lock and if there's conflicts because
two transactions want to write the same

1588
00:37:05,370 --> 00:37:05,380
two transactions want to write the same
 

1589
00:37:05,380 --> 00:37:06,750
two transactions want to write the same
data at the same time or one wants to

1590
00:37:06,750 --> 00:37:06,760
data at the same time or one wants to
 

1591
00:37:06,760 --> 00:37:08,130
data at the same time or one wants to
read and one that monster right they

1592
00:37:08,130 --> 00:37:08,140
read and one that monster right they
 

1593
00:37:08,140 --> 00:37:10,380
read and one that monster right they
can't do it at the same time one of them

1594
00:37:10,380 --> 00:37:10,390
can't do it at the same time one of them
 

1595
00:37:10,390 --> 00:37:12,210
can't do it at the same time one of them
has to block or all but one of the

1596
00:37:12,210 --> 00:37:12,220
has to block or all but one of the
 

1597
00:37:12,220 --> 00:37:13,620
has to block or all but one of the
transactions that went to you some data

1598
00:37:13,620 --> 00:37:13,630
transactions that went to you some data
 

1599
00:37:13,630 --> 00:37:15,420
transactions that went to you some data
missed a block wait for the lock to be

1600
00:37:15,420 --> 00:37:15,430
missed a block wait for the lock to be
 

1601
00:37:15,430 --> 00:37:17,910
missed a block wait for the lock to be
released um and of course this locking

1602
00:37:17,910 --> 00:37:17,920
released um and of course this locking
 

1603
00:37:17,920 --> 00:37:20,099
released um and of course this locking
scheme is the fact that the data has to

1604
00:37:20,099 --> 00:37:20,109
scheme is the fact that the data has to
 

1605
00:37:20,109 --> 00:37:21,900
scheme is the fact that the data has to
be locked and that somebody has to keep

1606
00:37:21,900 --> 00:37:21,910
be locked and that somebody has to keep
 

1607
00:37:21,910 --> 00:37:23,880
be locked and that somebody has to keep
track of who owns the lock and when the

1608
00:37:23,880 --> 00:37:23,890
track of who owns the lock and when the
 

1609
00:37:23,890 --> 00:37:27,609
track of who owns the lock and when the
lock is released etcetera

1610
00:37:27,609 --> 00:37:27,619

 

1611
00:37:27,619 --> 00:37:30,609

this is one thing that makes our DMA

1612
00:37:30,609 --> 00:37:30,619
this is one thing that makes our DMA
 

1613
00:37:30,619 --> 00:37:33,319
this is one thing that makes our DMA
it's not clear how you can do rights or

1614
00:37:33,319 --> 00:37:33,329
it's not clear how you can do rights or
 

1615
00:37:33,329 --> 00:37:35,599
it's not clear how you can do rights or
even reads using our DMA in a locking

1616
00:37:35,599 --> 00:37:35,609
even reads using our DMA in a locking
 

1617
00:37:35,609 --> 00:37:37,490
even reads using our DMA in a locking
scheme because somebody has to enforce

1618
00:37:37,490 --> 00:37:37,500
scheme because somebody has to enforce
 

1619
00:37:37,500 --> 00:37:40,279
scheme because somebody has to enforce
the locks I'm being a little tentative

1620
00:37:40,279 --> 00:37:40,289
the locks I'm being a little tentative
 

1621
00:37:40,289 --> 00:37:42,349
the locks I'm being a little tentative
about this because I suspect that with

1622
00:37:42,349 --> 00:37:42,359
about this because I suspect that with
 

1623
00:37:42,359 --> 00:37:45,400
about this because I suspect that with
more clever our DMA NICs that could

1624
00:37:45,400 --> 00:37:45,410
more clever our DMA NICs that could
 

1625
00:37:45,410 --> 00:37:49,450
more clever our DMA NICs that could
support a wider range of operations like

1626
00:37:49,450 --> 00:37:49,460
support a wider range of operations like
 

1627
00:37:49,460 --> 00:37:51,349
support a wider range of operations like
atomic test and set

1628
00:37:51,349 --> 00:37:51,359
atomic test and set
 

1629
00:37:51,359 --> 00:37:54,019
atomic test and set
you might someday be able to do a

1630
00:37:54,019 --> 00:37:54,029
you might someday be able to do a
 

1631
00:37:54,029 --> 00:37:58,480
you might someday be able to do a
locking scheme with pure one-sided RDMA

1632
00:37:58,480 --> 00:37:58,490
locking scheme with pure one-sided RDMA
 

1633
00:37:58,490 --> 00:38:02,839
locking scheme with pure one-sided RDMA
but farm doesn't do it okay so what farm

1634
00:38:02,839 --> 00:38:02,849
but farm doesn't do it okay so what farm
 

1635
00:38:02,849 --> 00:38:04,789
but farm doesn't do it okay so what farm
actually uses as an optimistic scheme

1636
00:38:04,789 --> 00:38:04,799
actually uses as an optimistic scheme
 

1637
00:38:04,799 --> 00:38:08,180
actually uses as an optimistic scheme
and here in an optimistic scheme you can

1638
00:38:08,180 --> 00:38:08,190
and here in an optimistic scheme you can
 

1639
00:38:08,190 --> 00:38:12,710
and here in an optimistic scheme you can
use at least you can read without

1640
00:38:12,710 --> 00:38:12,720
use at least you can read without
 

1641
00:38:12,720 --> 00:38:18,650
use at least you can read without
locking you just read the data you don't

1642
00:38:18,650 --> 00:38:18,660
locking you just read the data you don't
 

1643
00:38:18,660 --> 00:38:20,450
locking you just read the data you don't
know yet whether you are allowed to read

1644
00:38:20,450 --> 00:38:20,460
know yet whether you are allowed to read
 

1645
00:38:20,460 --> 00:38:21,799
know yet whether you are allowed to read
the data or whether somebody else is in

1646
00:38:21,799 --> 00:38:21,809
the data or whether somebody else is in
 

1647
00:38:21,809 --> 00:38:23,450
the data or whether somebody else is in
the model middle of modifying it or

1648
00:38:23,450 --> 00:38:23,460
the model middle of modifying it or
 

1649
00:38:23,460 --> 00:38:25,490
the model middle of modifying it or
anything you just read the data and a

1650
00:38:25,490 --> 00:38:25,500
anything you just read the data and a
 

1651
00:38:25,500 --> 00:38:27,049
anything you just read the data and a
transaction it uses what it whatever it

1652
00:38:27,049 --> 00:38:27,059
transaction it uses what it whatever it
 

1653
00:38:27,059 --> 00:38:30,799
transaction it uses what it whatever it
happens to be and you also don't

1654
00:38:30,799 --> 00:38:30,809
happens to be and you also don't
 

1655
00:38:30,809 --> 00:38:33,410
happens to be and you also don't
directly write the data in optimistic

1656
00:38:33,410 --> 00:38:33,420
directly write the data in optimistic
 

1657
00:38:33,420 --> 00:38:35,930
directly write the data in optimistic
schemes instead you buffered so you

1658
00:38:35,930 --> 00:38:35,940
schemes instead you buffered so you
 

1659
00:38:35,940 --> 00:38:38,089
schemes instead you buffered so you
buffer writes locally and in the client

1660
00:38:38,089 --> 00:38:38,099
buffer writes locally and in the client
 

1661
00:38:38,099 --> 00:38:41,529
buffer writes locally and in the client
until the transaction finally ends and

1662
00:38:41,529 --> 00:38:41,539
until the transaction finally ends and
 

1663
00:38:41,539 --> 00:38:44,240
until the transaction finally ends and
then when the transaction finally

1664
00:38:44,240 --> 00:38:44,250
then when the transaction finally
 

1665
00:38:44,250 --> 00:38:46,190
then when the transaction finally
finishes and you want to try to commit

1666
00:38:46,190 --> 00:38:46,200
finishes and you want to try to commit
 

1667
00:38:46,200 --> 00:38:50,539
finishes and you want to try to commit
it there's a validate what's called a

1668
00:38:50,539 --> 00:38:50,549
it there's a validate what's called a
 

1669
00:38:50,549 --> 00:38:56,349
it there's a validate what's called a
validation stage in which the

1670
00:38:56,349 --> 00:38:56,359
validation stage in which the
 

1671
00:38:56,359 --> 00:38:58,549
validation stage in which the
transaction processing system tries to

1672
00:38:58,549 --> 00:38:58,559
transaction processing system tries to
 

1673
00:38:58,559 --> 00:39:00,829
transaction processing system tries to
figure out whether the actual reason

1674
00:39:00,829 --> 00:39:00,839
figure out whether the actual reason
 

1675
00:39:00,839 --> 00:39:02,749
figure out whether the actual reason
rights you did were consistent with

1676
00:39:02,749 --> 00:39:02,759
rights you did were consistent with
 

1677
00:39:02,759 --> 00:39:04,789
rights you did were consistent with
serializability that is they try to

1678
00:39:04,789 --> 00:39:04,799
serializability that is they try to
 

1679
00:39:04,799 --> 00:39:06,380
serializability that is they try to
figure out oh was somebody writing the

1680
00:39:06,380 --> 00:39:06,390
figure out oh was somebody writing the
 

1681
00:39:06,390 --> 00:39:07,789
figure out oh was somebody writing the
data while I was reading it and if they

1682
00:39:07,789 --> 00:39:07,799
data while I was reading it and if they
 

1683
00:39:07,799 --> 00:39:08,960
data while I was reading it and if they
were boy

1684
00:39:08,960 --> 00:39:08,970
were boy
 

1685
00:39:08,970 --> 00:39:10,670
were boy
we can't commit this transaction because

1686
00:39:10,670 --> 00:39:10,680
we can't commit this transaction because
 

1687
00:39:10,680 --> 00:39:13,630
we can't commit this transaction because
it computed with garbage instead of

1688
00:39:13,630 --> 00:39:13,640
it computed with garbage instead of
 

1689
00:39:13,640 --> 00:39:18,440
it computed with garbage instead of
consistent read values and so if the

1690
00:39:18,440 --> 00:39:18,450
consistent read values and so if the
 

1691
00:39:18,450 --> 00:39:21,890
consistent read values and so if the
validation succeeds then you commit and

1692
00:39:21,890 --> 00:39:21,900
validation succeeds then you commit and
 

1693
00:39:21,900 --> 00:39:24,140
validation succeeds then you commit and
if the validation doesn't succeed if you

1694
00:39:24,140 --> 00:39:24,150
if the validation doesn't succeed if you
 

1695
00:39:24,150 --> 00:39:25,519
if the validation doesn't succeed if you
detect somebody else was messing with

1696
00:39:25,519 --> 00:39:25,529
detect somebody else was messing with
 

1697
00:39:25,529 --> 00:39:26,900
detect somebody else was messing with
the data while you were trying to use it

1698
00:39:26,900 --> 00:39:26,910
the data while you were trying to use it
 

1699
00:39:26,910 --> 00:39:29,089
the data while you were trying to use it
at abort so that means that if there's

1700
00:39:29,089 --> 00:39:29,099
at abort so that means that if there's
 

1701
00:39:29,099 --> 00:39:33,620
at abort so that means that if there's
conflicts if you're reading or writing

1702
00:39:33,620 --> 00:39:33,630
conflicts if you're reading or writing
 

1703
00:39:33,630 --> 00:39:35,870
conflicts if you're reading or writing
data and some other transactions also

1704
00:39:35,870 --> 00:39:35,880
data and some other transactions also
 

1705
00:39:35,880 --> 00:39:38,770
data and some other transactions also
modifying at the same time

1706
00:39:38,770 --> 00:39:38,780
modifying at the same time
 

1707
00:39:38,780 --> 00:39:41,120
modifying at the same time
optimistic schemes abort at that point

1708
00:39:41,120 --> 00:39:41,130
optimistic schemes abort at that point
 

1709
00:39:41,130 --> 00:39:43,280
optimistic schemes abort at that point
because the computation is already

1710
00:39:43,280 --> 00:39:43,290
because the computation is already
 

1711
00:39:43,290 --> 00:39:45,799
because the computation is already
incorrect at the commit point that is

1712
00:39:45,799 --> 00:39:45,809
incorrect at the commit point that is
 

1713
00:39:45,809 --> 00:39:47,870
incorrect at the commit point that is
you already read the damage data you

1714
00:39:47,870 --> 00:39:47,880
you already read the damage data you
 

1715
00:39:47,880 --> 00:39:49,970
you already read the damage data you
weren't supposed to read so there's no

1716
00:39:49,970 --> 00:39:49,980
weren't supposed to read so there's no
 

1717
00:39:49,980 --> 00:39:52,280
weren't supposed to read so there's no
way to for example block you know until

1718
00:39:52,280 --> 00:39:52,290
way to for example block you know until
 

1719
00:39:52,290 --> 00:39:53,329
way to for example block you know until
things are okay

1720
00:39:53,329 --> 00:39:53,339
things are okay
 

1721
00:39:53,339 --> 00:39:56,120
things are okay
instead the transactions already kind of

1722
00:39:56,120 --> 00:39:56,130
instead the transactions already kind of
 

1723
00:39:56,130 --> 00:39:57,950
instead the transactions already kind of
poisoned and just has to abort and

1724
00:39:57,950 --> 00:39:57,960
poisoned and just has to abort and
 

1725
00:39:57,960 --> 00:40:03,740
poisoned and just has to abort and
possibly be try okay so farm uses

1726
00:40:03,740 --> 00:40:03,750
possibly be try okay so farm uses
 

1727
00:40:03,750 --> 00:40:05,750
possibly be try okay so farm uses
optimistic because he wants to be able

1728
00:40:05,750 --> 00:40:05,760
optimistic because he wants to be able
 

1729
00:40:05,760 --> 00:40:08,299
optimistic because he wants to be able
to use one-sided RDMA to just read

1730
00:40:08,299 --> 00:40:08,309
to use one-sided RDMA to just read
 

1731
00:40:08,309 --> 00:40:12,980
to use one-sided RDMA to just read
whatever's there very quickly so this

1732
00:40:12,980 --> 00:40:12,990
whatever's there very quickly so this
 

1733
00:40:12,990 --> 00:40:16,460
whatever's there very quickly so this
this design was really forced by use of

1734
00:40:16,460 --> 00:40:16,470
this design was really forced by use of
 

1735
00:40:16,470 --> 00:40:19,579
this design was really forced by use of
our DMA this is often abbreviated OCC

1736
00:40:19,579 --> 00:40:19,589
our DMA this is often abbreviated OCC
 

1737
00:40:19,589 --> 00:40:26,390
our DMA this is often abbreviated OCC
for optimistic concurrency control all

1738
00:40:26,390 --> 00:40:26,400
for optimistic concurrency control all
 

1739
00:40:26,400 --> 00:40:27,650
for optimistic concurrency control all
right and then the interesting thing an

1740
00:40:27,650 --> 00:40:27,660
right and then the interesting thing an
 

1741
00:40:27,660 --> 00:40:28,880
right and then the interesting thing an
optimistic concurrency control protocols

1742
00:40:28,880 --> 00:40:28,890
optimistic concurrency control protocols
 

1743
00:40:28,890 --> 00:40:31,760
optimistic concurrency control protocols
is how validation works how do you

1744
00:40:31,760 --> 00:40:31,770
is how validation works how do you
 

1745
00:40:31,770 --> 00:40:33,559
is how validation works how do you
actually detect that somebody else was

1746
00:40:33,559 --> 00:40:33,569
actually detect that somebody else was
 

1747
00:40:33,569 --> 00:40:35,000
actually detect that somebody else was
writing the data while you were trying

1748
00:40:35,000 --> 00:40:35,010
writing the data while you were trying
 

1749
00:40:35,010 --> 00:40:38,089
writing the data while you were trying
to use it and that's actually mainly

1750
00:40:38,089 --> 00:40:38,099
to use it and that's actually mainly
 

1751
00:40:38,099 --> 00:40:39,530
to use it and that's actually mainly
gonna be what I talked about in the rest

1752
00:40:39,530 --> 00:40:39,540
gonna be what I talked about in the rest
 

1753
00:40:39,540 --> 00:40:42,410
gonna be what I talked about in the rest
of this lecture and just again though

1754
00:40:42,410 --> 00:40:42,420
of this lecture and just again though
 

1755
00:40:42,420 --> 00:40:44,329
of this lecture and just again though
just to retire this back to the top

1756
00:40:44,329 --> 00:40:44,339
just to retire this back to the top
 

1757
00:40:44,339 --> 00:40:47,180
just to retire this back to the top
level of the design what this is doing

1758
00:40:47,180 --> 00:40:47,190
level of the design what this is doing
 

1759
00:40:47,190 --> 00:40:49,900
level of the design what this is doing
for farm is that the reads can use

1760
00:40:49,900 --> 00:40:49,910
for farm is that the reads can use
 

1761
00:40:49,910 --> 00:40:56,089
for farm is that the reads can use
one-sided RDMA because and therefore be

1762
00:40:56,089 --> 00:40:56,099
one-sided RDMA because and therefore be
 

1763
00:40:56,099 --> 00:40:59,240
one-sided RDMA because and therefore be
extremely fast because we're gonna check

1764
00:40:59,240 --> 00:40:59,250
extremely fast because we're gonna check
 

1765
00:40:59,250 --> 00:41:07,640
extremely fast because we're gonna check
later whether the reads were okay all

1766
00:41:07,640 --> 00:41:07,650
later whether the reads were okay all
 

1767
00:41:07,650 --> 00:41:10,760
later whether the reads were okay all
right farms a research prototype it

1768
00:41:10,760 --> 00:41:10,770
right farms a research prototype it
 

1769
00:41:10,770 --> 00:41:16,579
right farms a research prototype it
doesn't support things like sequel it

1770
00:41:16,579 --> 00:41:16,589
doesn't support things like sequel it
 

1771
00:41:16,589 --> 00:41:20,660
doesn't support things like sequel it
supports a fairly simple API for

1772
00:41:20,660 --> 00:41:20,670
supports a fairly simple API for
 

1773
00:41:20,670 --> 00:41:23,839
supports a fairly simple API for
transactions this is the API just to

1774
00:41:23,839 --> 00:41:23,849
transactions this is the API just to
 

1775
00:41:23,849 --> 00:41:26,450
transactions this is the API just to
give you a tease for what a transaction

1776
00:41:26,450 --> 00:41:26,460
give you a tease for what a transaction
 

1777
00:41:26,460 --> 00:41:29,089
give you a tease for what a transaction
code might actually look like if you

1778
00:41:29,089 --> 00:41:29,099
code might actually look like if you
 

1779
00:41:29,099 --> 00:41:31,160
code might actually look like if you
have a transaction it's gotta to clear

1780
00:41:31,160 --> 00:41:31,170
have a transaction it's gotta to clear
 

1781
00:41:31,170 --> 00:41:32,510
have a transaction it's gotta to clear
the start of the transaction because we

1782
00:41:32,510 --> 00:41:32,520
the start of the transaction because we
 

1783
00:41:32,520 --> 00:41:34,819
the start of the transaction because we
need to say oh this particular set of

1784
00:41:34,819 --> 00:41:34,829
need to say oh this particular set of
 

1785
00:41:34,829 --> 00:41:36,680
need to say oh this particular set of
Reason rights needs to occur as a

1786
00:41:36,680 --> 00:41:36,690
Reason rights needs to occur as a
 

1787
00:41:36,690 --> 00:41:40,520
Reason rights needs to occur as a
complete transaction the code declares a

1788
00:41:40,520 --> 00:41:40,530
complete transaction the code declares a
 

1789
00:41:40,530 --> 00:41:43,160
complete transaction the code declares a
new transaction by calling TX create

1790
00:41:43,160 --> 00:41:43,170
new transaction by calling TX create
 

1791
00:41:43,170 --> 00:41:45,130
new transaction by calling TX create
this is all laid out by the way in the

1792
00:41:45,130 --> 00:41:45,140
this is all laid out by the way in the
 

1793
00:41:45,140 --> 00:41:47,630
this is all laid out by the way in the
paper I think from 2014 a slightly

1794
00:41:47,630 --> 00:41:47,640
paper I think from 2014 a slightly
 

1795
00:41:47,640 --> 00:41:51,070
paper I think from 2014 a slightly
earlier paper by the same authors

1796
00:41:51,070 --> 00:41:51,080
earlier paper by the same authors
 

1797
00:41:51,080 --> 00:41:53,110
earlier paper by the same authors
you create a new transaction and then

1798
00:41:53,110 --> 00:41:53,120
you create a new transaction and then
 

1799
00:41:53,120 --> 00:41:55,750
you create a new transaction and then
you explicitly read those functions to

1800
00:41:55,750 --> 00:41:55,760
you explicitly read those functions to
 

1801
00:41:55,760 --> 00:42:02,350
you explicitly read those functions to
read objects and you have to supply an

1802
00:42:02,350 --> 00:42:02,360
read objects and you have to supply an
 

1803
00:42:02,360 --> 00:42:06,370
read objects and you have to supply an
object identifier an OID indicating what

1804
00:42:06,370 --> 00:42:06,380
object identifier an OID indicating what
 

1805
00:42:06,380 --> 00:42:08,410
object identifier an OID indicating what
object you want to read then you get

1806
00:42:08,410 --> 00:42:08,420
object you want to read then you get
 

1807
00:42:08,420 --> 00:42:10,060
object you want to read then you get
back some object and you can modify the

1808
00:42:10,060 --> 00:42:10,070
back some object and you can modify the
 

1809
00:42:10,070 --> 00:42:12,190
back some object and you can modify the
object in local memory and we didn't

1810
00:42:12,190 --> 00:42:12,200
object in local memory and we didn't
 

1811
00:42:12,200 --> 00:42:14,890
object in local memory and we didn't
write it you have a copy of it that

1812
00:42:14,890 --> 00:42:14,900
write it you have a copy of it that
 

1813
00:42:14,900 --> 00:42:16,780
write it you have a copy of it that
you've read from the server the TX read

1814
00:42:16,780 --> 00:42:16,790
you've read from the server the TX read
 

1815
00:42:16,790 --> 00:42:18,340
you've read from the server the TX read
back from the server so you know you

1816
00:42:18,340 --> 00:42:18,350
back from the server so you know you
 

1817
00:42:18,350 --> 00:42:22,440
back from the server so you know you
might increment some field in the object

1818
00:42:22,440 --> 00:42:22,450
might increment some field in the object
 

1819
00:42:22,450 --> 00:42:26,410
might increment some field in the object
and then when you want to update an

1820
00:42:26,410 --> 00:42:26,420
and then when you want to update an
 

1821
00:42:26,420 --> 00:42:30,970
and then when you want to update an
object you call this TX right and again

1822
00:42:30,970 --> 00:42:30,980
object you call this TX right and again
 

1823
00:42:30,980 --> 00:42:34,720
object you call this TX right and again
you give it the object ID and the new

1824
00:42:34,720 --> 00:42:34,730
you give it the object ID and the new
 

1825
00:42:34,730 --> 00:42:37,060
you give it the object ID and the new
object contents and finally when you're

1826
00:42:37,060 --> 00:42:37,070
object contents and finally when you're
 

1827
00:42:37,070 --> 00:42:39,580
object contents and finally when you're
through with all of this you've got to

1828
00:42:39,580 --> 00:42:39,590
through with all of this you've got to
 

1829
00:42:39,590 --> 00:42:41,080
through with all of this you've got to
tell the assistant to commit this

1830
00:42:41,080 --> 00:42:41,090
tell the assistant to commit this
 

1831
00:42:41,090 --> 00:42:43,990
tell the assistant to commit this
transaction actually do validation and

1832
00:42:43,990 --> 00:42:44,000
transaction actually do validation and
 

1833
00:42:44,000 --> 00:42:46,300
transaction actually do validation and
if it succeeds cause the rights to

1834
00:42:46,300 --> 00:42:46,310
if it succeeds cause the rights to
 

1835
00:42:46,310 --> 00:42:48,490
if it succeeds cause the rights to
really take effect and be visible and

1836
00:42:48,490 --> 00:42:48,500
really take effect and be visible and
 

1837
00:42:48,500 --> 00:42:52,990
really take effect and be visible and
you call this commit routine the

1838
00:42:52,990 --> 00:42:53,000
you call this commit routine the
 

1839
00:42:53,000 --> 00:42:54,280
you call this commit routine the
community team runs a whole bunch of

1840
00:42:54,280 --> 00:42:54,290
community team runs a whole bunch of
 

1841
00:42:54,290 --> 00:42:56,340
community team runs a whole bunch of
stuff in figure 4 which we'll talk about

1842
00:42:56,340 --> 00:42:56,350
stuff in figure 4 which we'll talk about
 

1843
00:42:56,350 --> 00:42:59,260
stuff in figure 4 which we'll talk about
and it returns this okay value and it's

1844
00:42:59,260 --> 00:42:59,270
and it returns this okay value and it's
 

1845
00:42:59,270 --> 00:43:02,320
and it returns this okay value and it's
required to tell the application oh did

1846
00:43:02,320 --> 00:43:02,330
required to tell the application oh did
 

1847
00:43:02,330 --> 00:43:04,480
required to tell the application oh did
the commit succeed or was it aborted so

1848
00:43:04,480 --> 00:43:04,490
the commit succeed or was it aborted so
 

1849
00:43:04,490 --> 00:43:07,360
the commit succeed or was it aborted so
we need the return this okay return

1850
00:43:07,360 --> 00:43:07,370
we need the return this okay return
 

1851
00:43:07,370 --> 00:43:09,820
we need the return this okay return
valued you know correctly indicate by

1852
00:43:09,820 --> 00:43:09,830
valued you know correctly indicate by
 

1853
00:43:09,830 --> 00:43:13,210
valued you know correctly indicate by
the transaction succeeded okay there's

1854
00:43:13,210 --> 00:43:13,220
the transaction succeeded okay there's
 

1855
00:43:13,220 --> 00:43:16,300
the transaction succeeded okay there's
some questions one is question since OCC

1856
00:43:16,300 --> 00:43:16,310
some questions one is question since OCC
 

1857
00:43:16,310 --> 00:43:20,200
some questions one is question since OCC
aborts if there's contention question is

1858
00:43:20,200 --> 00:43:20,210
aborts if there's contention question is
 

1859
00:43:20,210 --> 00:43:23,170
aborts if there's contention question is
whether retries involve exponential

1860
00:43:23,170 --> 00:43:23,180
whether retries involve exponential
 

1861
00:43:23,180 --> 00:43:25,840
whether retries involve exponential
back-off because otherwise it seems like

1862
00:43:25,840 --> 00:43:25,850
back-off because otherwise it seems like
 

1863
00:43:25,850 --> 00:43:29,050
back-off because otherwise it seems like
if you just instantly be tried and that

1864
00:43:29,050 --> 00:43:29,060
if you just instantly be tried and that
 

1865
00:43:29,060 --> 00:43:32,980
if you just instantly be tried and that
there were a lot of transactions all

1866
00:43:32,980 --> 00:43:32,990
there were a lot of transactions all
 

1867
00:43:32,990 --> 00:43:34,390
there were a lot of transactions all
trying to update the same value at the

1868
00:43:34,390 --> 00:43:34,400
trying to update the same value at the
 

1869
00:43:34,400 --> 00:43:36,040
trying to update the same value at the
same time they'd all aboard they'd all

1870
00:43:36,040 --> 00:43:36,050
same time they'd all aboard they'd all
 

1871
00:43:36,050 --> 00:43:39,460
same time they'd all aboard they'd all
retry and waste a lot of time and I

1872
00:43:39,460 --> 00:43:39,470
retry and waste a lot of time and I
 

1873
00:43:39,470 --> 00:43:40,690
retry and waste a lot of time and I
don't know the answer to that question I

1874
00:43:40,690 --> 00:43:40,700
don't know the answer to that question I
 

1875
00:43:40,700 --> 00:43:42,220
don't know the answer to that question I
don't remember seeing them mentioning

1876
00:43:42,220 --> 00:43:42,230
don't remember seeing them mentioning
 

1877
00:43:42,230 --> 00:43:44,230
don't remember seeing them mentioning
exponential back-off in the paper but it

1878
00:43:44,230 --> 00:43:44,240
exponential back-off in the paper but it
 

1879
00:43:44,240 --> 00:43:46,890
exponential back-off in the paper but it
would make a huge amount of sense to

1880
00:43:46,890 --> 00:43:46,900
would make a huge amount of sense to
 

1881
00:43:46,900 --> 00:43:49,540
would make a huge amount of sense to
delay between retries and to increase

1882
00:43:49,540 --> 00:43:49,550
delay between retries and to increase
 

1883
00:43:49,550 --> 00:43:52,930
delay between retries and to increase
the delay to give somebody a chance of

1884
00:43:52,930 --> 00:43:52,940
the delay to give somebody a chance of
 

1885
00:43:52,940 --> 00:43:56,250
the delay to give somebody a chance of
succeeding this is much like the

1886
00:43:56,250 --> 00:43:56,260
succeeding this is much like the
 

1887
00:43:56,260 --> 00:43:59,480
succeeding this is much like the
randomization of the raft collects

1888
00:43:59,480 --> 00:43:59,490
randomization of the raft collects
 

1889
00:43:59,490 --> 00:44:04,070
randomization of the raft collects
Tanner's another question is the farm

1890
00:44:04,070 --> 00:44:04,080
Tanner's another question is the farm
 

1891
00:44:04,080 --> 00:44:05,960
Tanner's another question is the farm
API closer in spirit to a no sequel

1892
00:44:05,960 --> 00:44:05,970
API closer in spirit to a no sequel
 

1893
00:44:05,970 --> 00:44:09,020
API closer in spirit to a no sequel
database yeah you know that's one way of

1894
00:44:09,020 --> 00:44:09,030
database yeah you know that's one way of
 

1895
00:44:09,030 --> 00:44:12,290
database yeah you know that's one way of
viewing it it really that it doesn't

1896
00:44:12,290 --> 00:44:12,300
viewing it it really that it doesn't
 

1897
00:44:12,300 --> 00:44:15,859
viewing it it really that it doesn't
have any of the fancy query stuff like

1898
00:44:15,859 --> 00:44:15,869
have any of the fancy query stuff like
 

1899
00:44:15,869 --> 00:44:19,190
have any of the fancy query stuff like
joins for example that sequel has it's

1900
00:44:19,190 --> 00:44:19,200
joins for example that sequel has it's
 

1901
00:44:19,200 --> 00:44:20,480
joins for example that sequel has it's
really a very low-level kind of

1902
00:44:20,480 --> 00:44:20,490
really a very low-level kind of
 

1903
00:44:20,490 --> 00:44:25,040
really a very low-level kind of
readwrite interface plus the transaction

1904
00:44:25,040 --> 00:44:25,050
readwrite interface plus the transaction
 

1905
00:44:25,050 --> 00:44:27,109
readwrite interface plus the transaction
support so you you can sort of view it

1906
00:44:27,109 --> 00:44:27,119
support so you you can sort of view it
 

1907
00:44:27,119 --> 00:44:30,590
support so you you can sort of view it
as a no sequel database maybe with with

1908
00:44:30,590 --> 00:44:30,600
as a no sequel database maybe with with
 

1909
00:44:30,600 --> 00:44:36,560
as a no sequel database maybe with with
transactions all right this is what a

1910
00:44:36,560 --> 00:44:36,570
transactions all right this is what a
 

1911
00:44:36,570 --> 00:44:40,400
transactions all right this is what a
transaction looks like and these are all

1912
00:44:40,400 --> 00:44:40,410
transaction looks like and these are all
 

1913
00:44:40,410 --> 00:44:41,870
transaction looks like and these are all
these are library calls created

1914
00:44:41,870 --> 00:44:41,880
these are library calls created
 

1915
00:44:41,880 --> 00:44:44,450
these are library calls created
read/write commit commit as a sort of

1916
00:44:44,450 --> 00:44:44,460
read/write commit commit as a sort of
 

1917
00:44:44,460 --> 00:44:46,490
read/write commit commit as a sort of
complex write recall that actually runs

1918
00:44:46,490 --> 00:44:46,500
complex write recall that actually runs
 

1919
00:44:46,500 --> 00:44:49,700
complex write recall that actually runs
the transaction coordinator code first

1920
00:44:49,700 --> 00:44:49,710
the transaction coordinator code first
 

1921
00:44:49,710 --> 00:44:52,190
the transaction coordinator code first
what a rare variant of two-phase commit

1922
00:44:52,190 --> 00:44:52,200
what a rare variant of two-phase commit
 

1923
00:44:52,200 --> 00:44:56,450
what a rare variant of two-phase commit
this described in figure four just

1924
00:44:56,450 --> 00:44:56,460
this described in figure four just
 

1925
00:44:56,460 --> 00:44:59,090
this described in figure four just
repeat that the while the recall goes

1926
00:44:59,090 --> 00:44:59,100
repeat that the while the recall goes
 

1927
00:44:59,100 --> 00:45:00,410
repeat that the while the recall goes
off and actually reads the relevant

1928
00:45:00,410 --> 00:45:00,420
off and actually reads the relevant
 

1929
00:45:00,420 --> 00:45:04,099
off and actually reads the relevant
server the right call just locally

1930
00:45:04,099 --> 00:45:04,109
server the right call just locally
 

1931
00:45:04,109 --> 00:45:08,090
server the right call just locally
buffers then the new the modified object

1932
00:45:08,090 --> 00:45:08,100
buffers then the new the modified object
 

1933
00:45:08,100 --> 00:45:10,550
buffers then the new the modified object
and it's only in commit that the objects

1934
00:45:10,550 --> 00:45:10,560
and it's only in commit that the objects
 

1935
00:45:10,560 --> 00:45:14,270
and it's only in commit that the objects
are sent to the servers these object IDs

1936
00:45:14,270 --> 00:45:14,280
are sent to the servers these object IDs
 

1937
00:45:14,280 --> 00:45:17,780
are sent to the servers these object IDs
are actually compound identifiers for

1938
00:45:17,780 --> 00:45:17,790
are actually compound identifiers for
 

1939
00:45:17,790 --> 00:45:19,700
are actually compound identifiers for
objects and they contain two parts one

1940
00:45:19,700 --> 00:45:19,710
objects and they contain two parts one
 

1941
00:45:19,710 --> 00:45:25,520
objects and they contain two parts one
is the identify a region which is that

1942
00:45:25,520 --> 00:45:25,530
is the identify a region which is that
 

1943
00:45:25,530 --> 00:45:27,349
is the identify a region which is that
all the memory of all the servers is

1944
00:45:27,349 --> 00:45:27,359
all the memory of all the servers is
 

1945
00:45:27,359 --> 00:45:29,450
all the memory of all the servers is
split up into these regions and the

1946
00:45:29,450 --> 00:45:29,460
split up into these regions and the
 

1947
00:45:29,460 --> 00:45:31,570
split up into these regions and the
configuration manager sort of tracks

1948
00:45:31,570 --> 00:45:31,580
configuration manager sort of tracks
 

1949
00:45:31,580 --> 00:45:34,609
configuration manager sort of tracks
which servers replicate which region

1950
00:45:34,609 --> 00:45:34,619
which servers replicate which region
 

1951
00:45:34,619 --> 00:45:36,620
which servers replicate which region
number so there's a reason number in

1952
00:45:36,620 --> 00:45:36,630
number so there's a reason number in
 

1953
00:45:36,630 --> 00:45:40,970
number so there's a reason number in
here and then and then you you know you

1954
00:45:40,970 --> 00:45:40,980
here and then and then you you know you
 

1955
00:45:40,980 --> 00:45:42,740
here and then and then you you know you
client can look up in a table the

1956
00:45:42,740 --> 00:45:42,750
client can look up in a table the
 

1957
00:45:42,750 --> 00:45:44,599
client can look up in a table the
current primary and backups for a given

1958
00:45:44,599 --> 00:45:44,609
current primary and backups for a given
 

1959
00:45:44,609 --> 00:45:46,010
current primary and backups for a given
region number and then there's an

1960
00:45:46,010 --> 00:45:46,020
region number and then there's an
 

1961
00:45:46,020 --> 00:45:47,930
region number and then there's an
address such as the straight memory

1962
00:45:47,930 --> 00:45:47,940
address such as the straight memory
 

1963
00:45:47,940 --> 00:45:53,500
address such as the straight memory
address within that region and so the

1964
00:45:53,500 --> 00:45:53,510
address within that region and so the
 

1965
00:45:53,510 --> 00:45:55,460
address within that region and so the
client uses the reason number to pick

1966
00:45:55,460 --> 00:45:55,470
client uses the reason number to pick
 

1967
00:45:55,470 --> 00:45:57,380
client uses the reason number to pick
the primary in the backup to talk to and

1968
00:45:57,380 --> 00:45:57,390
the primary in the backup to talk to and
 

1969
00:45:57,390 --> 00:45:59,990
the primary in the backup to talk to and
then it hands the address to the our DMA

1970
00:45:59,990 --> 00:46:00,000
then it hands the address to the our DMA
 

1971
00:46:00,000 --> 00:46:03,050
then it hands the address to the our DMA
NIC and tells it look please read at

1972
00:46:03,050 --> 00:46:03,060
NIC and tells it look please read at
 

1973
00:46:03,060 --> 00:46:05,300
NIC and tells it look please read at
this address in order to get fetch this

1974
00:46:05,300 --> 00:46:05,310
this address in order to get fetch this
 

1975
00:46:05,310 --> 00:46:11,690
this address in order to get fetch this
object

1976
00:46:11,690 --> 00:46:11,700

 

1977
00:46:11,700 --> 00:46:14,910

alright another piece of detail we have

1978
00:46:14,910 --> 00:46:14,920
alright another piece of detail we have
 

1979
00:46:14,920 --> 00:46:17,910
alright another piece of detail we have
to get out of the way is to look at the

1980
00:46:17,910 --> 00:46:17,920
to get out of the way is to look at the
 

1981
00:46:17,920 --> 00:46:25,620
to get out of the way is to look at the
server memory layout I'm in any one

1982
00:46:25,620 --> 00:46:25,630
server memory layout I'm in any one
 

1983
00:46:25,630 --> 00:46:29,760
server memory layout I'm in any one
server there's a bunch of stuff in

1984
00:46:29,760 --> 00:46:29,770
server there's a bunch of stuff in
 

1985
00:46:29,770 --> 00:46:33,030
server there's a bunch of stuff in
memory so one part is that the server

1986
00:46:33,030 --> 00:46:33,040
memory so one part is that the server
 

1987
00:46:33,040 --> 00:46:37,620
memory so one part is that the server
has in its memory its if it's it's

1988
00:46:37,620 --> 00:46:37,630
has in its memory its if it's it's
 

1989
00:46:37,630 --> 00:46:39,150
has in its memory its if it's it's
replicating one or more regions it has

1990
00:46:39,150 --> 00:46:39,160
replicating one or more regions it has
 

1991
00:46:39,160 --> 00:46:41,850
replicating one or more regions it has
the actual regions and or what a reason

1992
00:46:41,850 --> 00:46:41,860
the actual regions and or what a reason
 

1993
00:46:41,860 --> 00:46:42,990
the actual regions and or what a reason
contains is a whole bunch of these

1994
00:46:42,990 --> 00:46:43,000
contains is a whole bunch of these
 

1995
00:46:43,000 --> 00:46:47,130
contains is a whole bunch of these
objects and each object there's a lot of

1996
00:46:47,130 --> 00:46:47,140
objects and each object there's a lot of
 

1997
00:46:47,140 --> 00:46:52,710
objects and each object there's a lot of
objects objects sitting in memory each

1998
00:46:52,710 --> 00:46:52,720
objects objects sitting in memory each
 

1999
00:46:52,720 --> 00:46:58,800
objects objects sitting in memory each
object has in it a header which contains

2000
00:46:58,800 --> 00:46:58,810
object has in it a header which contains
 

2001
00:46:58,810 --> 00:47:00,750
object has in it a header which contains
the version number so these are

2002
00:47:00,750 --> 00:47:00,760
the version number so these are
 

2003
00:47:00,760 --> 00:47:03,060
the version number so these are
versioned objects but each object only

2004
00:47:03,060 --> 00:47:03,070
versioned objects but each object only
 

2005
00:47:03,070 --> 00:47:07,280
versioned objects but each object only
has one version at a time so this is

2006
00:47:07,280 --> 00:47:07,290
has one version at a time so this is
 

2007
00:47:07,290 --> 00:47:13,620
has one version at a time so this is
version number and in the high bit let

2008
00:47:13,620 --> 00:47:13,630
version number and in the high bit let
 

2009
00:47:13,630 --> 00:47:15,780
version number and in the high bit let
me try again here and the high bit of

2010
00:47:15,780 --> 00:47:15,790
me try again here and the high bit of
 

2011
00:47:15,790 --> 00:47:17,670
me try again here and the high bit of
each version number is a lock flag so in

2012
00:47:17,670 --> 00:47:17,680
each version number is a lock flag so in
 

2013
00:47:17,680 --> 00:47:18,990
each version number is a lock flag so in
the header of an object there's a lock

2014
00:47:18,990 --> 00:47:19,000
the header of an object there's a lock
 

2015
00:47:19,000 --> 00:47:21,930
the header of an object there's a lock
flag and the high bit and then a version

2016
00:47:21,930 --> 00:47:21,940
flag and the high bit and then a version
 

2017
00:47:21,940 --> 00:47:26,280
flag and the high bit and then a version
number in a little bit and then the

2018
00:47:26,280 --> 00:47:26,290
number in a little bit and then the
 

2019
00:47:26,290 --> 00:47:29,790
number in a little bit and then the
actual data of the object so each object

2020
00:47:29,790 --> 00:47:29,800
actual data of the object so each object
 

2021
00:47:29,800 --> 00:47:31,890
actual data of the object so each object
has the same servers memory it's the

2022
00:47:31,890 --> 00:47:31,900
has the same servers memory it's the
 

2023
00:47:31,900 --> 00:47:33,630
has the same servers memory it's the
same layout a lock bit in the high bit

2024
00:47:33,630 --> 00:47:33,640
same layout a lock bit in the high bit
 

2025
00:47:33,640 --> 00:47:37,110
same layout a lock bit in the high bit
and the current version number a little

2026
00:47:37,110 --> 00:47:37,120
and the current version number a little
 

2027
00:47:37,120 --> 00:47:38,990
and the current version number a little
bit and every time the system writes

2028
00:47:38,990 --> 00:47:39,000
bit and every time the system writes
 

2029
00:47:39,000 --> 00:47:41,490
bit and every time the system writes
modifies an object it increases the

2030
00:47:41,490 --> 00:47:41,500
modifies an object it increases the
 

2031
00:47:41,500 --> 00:47:42,780
modifies an object it increases the
version number and let's see how the

2032
00:47:42,780 --> 00:47:42,790
version number and let's see how the
 

2033
00:47:42,790 --> 00:47:44,810
version number and let's see how the
lock bits are used in a couple minutes

2034
00:47:44,810 --> 00:47:44,820
lock bits are used in a couple minutes
 

2035
00:47:44,820 --> 00:47:47,700
lock bits are used in a couple minutes
in addition in the server's memory there

2036
00:47:47,700 --> 00:47:47,710
in addition in the server's memory there
 

2037
00:47:47,710 --> 00:47:52,580
in addition in the server's memory there
are pairs of cue pairs of message queues

2038
00:47:52,580 --> 00:47:52,590
are pairs of cue pairs of message queues
 

2039
00:47:52,590 --> 00:47:58,050
are pairs of cue pairs of message queues
and logs one for every other computer in

2040
00:47:58,050 --> 00:47:58,060
and logs one for every other computer in
 

2041
00:47:58,060 --> 00:48:03,390
and logs one for every other computer in
the system so that means that you know

2042
00:48:03,390 --> 00:48:03,400
the system so that means that you know
 

2043
00:48:03,400 --> 00:48:09,030
the system so that means that you know
if there's four other servers in the

2044
00:48:09,030 --> 00:48:09,040
if there's four other servers in the
 

2045
00:48:09,040 --> 00:48:11,430
if there's four other servers in the
system that are running or if there's

2046
00:48:11,430 --> 00:48:11,440
system that are running or if there's
 

2047
00:48:11,440 --> 00:48:12,710
system that are running or if there's
four servers that are running

2048
00:48:12,710 --> 00:48:12,720
four servers that are running
 

2049
00:48:12,720 --> 00:48:15,120
four servers that are running
transactions there's going to be four

2050
00:48:15,120 --> 00:48:15,130
transactions there's going to be four
 

2051
00:48:15,130 --> 00:48:18,630
transactions there's going to be four
logs sitting in memory that can be

2052
00:48:18,630 --> 00:48:18,640
logs sitting in memory that can be
 

2053
00:48:18,640 --> 00:48:21,630
logs sitting in memory that can be
appended to with our DMA one for each of

2054
00:48:21,630 --> 00:48:21,640
appended to with our DMA one for each of
 

2055
00:48:21,640 --> 00:48:23,210
appended to with our DMA one for each of
the other servers and that means that

2056
00:48:23,210 --> 00:48:23,220
the other servers and that means that
 

2057
00:48:23,220 --> 00:48:25,770
the other servers and that means that
one for each of the other computers can

2058
00:48:25,770 --> 00:48:25,780
one for each of the other computers can
 

2059
00:48:25,780 --> 00:48:27,120
one for each of the other computers can
run transactions so that means that the

2060
00:48:27,120 --> 00:48:27,130
run transactions so that means that the
 

2061
00:48:27,130 --> 00:48:31,320
run transactions so that means that the
transaction code running on you know so

2062
00:48:31,320 --> 00:48:31,330
transaction code running on you know so
 

2063
00:48:31,330 --> 00:48:33,300
transaction code running on you know so
number of them you know it's the

2064
00:48:33,300 --> 00:48:33,310
number of them you know it's the
 

2065
00:48:33,310 --> 00:48:36,150
number of them you know it's the
transaction code running on computer to

2066
00:48:36,150 --> 00:48:36,160
transaction code running on computer to
 

2067
00:48:36,160 --> 00:48:39,150
transaction code running on computer to
when it wants to talk to this server and

2068
00:48:39,150 --> 00:48:39,160
when it wants to talk to this server and
 

2069
00:48:39,160 --> 00:48:42,270
when it wants to talk to this server and
append to its log which as well see it's

2070
00:48:42,270 --> 00:48:42,280
append to its log which as well see it's
 

2071
00:48:42,280 --> 00:48:45,270
append to its log which as well see it's
actually going to append to server twos

2072
00:48:45,270 --> 00:48:45,280
actually going to append to server twos
 

2073
00:48:45,280 --> 00:48:47,460
actually going to append to server twos
log in this servers memory so there's a

2074
00:48:47,460 --> 00:48:47,470
log in this servers memory so there's a
 

2075
00:48:47,470 --> 00:48:49,920
log in this servers memory so there's a
total N squared of these queues floating

2076
00:48:49,920 --> 00:48:49,930
total N squared of these queues floating
 

2077
00:48:49,930 --> 00:48:53,990
total N squared of these queues floating
around in in in each servers memory and

2078
00:48:53,990 --> 00:48:54,000
around in in in each servers memory and
 

2079
00:48:54,000 --> 00:48:56,430
around in in in each servers memory and
it certainly seems like there's actually

2080
00:48:56,430 --> 00:48:56,440
it certainly seems like there's actually
 

2081
00:48:56,440 --> 00:48:59,090
it certainly seems like there's actually
one set of logs which are meant to be I

2082
00:48:59,090 --> 00:48:59,100
one set of logs which are meant to be I
 

2083
00:48:59,100 --> 00:49:03,320
one set of logs which are meant to be I
would non-volatile and then also

2084
00:49:03,320 --> 00:49:03,330
would non-volatile and then also
 

2085
00:49:03,330 --> 00:49:06,930
would non-volatile and then also
possibly a separate set of message

2086
00:49:06,930 --> 00:49:06,940
possibly a separate set of message
 

2087
00:49:06,940 --> 00:49:09,060
possibly a separate set of message
queues which are used just for more RPC

2088
00:49:09,060 --> 00:49:09,070
queues which are used just for more RPC
 

2089
00:49:09,070 --> 00:49:12,600
queues which are used just for more RPC
like communication again one in each

2090
00:49:12,600 --> 00:49:12,610
like communication again one in each
 

2091
00:49:12,610 --> 00:49:14,310
like communication again one in each
server one queue message incoming

2092
00:49:14,310 --> 00:49:14,320
server one queue message incoming
 

2093
00:49:14,320 --> 00:49:16,470
server one queue message incoming
message cube per other server written

2094
00:49:16,470 --> 00:49:16,480
message cube per other server written
 

2095
00:49:16,480 --> 00:49:28,230
message cube per other server written
with our DMA writes all right actually

2096
00:49:28,230 --> 00:49:28,240
with our DMA writes all right actually
 

2097
00:49:28,240 --> 00:49:31,470
with our DMA writes all right actually
the next thing to talk about is a year

2098
00:49:31,470 --> 00:49:31,480
the next thing to talk about is a year
 

2099
00:49:31,480 --> 00:49:33,030
the next thing to talk about is a year
four in the paper

2100
00:49:33,030 --> 00:49:33,040
four in the paper
 

2101
00:49:33,040 --> 00:49:39,140
four in the paper
this is feet four and this explains the

2102
00:49:39,140 --> 00:49:39,150
this is feet four and this explains the
 

2103
00:49:39,150 --> 00:49:46,470
this is feet four and this explains the
occ commit protocol that farm uses and

2104
00:49:46,470 --> 00:49:46,480
occ commit protocol that farm uses and
 

2105
00:49:46,480 --> 00:49:48,360
occ commit protocol that farm uses and
I'm gonna go through mostly steps one by

2106
00:49:48,360 --> 00:49:48,370
I'm gonna go through mostly steps one by
 

2107
00:49:48,370 --> 00:49:51,180
I'm gonna go through mostly steps one by
one and actually to to begin with I'm

2108
00:49:51,180 --> 00:49:51,190
one and actually to to begin with I'm
 

2109
00:49:51,190 --> 00:49:52,590
one and actually to to begin with I'm
gonna focus only on the concurrency

2110
00:49:52,590 --> 00:49:52,600
gonna focus only on the concurrency
 

2111
00:49:52,600 --> 00:49:55,410
gonna focus only on the concurrency
control part of this it turns out these

2112
00:49:55,410 --> 00:49:55,420
control part of this it turns out these
 

2113
00:49:55,420 --> 00:49:58,730
control part of this it turns out these
steps also do replication as well as

2114
00:49:58,730 --> 00:49:58,740
steps also do replication as well as
 

2115
00:49:58,740 --> 00:50:01,830
steps also do replication as well as
implement serializable transactions but

2116
00:50:01,830 --> 00:50:01,840
implement serializable transactions but
 

2117
00:50:01,840 --> 00:50:04,590
implement serializable transactions but
we'll talk about the replication for

2118
00:50:04,590 --> 00:50:04,600
we'll talk about the replication for
 

2119
00:50:04,600 --> 00:50:07,980
we'll talk about the replication for
fault tolerance a little bit later okay

2120
00:50:07,980 --> 00:50:07,990
fault tolerance a little bit later okay
 

2121
00:50:07,990 --> 00:50:08,970
fault tolerance a little bit later okay
so the first thing that happens is the

2122
00:50:08,970 --> 00:50:08,980
so the first thing that happens is the
 

2123
00:50:08,980 --> 00:50:11,430
so the first thing that happens is the
execute phase and this is the TX reads

2124
00:50:11,430 --> 00:50:11,440
execute phase and this is the TX reads
 

2125
00:50:11,440 --> 00:50:13,740
execute phase and this is the TX reads
and TX writes the reason writes that the

2126
00:50:13,740 --> 00:50:13,750
and TX writes the reason writes that the
 

2127
00:50:13,750 --> 00:50:17,040
and TX writes the reason writes that the
client transaction is doing and so each

2128
00:50:17,040 --> 00:50:17,050
client transaction is doing and so each
 

2129
00:50:17,050 --> 00:50:19,200
client transaction is doing and so each
of these arrows here what this means is

2130
00:50:19,200 --> 00:50:19,210
of these arrows here what this means is
 

2131
00:50:19,210 --> 00:50:21,180
of these arrows here what this means is
that the transaction runs on computer C

2132
00:50:21,180 --> 00:50:21,190
that the transaction runs on computer C
 

2133
00:50:21,190 --> 00:50:22,260
that the transaction runs on computer C
and when

2134
00:50:22,260 --> 00:50:22,270
and when
 

2135
00:50:22,270 --> 00:50:26,310
and when
needs to read something it uses

2136
00:50:26,310 --> 00:50:26,320
needs to read something it uses
 

2137
00:50:26,320 --> 00:50:29,190
needs to read something it uses
one-sided RDMA we to simply read it out

2138
00:50:29,190 --> 00:50:29,200
one-sided RDMA we to simply read it out
 

2139
00:50:29,200 --> 00:50:31,980
one-sided RDMA we to simply read it out
of the relevant primary servers memory

2140
00:50:31,980 --> 00:50:31,990
of the relevant primary servers memory
 

2141
00:50:31,990 --> 00:50:34,970
of the relevant primary servers memory
so what we got here was a primary backup

2142
00:50:34,970 --> 00:50:34,980
so what we got here was a primary backup
 

2143
00:50:34,980 --> 00:50:37,440
so what we got here was a primary backup
primary backup primary backup for three

2144
00:50:37,440 --> 00:50:37,450
primary backup primary backup for three
 

2145
00:50:37,450 --> 00:50:39,000
primary backup primary backup for three
different shards and we're imagining

2146
00:50:39,000 --> 00:50:39,010
different shards and we're imagining
 

2147
00:50:39,010 --> 00:50:42,360
different shards and we're imagining
that our transaction read something from

2148
00:50:42,360 --> 00:50:42,370
that our transaction read something from
 

2149
00:50:42,370 --> 00:50:44,460
that our transaction read something from
one object from each of these shards

2150
00:50:44,460 --> 00:50:44,470
one object from each of these shards
 

2151
00:50:44,470 --> 00:50:47,730
one object from each of these shards
using one-sided RDMA reason that means

2152
00:50:47,730 --> 00:50:47,740
using one-sided RDMA reason that means
 

2153
00:50:47,740 --> 00:50:50,910
using one-sided RDMA reason that means
these blindingly fast five microseconds

2154
00:50:50,910 --> 00:50:50,920
these blindingly fast five microseconds
 

2155
00:50:50,920 --> 00:50:54,660
these blindingly fast five microseconds
each okay so the client reads everything

2156
00:50:54,660 --> 00:50:54,670
each okay so the client reads everything
 

2157
00:50:54,670 --> 00:50:56,340
each okay so the client reads everything
it needs to read for the transaction

2158
00:50:56,340 --> 00:50:56,350
it needs to read for the transaction
 

2159
00:50:56,350 --> 00:50:58,350
it needs to read for the transaction
also anything that's going to write it

2160
00:50:58,350 --> 00:50:58,360
also anything that's going to write it
 

2161
00:50:58,360 --> 00:51:01,500
also anything that's going to write it
first reads and it has to do it do this

2162
00:51:01,500 --> 00:51:01,510
first reads and it has to do it do this
 

2163
00:51:01,510 --> 00:51:04,320
first reads and it has to do it do this
read has to first read because it needs

2164
00:51:04,320 --> 00:51:04,330
read has to first read because it needs
 

2165
00:51:04,330 --> 00:51:05,970
read has to first read because it needs
to get the version number

2166
00:51:05,970 --> 00:51:05,980
to get the version number
 

2167
00:51:05,980 --> 00:51:08,820
to get the version number
the initial version number all right so

2168
00:51:08,820 --> 00:51:08,830
the initial version number all right so
 

2169
00:51:08,830 --> 00:51:11,850
the initial version number all right so
that's the execute phase then when the

2170
00:51:11,850 --> 00:51:11,860
that's the execute phase then when the
 

2171
00:51:11,860 --> 00:51:14,280
that's the execute phase then when the
transaction calls TX commits to indicate

2172
00:51:14,280 --> 00:51:14,290
transaction calls TX commits to indicate
 

2173
00:51:14,290 --> 00:51:18,630
transaction calls TX commits to indicate
that it's totally done the library on

2174
00:51:18,630 --> 00:51:18,640
that it's totally done the library on
 

2175
00:51:18,640 --> 00:51:21,210
that it's totally done the library on
the you know the TX commit call on on

2176
00:51:21,210 --> 00:51:21,220
the you know the TX commit call on on
 

2177
00:51:21,220 --> 00:51:22,740
the you know the TX commit call on on
the client acts as a transaction

2178
00:51:22,740 --> 00:51:22,750
the client acts as a transaction
 

2179
00:51:22,750 --> 00:51:26,400
the client acts as a transaction
coordinator and runs this whole protocol

2180
00:51:26,400 --> 00:51:26,410
coordinator and runs this whole protocol
 

2181
00:51:26,410 --> 00:51:28,760
coordinator and runs this whole protocol
which is a kind of elaborate version of

2182
00:51:28,760 --> 00:51:28,770
which is a kind of elaborate version of
 

2183
00:51:28,770 --> 00:51:35,900
which is a kind of elaborate version of
two-phase commit the first phase and

2184
00:51:35,900 --> 00:51:35,910
two-phase commit the first phase and
 

2185
00:51:35,910 --> 00:51:38,610
two-phase commit the first phase and
that's described in terms of rounds of

2186
00:51:38,610 --> 00:51:38,620
that's described in terms of rounds of
 

2187
00:51:38,620 --> 00:51:40,050
that's described in terms of rounds of
messages so the transaction coordinator

2188
00:51:40,050 --> 00:51:40,060
messages so the transaction coordinator
 

2189
00:51:40,060 --> 00:51:41,730
messages so the transaction coordinator
sends a bunch of LOC messages and wait

2190
00:51:41,730 --> 00:51:41,740
sends a bunch of LOC messages and wait
 

2191
00:51:41,740 --> 00:51:43,650
sends a bunch of LOC messages and wait
for them to reply and then validate

2192
00:51:43,650 --> 00:51:43,660
for them to reply and then validate
 

2193
00:51:43,660 --> 00:51:45,330
for them to reply and then validate
messages and waste for the all the

2194
00:51:45,330 --> 00:51:45,340
messages and waste for the all the
 

2195
00:51:45,340 --> 00:51:48,240
messages and waste for the all the
replies so the first phase in the commit

2196
00:51:48,240 --> 00:51:48,250
replies so the first phase in the commit
 

2197
00:51:48,250 --> 00:51:51,570
replies so the first phase in the commit
protocol is the lock fees in this phase

2198
00:51:51,570 --> 00:51:51,580
protocol is the lock fees in this phase
 

2199
00:51:51,580 --> 00:51:55,050
protocol is the lock fees in this phase
what the client is sending is it sends

2200
00:51:55,050 --> 00:51:55,060
what the client is sending is it sends
 

2201
00:51:55,060 --> 00:52:00,120
what the client is sending is it sends
to each primary the identity of the

2202
00:52:00,120 --> 00:52:00,130
to each primary the identity of the
 

2203
00:52:00,130 --> 00:52:02,400
to each primary the identity of the
object in for each object for clients

2204
00:52:02,400 --> 00:52:02,410
object in for each object for clients
 

2205
00:52:02,410 --> 00:52:03,840
object in for each object for clients
written and needs to send that updated

2206
00:52:03,840 --> 00:52:03,850
written and needs to send that updated
 

2207
00:52:03,850 --> 00:52:06,600
written and needs to send that updated
object to the relevant primary so it

2208
00:52:06,600 --> 00:52:06,610
object to the relevant primary so it
 

2209
00:52:06,610 --> 00:52:09,030
object to the relevant primary so it
sends the updated objects the primary

2210
00:52:09,030 --> 00:52:09,040
sends the updated objects the primary
 

2211
00:52:09,040 --> 00:52:15,150
sends the updated objects the primary
and as an as a new log entry in the

2212
00:52:15,150 --> 00:52:15,160
and as an as a new log entry in the
 

2213
00:52:15,160 --> 00:52:18,210
and as an as a new log entry in the
primaries log you know for this client

2214
00:52:18,210 --> 00:52:18,220
primaries log you know for this client
 

2215
00:52:18,220 --> 00:52:20,370
primaries log you know for this client
so the client really abusing already

2216
00:52:20,370 --> 00:52:20,380
so the client really abusing already
 

2217
00:52:20,380 --> 00:52:22,650
so the client really abusing already
made to append to the primaries log and

2218
00:52:22,650 --> 00:52:22,660
made to append to the primaries log and
 

2219
00:52:22,660 --> 00:52:27,210
made to append to the primaries log and
what it's appending is the object ID of

2220
00:52:27,210 --> 00:52:27,220
what it's appending is the object ID of
 

2221
00:52:27,220 --> 00:52:28,710
what it's appending is the object ID of
the writ of the object wants to write

2222
00:52:28,710 --> 00:52:28,720
the writ of the object wants to write
 

2223
00:52:28,720 --> 00:52:30,810
the writ of the object wants to write
the version number that the client

2224
00:52:30,810 --> 00:52:30,820
the version number that the client
 

2225
00:52:30,820 --> 00:52:33,830
the version number that the client
initially read when it read the object

2226
00:52:33,830 --> 00:52:33,840
initially read when it read the object
 

2227
00:52:33,840 --> 00:52:36,260
initially read when it read the object
and the new value

2228
00:52:36,260 --> 00:52:36,270
and the new value
 

2229
00:52:36,270 --> 00:52:38,420
and the new value
so it appends the object of yours number

2230
00:52:38,420 --> 00:52:38,430
so it appends the object of yours number
 

2231
00:52:38,430 --> 00:52:42,260
so it appends the object of yours number
and new value to the primary logon for

2232
00:52:42,260 --> 00:52:42,270
and new value to the primary logon for
 

2233
00:52:42,270 --> 00:52:43,430
and new value to the primary logon for
the primary beach of the charge that

2234
00:52:43,430 --> 00:52:43,440
the primary beach of the charge that
 

2235
00:52:43,440 --> 00:52:48,950
the primary beach of the charge that
it's written an object in so these I

2236
00:52:48,950 --> 00:52:48,960
it's written an object in so these I
 

2237
00:52:48,960 --> 00:52:51,160
it's written an object in so these I
guess what's going on here is that the

2238
00:52:51,160 --> 00:52:51,170
guess what's going on here is that the
 

2239
00:52:51,170 --> 00:52:53,450
guess what's going on here is that the
this transaction wrote two different

2240
00:52:53,450 --> 00:52:53,460
this transaction wrote two different
 

2241
00:52:53,460 --> 00:52:55,310
this transaction wrote two different
objects one on primary one and the other

2242
00:52:55,310 --> 00:52:55,320
objects one on primary one and the other
 

2243
00:52:55,320 --> 00:52:57,620
objects one on primary one and the other
on primary to know when this is done

2244
00:52:57,620 --> 00:52:57,630
on primary to know when this is done
 

2245
00:52:57,630 --> 00:52:59,630
on primary to know when this is done
when the transaction coordinator gets

2246
00:52:59,630 --> 00:52:59,640
when the transaction coordinator gets
 

2247
00:52:59,640 --> 00:53:05,270
when the transaction coordinator gets
back the well alright so now the these

2248
00:53:05,270 --> 00:53:05,280
back the well alright so now the these
 

2249
00:53:05,280 --> 00:53:07,040
back the well alright so now the these
new log records are sitting in the logs

2250
00:53:07,040 --> 00:53:07,050
new log records are sitting in the logs
 

2251
00:53:07,050 --> 00:53:09,410
new log records are sitting in the logs
of the primaries the primary though has

2252
00:53:09,410 --> 00:53:09,420
of the primaries the primary though has
 

2253
00:53:09,420 --> 00:53:11,630
of the primaries the primary though has
to actually actively process these log

2254
00:53:11,630 --> 00:53:11,640
to actually actively process these log
 

2255
00:53:11,640 --> 00:53:14,360
to actually actively process these log
entries because it needs to check and

2256
00:53:14,360 --> 00:53:14,370
entries because it needs to check and
 

2257
00:53:14,370 --> 00:53:15,950
entries because it needs to check and
they sort of do a number of checks

2258
00:53:15,950 --> 00:53:15,960
they sort of do a number of checks
 

2259
00:53:15,960 --> 00:53:18,550
they sort of do a number of checks
involved with validation to see if the

2260
00:53:18,550 --> 00:53:18,560
involved with validation to see if the
 

2261
00:53:18,560 --> 00:53:20,900
involved with validation to see if the
if this primary is part of the

2262
00:53:20,900 --> 00:53:20,910
if this primary is part of the
 

2263
00:53:20,910 --> 00:53:23,150
if this primary is part of the
transaction can be allowed to commit so

2264
00:53:23,150 --> 00:53:23,160
transaction can be allowed to commit so
 

2265
00:53:23,160 --> 00:53:25,760
transaction can be allowed to commit so
at this point we have to wait for each

2266
00:53:25,760 --> 00:53:25,770
at this point we have to wait for each
 

2267
00:53:25,770 --> 00:53:30,470
at this point we have to wait for each
primary to to poll the this clients log

2268
00:53:30,470 --> 00:53:30,480
primary to to poll the this clients log
 

2269
00:53:30,480 --> 00:53:32,180
primary to to poll the this clients log
in the primaries memory see that there's

2270
00:53:32,180 --> 00:53:32,190
in the primaries memory see that there's
 

2271
00:53:32,190 --> 00:53:34,310
in the primaries memory see that there's
a new log entry and process that new log

2272
00:53:34,310 --> 00:53:34,320
a new log entry and process that new log
 

2273
00:53:34,320 --> 00:53:39,200
a new log entry and process that new log
entry and then send a yes-or-no vote to

2274
00:53:39,200 --> 00:53:39,210
entry and then send a yes-or-no vote to
 

2275
00:53:39,210 --> 00:53:40,700
entry and then send a yes-or-no vote to
say whether it is or is not willing to

2276
00:53:40,700 --> 00:53:40,710
say whether it is or is not willing to
 

2277
00:53:40,710 --> 00:53:43,730
say whether it is or is not willing to
do its part of the transaction all right

2278
00:53:43,730 --> 00:53:43,740
do its part of the transaction all right
 

2279
00:53:43,740 --> 00:53:46,270
do its part of the transaction all right
so what does the primary do when it's

2280
00:53:46,270 --> 00:53:46,280
so what does the primary do when it's
 

2281
00:53:46,280 --> 00:53:51,530
so what does the primary do when it's
polling loop sees that an incoming lock

2282
00:53:51,530 --> 00:53:51,540
polling loop sees that an incoming lock
 

2283
00:53:51,540 --> 00:53:56,420
polling loop sees that an incoming lock
log entry from a client first of all if

2284
00:53:56,420 --> 00:53:56,430
log entry from a client first of all if
 

2285
00:53:56,430 --> 00:53:58,490
log entry from a client first of all if
that object with the object ID is

2286
00:53:58,490 --> 00:53:58,500
that object with the object ID is
 

2287
00:53:58,500 --> 00:54:02,030
that object with the object ID is
currently blocked then the primary

2288
00:54:02,030 --> 00:54:02,040
currently blocked then the primary
 

2289
00:54:02,040 --> 00:54:05,270
currently blocked then the primary
rejects this lock message and sends back

2290
00:54:05,270 --> 00:54:05,280
rejects this lock message and sends back
 

2291
00:54:05,280 --> 00:54:07,490
rejects this lock message and sends back
a message to the client using RDMA

2292
00:54:07,490 --> 00:54:07,500
a message to the client using RDMA
 

2293
00:54:07,500 --> 00:54:09,590
a message to the client using RDMA
saying no that this transaction cannot

2294
00:54:09,590 --> 00:54:09,600
saying no that this transaction cannot
 

2295
00:54:09,600 --> 00:54:11,780
saying no that this transaction cannot
be allowed to proceed I'm voting no and

2296
00:54:11,780 --> 00:54:11,790
be allowed to proceed I'm voting no and
 

2297
00:54:11,790 --> 00:54:13,460
be allowed to proceed I'm voting no and
two-phase commit and that will cause the

2298
00:54:13,460 --> 00:54:13,470
two-phase commit and that will cause the
 

2299
00:54:13,470 --> 00:54:14,930
two-phase commit and that will cause the
transaction coordinator to abort the

2300
00:54:14,930 --> 00:54:14,940
transaction coordinator to abort the
 

2301
00:54:14,940 --> 00:54:18,280
transaction coordinator to abort the
transaction and the other is not locked

2302
00:54:18,280 --> 00:54:18,290
transaction and the other is not locked
 

2303
00:54:18,290 --> 00:54:21,020
transaction and the other is not locked
then the next thing the primary does is

2304
00:54:21,020 --> 00:54:21,030
then the next thing the primary does is
 

2305
00:54:21,030 --> 00:54:22,760
then the next thing the primary does is
check the version numbers it checks to

2306
00:54:22,760 --> 00:54:22,770
check the version numbers it checks to
 

2307
00:54:22,770 --> 00:54:24,140
check the version numbers it checks to
make sure that the version number that

2308
00:54:24,140 --> 00:54:24,150
make sure that the version number that
 

2309
00:54:24,150 --> 00:54:26,180
make sure that the version number that
the client sent it that is the version

2310
00:54:26,180 --> 00:54:26,190
the client sent it that is the version
 

2311
00:54:26,190 --> 00:54:28,420
the client sent it that is the version
number of the client originally read is

2312
00:54:28,420 --> 00:54:28,430
number of the client originally read is
 

2313
00:54:28,430 --> 00:54:31,820
number of the client originally read is
unchanged and if the version numbers

2314
00:54:31,820 --> 00:54:31,830
unchanged and if the version numbers
 

2315
00:54:31,830 --> 00:54:34,280
unchanged and if the version numbers
changed that means that between when our

2316
00:54:34,280 --> 00:54:34,290
changed that means that between when our
 

2317
00:54:34,290 --> 00:54:35,840
changed that means that between when our
transaction read and when it wrote

2318
00:54:35,840 --> 00:54:35,850
transaction read and when it wrote
 

2319
00:54:35,850 --> 00:54:38,750
transaction read and when it wrote
somebody else wrote the object if the

2320
00:54:38,750 --> 00:54:38,760
somebody else wrote the object if the
 

2321
00:54:38,760 --> 00:54:39,890
somebody else wrote the object if the
version numbers changed and so the

2322
00:54:39,890 --> 00:54:39,900
version numbers changed and so the
 

2323
00:54:39,900 --> 00:54:41,780
version numbers changed and so the
version numbers changed again the

2324
00:54:41,780 --> 00:54:41,790
version numbers changed again the
 

2325
00:54:41,790 --> 00:54:44,330
version numbers changed again the
primary will respond no and forbid the

2326
00:54:44,330 --> 00:54:44,340
primary will respond no and forbid the
 

2327
00:54:44,340 --> 00:54:47,030
primary will respond no and forbid the
transaction from continuing but if the

2328
00:54:47,030 --> 00:54:47,040
transaction from continuing but if the
 

2329
00:54:47,040 --> 00:54:48,230
transaction from continuing but if the
version number is the same in the lock

2330
00:54:48,230 --> 00:54:48,240
version number is the same in the lock
 

2331
00:54:48,240 --> 00:54:51,070
version number is the same in the lock
that's not set

2332
00:54:51,070 --> 00:54:51,080

 

2333
00:54:51,080 --> 00:54:57,970

and the primary will set the lock and

2334
00:54:57,970 --> 00:54:57,980
and the primary will set the lock and
 

2335
00:54:57,980 --> 00:55:00,470
and the primary will set the lock and
return a positive response back to the

2336
00:55:00,470 --> 00:55:00,480
return a positive response back to the
 

2337
00:55:00,480 --> 00:55:06,080
return a positive response back to the
client now because the primary's

2338
00:55:06,080 --> 00:55:06,090
client now because the primary's
 

2339
00:55:06,090 --> 00:55:08,150
client now because the primary's
multi-threaded running on multiple CPUs

2340
00:55:08,150 --> 00:55:08,160
multi-threaded running on multiple CPUs
 

2341
00:55:08,160 --> 00:55:10,870
multi-threaded running on multiple CPUs
and there may be other transactions

2342
00:55:10,870 --> 00:55:10,880
and there may be other transactions
 

2343
00:55:10,880 --> 00:55:13,790
and there may be other transactions
there may be other CPUs reading other

2344
00:55:13,790 --> 00:55:13,800
there may be other CPUs reading other
 

2345
00:55:13,800 --> 00:55:16,280
there may be other CPUs reading other
incoming log cues from other clients at

2346
00:55:16,280 --> 00:55:16,290
incoming log cues from other clients at
 

2347
00:55:16,290 --> 00:55:18,890
incoming log cues from other clients at
the same time on the same primary there

2348
00:55:18,890 --> 00:55:18,900
the same time on the same primary there
 

2349
00:55:18,900 --> 00:55:20,240
the same time on the same primary there
may be races between different

2350
00:55:20,240 --> 00:55:20,250
may be races between different
 

2351
00:55:20,250 --> 00:55:23,480
may be races between different
transactions or lock the clock record

2352
00:55:23,480 --> 00:55:23,490
transactions or lock the clock record
 

2353
00:55:23,490 --> 00:55:26,470
transactions or lock the clock record
processing from different transactions

2354
00:55:26,470 --> 00:55:26,480
processing from different transactions
 

2355
00:55:26,480 --> 00:55:29,630
processing from different transactions
trying to modify the same object so the

2356
00:55:29,630 --> 00:55:29,640
trying to modify the same object so the
 

2357
00:55:29,640 --> 00:55:31,580
trying to modify the same object so the
primary actually uses an atomic

2358
00:55:31,580 --> 00:55:31,590
primary actually uses an atomic
 

2359
00:55:31,590 --> 00:55:33,590
primary actually uses an atomic
instruction a compare and swap

2360
00:55:33,590 --> 00:55:33,600
instruction a compare and swap
 

2361
00:55:33,600 --> 00:55:39,830
instruction a compare and swap
instruction in order to both check check

2362
00:55:39,830 --> 00:55:39,840
instruction in order to both check check
 

2363
00:55:39,840 --> 00:55:42,020
instruction in order to both check check
the version number and lock and set the

2364
00:55:42,020 --> 00:55:42,030
the version number and lock and set the
 

2365
00:55:42,030 --> 00:55:44,810
the version number and lock and set the
lock a bit on that version number as an

2366
00:55:44,810 --> 00:55:44,820
lock a bit on that version number as an
 

2367
00:55:44,820 --> 00:55:46,910
lock a bit on that version number as an
atomic operation and this is the reason

2368
00:55:46,910 --> 00:55:46,920
atomic operation and this is the reason
 

2369
00:55:46,920 --> 00:55:48,440
atomic operation and this is the reason
why the lock of it has to be in the high

2370
00:55:48,440 --> 00:55:48,450
why the lock of it has to be in the high
 

2371
00:55:48,450 --> 00:55:49,760
why the lock of it has to be in the high
bits of the version number so that a

2372
00:55:49,760 --> 00:55:49,770
bits of the version number so that a
 

2373
00:55:49,770 --> 00:55:55,130
bits of the version number so that a
single instruction can do a compare and

2374
00:55:55,130 --> 00:55:55,140
single instruction can do a compare and
 

2375
00:55:55,140 --> 00:55:56,990
single instruction can do a compare and
swap on the version number and the lock

2376
00:55:56,990 --> 00:55:57,000
swap on the version number and the lock
 

2377
00:55:57,000 --> 00:56:02,170
swap on the version number and the lock
bit okay now one thing to note is that

2378
00:56:02,170 --> 00:56:02,180
bit okay now one thing to note is that
 

2379
00:56:02,180 --> 00:56:05,150
bit okay now one thing to note is that
if the objects already locked

2380
00:56:05,150 --> 00:56:05,160
if the objects already locked
 

2381
00:56:05,160 --> 00:56:07,490
if the objects already locked
there's no blocking there's no waiting

2382
00:56:07,490 --> 00:56:07,500
there's no blocking there's no waiting
 

2383
00:56:07,500 --> 00:56:08,990
there's no blocking there's no waiting
for the lock to be released the primary

2384
00:56:08,990 --> 00:56:09,000
for the lock to be released the primary
 

2385
00:56:09,000 --> 00:56:12,200
for the lock to be released the primary
simply sends back a know if some other

2386
00:56:12,200 --> 00:56:12,210
simply sends back a know if some other
 

2387
00:56:12,210 --> 00:56:15,050
simply sends back a know if some other
transaction has it locked alright any

2388
00:56:15,050 --> 00:56:15,060
transaction has it locked alright any
 

2389
00:56:15,060 --> 00:56:18,380
transaction has it locked alright any
questions about the lock fees of of

2390
00:56:18,380 --> 00:56:18,390
questions about the lock fees of of
 

2391
00:56:18,390 --> 00:56:23,750
questions about the lock fees of of
Committee all right back in the trend

2392
00:56:23,750 --> 00:56:23,760
Committee all right back in the trend
 

2393
00:56:23,760 --> 00:56:25,220
Committee all right back in the trend
head in the client which is acting his

2394
00:56:25,220 --> 00:56:25,230
head in the client which is acting his
 

2395
00:56:25,230 --> 00:56:26,510
head in the client which is acting his
transaction coordinator it waits for

2396
00:56:26,510 --> 00:56:26,520
transaction coordinator it waits for
 

2397
00:56:26,520 --> 00:56:28,940
transaction coordinator it waits for
responses from all the primaries from

2398
00:56:28,940 --> 00:56:28,950
responses from all the primaries from
 

2399
00:56:28,950 --> 00:56:31,940
responses from all the primaries from
the primaries of the shard so for every

2400
00:56:31,940 --> 00:56:31,950
the primaries of the shard so for every
 

2401
00:56:31,950 --> 00:56:34,730
the primaries of the shard so for every
object that the transaction modified if

2402
00:56:34,730 --> 00:56:34,740
object that the transaction modified if
 

2403
00:56:34,740 --> 00:56:37,040
object that the transaction modified if
any of them say no if they need them

2404
00:56:37,040 --> 00:56:37,050
any of them say no if they need them
 

2405
00:56:37,050 --> 00:56:38,180
any of them say no if they need them
reject the transaction then the

2406
00:56:38,180 --> 00:56:38,190
reject the transaction then the
 

2407
00:56:38,190 --> 00:56:39,830
reject the transaction then the
transaction coordinator aborts the whole

2408
00:56:39,830 --> 00:56:39,840
transaction coordinator aborts the whole
 

2409
00:56:39,840 --> 00:56:42,170
transaction coordinator aborts the whole
transaction and actually sends out

2410
00:56:42,170 --> 00:56:42,180
transaction and actually sends out
 

2411
00:56:42,180 --> 00:56:43,910
transaction and actually sends out
messages to all the primaries saying I

2412
00:56:43,910 --> 00:56:43,920
messages to all the primaries saying I
 

2413
00:56:43,920 --> 00:56:46,580
messages to all the primaries saying I
changed my mind I don't want to commit

2414
00:56:46,580 --> 00:56:46,590
changed my mind I don't want to commit
 

2415
00:56:46,590 --> 00:56:48,980
changed my mind I don't want to commit
this transaction after all but if they

2416
00:56:48,980 --> 00:56:48,990
this transaction after all but if they
 

2417
00:56:48,990 --> 00:56:50,540
this transaction after all but if they
all answered yes of all the primaries

2418
00:56:50,540 --> 00:56:50,550
all answered yes of all the primaries
 

2419
00:56:50,550 --> 00:56:54,590
all answered yes of all the primaries
answer yes then the transaction

2420
00:56:54,590 --> 00:56:54,600
answer yes then the transaction
 

2421
00:56:54,600 --> 00:56:56,810
answer yes then the transaction
coordinator thinks that decides that the

2422
00:56:56,810 --> 00:56:56,820
coordinator thinks that decides that the
 

2423
00:56:56,820 --> 00:56:59,990
coordinator thinks that decides that the
transaction can actually commit but the

2424
00:56:59,990 --> 00:57:00,000
transaction can actually commit but the
 

2425
00:57:00,000 --> 00:57:01,400
transaction can actually commit but the
primaries of course don't know whether

2426
00:57:01,400 --> 00:57:01,410
primaries of course don't know whether
 

2427
00:57:01,410 --> 00:57:02,810
primaries of course don't know whether
they all voted yes

2428
00:57:02,810 --> 00:57:02,820
they all voted yes
 

2429
00:57:02,820 --> 00:57:05,540
they all voted yes
or not so the transaction coordinator

2430
00:57:05,540 --> 00:57:05,550
or not so the transaction coordinator
 

2431
00:57:05,550 --> 00:57:07,970
or not so the transaction coordinator
has to notify every ball the primary so

2432
00:57:07,970 --> 00:57:07,980
has to notify every ball the primary so
 

2433
00:57:07,980 --> 00:57:10,550
has to notify every ball the primary so
yes deed everybody voted yes so please

2434
00:57:10,550 --> 00:57:10,560
yes deed everybody voted yes so please
 

2435
00:57:10,560 --> 00:57:14,650
yes deed everybody voted yes so please
do actually commit this and the way the

2436
00:57:14,650 --> 00:57:14,660
do actually commit this and the way the
 

2437
00:57:14,660 --> 00:57:17,390
do actually commit this and the way the
client does this is by appending another

2438
00:57:17,390 --> 00:57:17,400
client does this is by appending another
 

2439
00:57:17,400 --> 00:57:20,630
client does this is by appending another
record to the logs of the primaries for

2440
00:57:20,630 --> 00:57:20,640
record to the logs of the primaries for
 

2441
00:57:20,640 --> 00:57:23,060
record to the logs of the primaries for
each modified object this time it's a

2442
00:57:23,060 --> 00:57:23,070
each modified object this time it's a
 

2443
00:57:23,070 --> 00:57:26,440
each modified object this time it's a
commit backup record that it's a pending

2444
00:57:26,440 --> 00:57:26,450
commit backup record that it's a pending
 

2445
00:57:26,450 --> 00:57:30,350
commit backup record that it's a pending
and the this time the transaction

2446
00:57:30,350 --> 00:57:30,360
and the this time the transaction
 

2447
00:57:30,360 --> 00:57:33,710
and the this time the transaction
coordinator I'm sorry I did commit

2448
00:57:33,710 --> 00:57:33,720
coordinator I'm sorry I did commit
 

2449
00:57:33,720 --> 00:57:35,900
coordinator I'm sorry I did commit
primary I'm skipping over valide didn't

2450
00:57:35,900 --> 00:57:35,910
primary I'm skipping over valide didn't
 

2451
00:57:35,910 --> 00:57:37,160
primary I'm skipping over valide didn't
commit backup for now I'll talk about

2452
00:57:37,160 --> 00:57:37,170
commit backup for now I'll talk about
 

2453
00:57:37,170 --> 00:57:39,620
commit backup for now I'll talk about
those later so just ignore those for the

2454
00:57:39,620 --> 00:57:39,630
those later so just ignore those for the
 

2455
00:57:39,630 --> 00:57:42,020
those later so just ignore those for the
moment the transaction coordinator goes

2456
00:57:42,020 --> 00:57:42,030
moment the transaction coordinator goes
 

2457
00:57:42,030 --> 00:57:44,240
moment the transaction coordinator goes
on to commit primary sends pens that

2458
00:57:44,240 --> 00:57:44,250
on to commit primary sends pens that
 

2459
00:57:44,250 --> 00:57:47,330
on to commit primary sends pens that
commit primary to each primaries log and

2460
00:57:47,330 --> 00:57:47,340
commit primary to each primaries log and
 

2461
00:57:47,340 --> 00:57:49,220
commit primary to each primaries log and
the transaction coordinator only has to

2462
00:57:49,220 --> 00:57:49,230
the transaction coordinator only has to
 

2463
00:57:49,230 --> 00:57:51,700
the transaction coordinator only has to
wait for the hardware RDMA

2464
00:57:51,700 --> 00:57:51,710
wait for the hardware RDMA
 

2465
00:57:51,710 --> 00:57:54,260
wait for the hardware RDMA
acknowledgments it doesn't have to wait

2466
00:57:54,260 --> 00:57:54,270
acknowledgments it doesn't have to wait
 

2467
00:57:54,270 --> 00:57:58,430
acknowledgments it doesn't have to wait
for the primary just actually process

2468
00:57:58,430 --> 00:57:58,440
for the primary just actually process
 

2469
00:57:58,440 --> 00:58:01,040
for the primary just actually process
the log record the transaction

2470
00:58:01,040 --> 00:58:01,050
the log record the transaction
 

2471
00:58:01,050 --> 00:58:02,900
the log record the transaction
coordinator it turns out as soon as it

2472
00:58:02,900 --> 00:58:02,910
coordinator it turns out as soon as it
 

2473
00:58:02,910 --> 00:58:04,550
coordinator it turns out as soon as it
gets a single acknowledgment from any of

2474
00:58:04,550 --> 00:58:04,560
gets a single acknowledgment from any of
 

2475
00:58:04,560 --> 00:58:08,750
gets a single acknowledgment from any of
the primaries it can return yes the okay

2476
00:58:08,750 --> 00:58:08,760
the primaries it can return yes the okay
 

2477
00:58:08,760 --> 00:58:10,580
the primaries it can return yes the okay
equals true to the transactions

2478
00:58:10,580 --> 00:58:10,590
equals true to the transactions
 

2479
00:58:10,590 --> 00:58:12,940
equals true to the transactions
signifying that the transaction six

2480
00:58:12,940 --> 00:58:12,950
signifying that the transaction six
 

2481
00:58:12,950 --> 00:58:16,040
signifying that the transaction six
succeeded and then there's another stage

2482
00:58:16,040 --> 00:58:16,050
succeeded and then there's another stage
 

2483
00:58:16,050 --> 00:58:20,090
succeeded and then there's another stage
later on where the once the transaction

2484
00:58:20,090 --> 00:58:20,100
later on where the once the transaction
 

2485
00:58:20,100 --> 00:58:21,890
later on where the once the transaction
coordinator knows that every primary

2486
00:58:21,890 --> 00:58:21,900
coordinator knows that every primary
 

2487
00:58:21,900 --> 00:58:24,350
coordinator knows that every primary
knows that the transaction coordinated

2488
00:58:24,350 --> 00:58:24,360
knows that the transaction coordinated
 

2489
00:58:24,360 --> 00:58:29,420
knows that the transaction coordinated
committed you can tell all the primaries

2490
00:58:29,420 --> 00:58:29,430
committed you can tell all the primaries
 

2491
00:58:29,430 --> 00:58:30,620
committed you can tell all the primaries
that they can discard all the log

2492
00:58:30,620 --> 00:58:30,630
that they can discard all the log
 

2493
00:58:30,630 --> 00:58:35,240
that they can discard all the log
entries for this transaction okay now

2494
00:58:35,240 --> 00:58:35,250
entries for this transaction okay now
 

2495
00:58:35,250 --> 00:58:37,790
entries for this transaction okay now
there's one last thing that has to

2496
00:58:37,790 --> 00:58:37,800
there's one last thing that has to
 

2497
00:58:37,800 --> 00:58:40,070
there's one last thing that has to
happen the primaries which are looking

2498
00:58:40,070 --> 00:58:40,080
happen the primaries which are looking
 

2499
00:58:40,080 --> 00:58:42,400
happen the primaries which are looking
at the logs their polling the Long's

2500
00:58:42,400 --> 00:58:42,410
at the logs their polling the Long's
 

2501
00:58:42,410 --> 00:58:44,360
at the logs their polling the Long's
they'll notice that there's a commit

2502
00:58:44,360 --> 00:58:44,370
they'll notice that there's a commit
 

2503
00:58:44,370 --> 00:58:46,820
they'll notice that there's a commit
primary record at some point and then on

2504
00:58:46,820 --> 00:58:46,830
primary record at some point and then on
 

2505
00:58:46,830 --> 00:58:49,040
primary record at some point and then on
the primary that receives the commit

2506
00:58:49,040 --> 00:58:49,050
the primary that receives the commit
 

2507
00:58:49,050 --> 00:58:53,090
the primary that receives the commit
primary log entry will it knows that it

2508
00:58:53,090 --> 00:58:53,100
primary log entry will it knows that it
 

2509
00:58:53,100 --> 00:58:58,010
primary log entry will it knows that it
had locked that object previously and

2510
00:58:58,010 --> 00:58:58,020
had locked that object previously and
 

2511
00:58:58,020 --> 00:58:59,420
had locked that object previously and
that the object must still be locked so

2512
00:58:59,420 --> 00:58:59,430
that the object must still be locked so
 

2513
00:58:59,430 --> 00:59:01,700
that the object must still be locked so
what the primary will do is update the

2514
00:59:01,700 --> 00:59:01,710
what the primary will do is update the
 

2515
00:59:01,710 --> 00:59:03,410
what the primary will do is update the
object in its memory with the new

2516
00:59:03,410 --> 00:59:03,420
object in its memory with the new
 

2517
00:59:03,420 --> 00:59:05,420
object in its memory with the new
contents that were previously sent in

2518
00:59:05,420 --> 00:59:05,430
contents that were previously sent in
 

2519
00:59:05,430 --> 00:59:07,490
contents that were previously sent in
the lock message I'm increment the

2520
00:59:07,490 --> 00:59:07,500
the lock message I'm increment the
 

2521
00:59:07,500 --> 00:59:09,020
the lock message I'm increment the
version number associated with that

2522
00:59:09,020 --> 00:59:09,030
version number associated with that
 

2523
00:59:09,030 --> 00:59:11,120
version number associated with that
object and finally clear the lock bit on

2524
00:59:11,120 --> 00:59:11,130
object and finally clear the lock bit on
 

2525
00:59:11,130 --> 00:59:13,850
object and finally clear the lock bit on
that object and what that means is that

2526
00:59:13,850 --> 00:59:13,860
that object and what that means is that
 

2527
00:59:13,860 --> 00:59:16,180
that object and what that means is that
as soon as a primary

2528
00:59:16,180 --> 00:59:16,190
as soon as a primary
 

2529
00:59:16,190 --> 00:59:18,700
as soon as a primary
receives and processes a commit primary

2530
00:59:18,700 --> 00:59:18,710
receives and processes a commit primary
 

2531
00:59:18,710 --> 00:59:21,730
receives and processes a commit primary
log message it may since it clears the

2532
00:59:21,730 --> 00:59:21,740
log message it may since it clears the
 

2533
00:59:21,740 --> 00:59:24,339
log message it may since it clears the
lock a bit and updates the data it may

2534
00:59:24,339 --> 00:59:24,349
lock a bit and updates the data it may
 

2535
00:59:24,349 --> 00:59:27,069
lock a bit and updates the data it may
well expose this new data to other

2536
00:59:27,069 --> 00:59:27,079
well expose this new data to other
 

2537
00:59:27,079 --> 00:59:28,690
well expose this new data to other
transactions other transactions after

2538
00:59:28,690 --> 00:59:28,700
transactions other transactions after
 

2539
00:59:28,700 --> 00:59:30,910
transactions other transactions after
this point are free to use it are free

2540
00:59:30,910 --> 00:59:30,920
this point are free to use it are free
 

2541
00:59:30,920 --> 00:59:34,089
this point are free to use it are free
to use the object with its new value and

2542
00:59:34,089 --> 00:59:34,099
to use the object with its new value and
 

2543
00:59:34,099 --> 00:59:40,710
to use the object with its new value and
new version number all right I'm gonna

2544
00:59:40,710 --> 00:59:40,720
new version number all right I'm gonna
 

2545
00:59:40,720 --> 00:59:44,290
new version number all right I'm gonna
do an example any questions about the

2546
00:59:44,290 --> 00:59:44,300
do an example any questions about the
 

2547
00:59:44,300 --> 00:59:46,510
do an example any questions about the
machinery before I start thinking about

2548
00:59:46,510 --> 00:59:46,520
machinery before I start thinking about
 

2549
00:59:46,520 --> 00:59:51,870
machinery before I start thinking about
an example feel free to ask questions

2550
00:59:51,870 --> 00:59:51,880
an example feel free to ask questions
 

2551
00:59:51,880 --> 00:59:55,510
an example feel free to ask questions
any time alright so how about an example

2552
00:59:55,510 --> 00:59:55,520
any time alright so how about an example
 

2553
00:59:55,520 --> 00:59:59,140
any time alright so how about an example
let's suppose we have two transactions

2554
00:59:59,140 --> 00:59:59,150
let's suppose we have two transactions
 

2555
00:59:59,150 --> 01:00:02,079
let's suppose we have two transactions
transaction one and transaction two and

2556
01:00:02,079 --> 01:00:02,089
transaction one and transaction two and
 

2557
01:00:02,089 --> 01:00:03,339
transaction one and transaction two and
they're both trying to do the same thing

2558
01:00:03,339 --> 01:00:03,349
they're both trying to do the same thing
 

2559
01:00:03,349 --> 01:00:09,790
they're both trying to do the same thing
they both just wanna increment X X is

2560
01:00:09,790 --> 01:00:09,800
they both just wanna increment X X is
 

2561
01:00:09,800 --> 01:00:12,370
they both just wanna increment X X is
the object sitting off in some servers

2562
01:00:12,370 --> 01:00:12,380
the object sitting off in some servers
 

2563
01:00:12,380 --> 01:00:18,040
the object sitting off in some servers
memory so so both we got two

2564
01:00:18,040 --> 01:00:18,050
memory so so both we got two
 

2565
01:00:18,050 --> 01:00:19,450
memory so so both we got two
transactions running running through

2566
01:00:19,450 --> 01:00:19,460
transactions running running through
 

2567
01:00:19,460 --> 01:00:21,040
transactions running running through
this before we look into what actually

2568
01:00:21,040 --> 01:00:21,050
this before we look into what actually
 

2569
01:00:21,050 --> 01:00:22,930
this before we look into what actually
happens we should remind ourselves what

2570
01:00:22,930 --> 01:00:22,940
happens we should remind ourselves what
 

2571
01:00:22,940 --> 01:00:26,410
happens we should remind ourselves what
the valid possibilities are for the

2572
01:00:26,410 --> 01:00:26,420
the valid possibilities are for the
 

2573
01:00:26,420 --> 01:00:30,609
the valid possibilities are for the
outcomes so and that's all about

2574
01:00:30,609 --> 01:00:30,619
outcomes so and that's all about
 

2575
01:00:30,619 --> 01:00:32,290
outcomes so and that's all about
serializability farm guaranteed

2576
01:00:32,290 --> 01:00:32,300
serializability farm guaranteed
 

2577
01:00:32,300 --> 01:00:33,849
serializability farm guaranteed
serialize ability so that means that

2578
01:00:33,849 --> 01:00:33,859
serialize ability so that means that
 

2579
01:00:33,859 --> 01:00:35,680
serialize ability so that means that
whatever farm actually does it has to be

2580
01:00:35,680 --> 01:00:35,690
whatever farm actually does it has to be
 

2581
01:00:35,690 --> 01:00:37,930
whatever farm actually does it has to be
equivalent to some one at a time

2582
01:00:37,930 --> 01:00:37,940
equivalent to some one at a time
 

2583
01:00:37,940 --> 01:00:40,210
equivalent to some one at a time
execution of these two transactions so

2584
01:00:40,210 --> 01:00:40,220
execution of these two transactions so
 

2585
01:00:40,220 --> 01:00:41,950
execution of these two transactions so
we're allowed to see was the results you

2586
01:00:41,950 --> 01:00:41,960
we're allowed to see was the results you
 

2587
01:00:41,960 --> 01:00:44,650
we're allowed to see was the results you
would see if t1 ran and then strictly

2588
01:00:44,650 --> 01:00:44,660
would see if t1 ran and then strictly
 

2589
01:00:44,660 --> 01:00:47,380
would see if t1 ran and then strictly
afterwards t2 ran or we can see the

2590
01:00:47,380 --> 01:00:47,390
afterwards t2 ran or we can see the
 

2591
01:00:47,390 --> 01:00:50,260
afterwards t2 ran or we can see the
results that could ensue if t2 ran and

2592
01:00:50,260 --> 01:00:50,270
results that could ensue if t2 ran and
 

2593
01:00:50,270 --> 01:00:52,270
results that could ensue if t2 ran and
then t1 run those are the only

2594
01:00:52,270 --> 01:00:52,280
then t1 run those are the only
 

2595
01:00:52,280 --> 01:00:57,220
then t1 run those are the only
possibilities now in fact farm is

2596
01:00:57,220 --> 01:00:57,230
possibilities now in fact farm is
 

2597
01:00:57,230 --> 01:01:00,220
possibilities now in fact farm is
entitled to abort a transaction so we

2598
01:01:00,220 --> 01:01:00,230
entitled to abort a transaction so we
 

2599
01:01:00,230 --> 01:01:01,569
entitled to abort a transaction so we
also have to consider the possibility

2600
01:01:01,569 --> 01:01:01,579
also have to consider the possibility
 

2601
01:01:01,579 --> 01:01:03,490
also have to consider the possibility
that one of the two transactions aborted

2602
01:01:03,490 --> 01:01:03,500
that one of the two transactions aborted
 

2603
01:01:03,500 --> 01:01:06,400
that one of the two transactions aborted
or indeed that they both aborted I since

2604
01:01:06,400 --> 01:01:06,410
or indeed that they both aborted I since
 

2605
01:01:06,410 --> 01:01:08,349
or indeed that they both aborted I since
they're doing both doing the same thing

2606
01:01:08,349 --> 01:01:08,359
they're doing both doing the same thing
 

2607
01:01:08,359 --> 01:01:09,970
they're doing both doing the same thing
there's a certain amount of symmetry

2608
01:01:09,970 --> 01:01:09,980
there's a certain amount of symmetry
 

2609
01:01:09,980 --> 01:01:15,069
there's a certain amount of symmetry
here so one possibility is that they

2610
01:01:15,069 --> 01:01:15,079
here so one possibility is that they
 

2611
01:01:15,079 --> 01:01:18,400
here so one possibility is that they
both committed and that means two

2612
01:01:18,400 --> 01:01:18,410
both committed and that means two
 

2613
01:01:18,410 --> 01:01:20,589
both committed and that means two
increments happen so one legal

2614
01:01:20,589 --> 01:01:20,599
increments happen so one legal
 

2615
01:01:20,599 --> 01:01:25,349
increments happen so one legal
possibilities that X is equal to 2 and

2616
01:01:25,349 --> 01:01:25,359

 

2617
01:01:25,359 --> 01:01:28,700

both then the TX

2618
01:01:28,700 --> 01:01:28,710
both then the TX
 

2619
01:01:28,710 --> 01:01:30,380
both then the TX
it has to agree with whether things a

2620
01:01:30,380 --> 01:01:30,390
it has to agree with whether things a
 

2621
01:01:30,390 --> 01:01:35,480
it has to agree with whether things a
bit or aborted or committed so that both

2622
01:01:35,480 --> 01:01:35,490
bit or aborted or committed so that both
 

2623
01:01:35,490 --> 01:01:40,160
bit or aborted or committed so that both
transactions need to CTX commit returned

2624
01:01:40,160 --> 01:01:40,170
transactions need to CTX commit returned
 

2625
01:01:40,170 --> 01:01:44,810
transactions need to CTX commit returned
true in this case another possibility is

2626
01:01:44,810 --> 01:01:44,820
true in this case another possibility is
 

2627
01:01:44,820 --> 01:01:46,940
true in this case another possibility is
that only one of them transactions

2628
01:01:46,940 --> 01:01:46,950
that only one of them transactions
 

2629
01:01:46,950 --> 01:01:48,920
that only one of them transactions
committed and the other aborted and then

2630
01:01:48,920 --> 01:01:48,930
committed and the other aborted and then
 

2631
01:01:48,930 --> 01:01:52,820
committed and the other aborted and then
we want to see only one true and the

2632
01:01:52,820 --> 01:01:52,830
we want to see only one true and the
 

2633
01:01:52,830 --> 01:01:56,810
we want to see only one true and the
other false and another possibilities

2634
01:01:56,810 --> 01:01:56,820
other false and another possibilities
 

2635
01:01:56,820 --> 01:01:58,609
other false and another possibilities
maybe they both aborted we don't think

2636
01:01:58,609 --> 01:01:58,619
maybe they both aborted we don't think
 

2637
01:01:58,619 --> 01:02:00,890
maybe they both aborted we don't think
this could necessarily happen but it's

2638
01:02:00,890 --> 01:02:00,900
this could necessarily happen but it's
 

2639
01:02:00,900 --> 01:02:03,710
this could necessarily happen but it's
actually legal so that X isn't changed

2640
01:02:03,710 --> 01:02:03,720
actually legal so that X isn't changed
 

2641
01:02:03,720 --> 01:02:09,640
actually legal so that X isn't changed
and we want both to get false back from

2642
01:02:09,640 --> 01:02:09,650

 

2643
01:02:09,650 --> 01:02:14,540

TX commit so we better better not see

2644
01:02:14,540 --> 01:02:14,550
TX commit so we better better not see
 

2645
01:02:14,550 --> 01:02:21,220
TX commit so we better better not see
anything other than these three options

2646
01:02:21,220 --> 01:02:21,230

 

2647
01:02:21,230 --> 01:02:24,050

all right so of course what happens

2648
01:02:24,050 --> 01:02:24,060
all right so of course what happens
 

2649
01:02:24,060 --> 01:02:31,540
all right so of course what happens
depends on the timing so I'm going to

2650
01:02:31,540 --> 01:02:31,550

 

2651
01:02:31,550 --> 01:02:33,410

integrate out various different ways

2652
01:02:33,410 --> 01:02:33,420
integrate out various different ways
 

2653
01:02:33,420 --> 01:02:35,839
integrate out various different ways
that the commit protocol could in early

2654
01:02:35,839 --> 01:02:35,849
that the commit protocol could in early
 

2655
01:02:35,849 --> 01:02:39,339
that the commit protocol could in early
even for convenience I have a handy

2656
01:02:39,339 --> 01:02:39,349
even for convenience I have a handy
 

2657
01:02:39,349 --> 01:02:41,750
even for convenience I have a handy
reminder of what the actual commit

2658
01:02:41,750 --> 01:02:41,760
reminder of what the actual commit
 

2659
01:02:41,760 --> 01:02:46,310
reminder of what the actual commit
protocol is here so one possibility is

2660
01:02:46,310 --> 01:02:46,320
protocol is here so one possibility is
 

2661
01:02:46,320 --> 01:02:51,920
protocol is here so one possibility is
that they run exactly in lockstep they

2662
01:02:51,920 --> 01:02:51,930
that they run exactly in lockstep they
 

2663
01:02:51,930 --> 01:02:55,460
that they run exactly in lockstep they
both send all their messages at the same

2664
01:02:55,460 --> 01:02:55,470
both send all their messages at the same
 

2665
01:02:55,470 --> 01:02:57,800
both send all their messages at the same
time they both read at the same time I'm

2666
01:02:57,800 --> 01:02:57,810
time they both read at the same time I'm
 

2667
01:02:57,810 --> 01:02:59,329
time they both read at the same time I'm
going to assume that X starts out as

2668
01:02:59,329 --> 01:02:59,339
going to assume that X starts out as
 

2669
01:02:59,339 --> 01:03:00,800
going to assume that X starts out as
zero if they both read at the same time

2670
01:03:00,800 --> 01:03:00,810
zero if they both read at the same time
 

2671
01:03:00,810 --> 01:03:03,109
zero if they both read at the same time
that we're going to see zero I assume

2672
01:03:03,109 --> 01:03:03,119
that we're going to see zero I assume
 

2673
01:03:03,119 --> 01:03:05,030
that we're going to see zero I assume
they both sent out lakh messages at the

2674
01:03:05,030 --> 01:03:05,040
they both sent out lakh messages at the
 

2675
01:03:05,040 --> 01:03:08,650
they both sent out lakh messages at the
same time

2676
01:03:08,650 --> 01:03:08,660

 

2677
01:03:08,660 --> 01:03:10,059

and indeed they accompany their log

2678
01:03:10,059 --> 01:03:10,069
and indeed they accompany their log
 

2679
01:03:10,069 --> 01:03:11,710
and indeed they accompany their log
messages with the value one since

2680
01:03:11,710 --> 01:03:11,720
messages with the value one since
 

2681
01:03:11,720 --> 01:03:13,630
messages with the value one since
they're adding 1 to it and that if they

2682
01:03:13,630 --> 01:03:13,640
they're adding 1 to it and that if they
 

2683
01:03:13,640 --> 01:03:16,299
they're adding 1 to it and that if they
commit if they walk messages say yes

2684
01:03:16,299 --> 01:03:16,309
commit if they walk messages say yes
 

2685
01:03:16,309 --> 01:03:19,660
commit if they walk messages say yes
then they would if they did both commit

2686
01:03:19,660 --> 01:03:19,670
then they would if they did both commit
 

2687
01:03:19,670 --> 01:03:25,569
then they would if they did both commit
at the same time so if if this is the

2688
01:03:25,569 --> 01:03:25,579
at the same time so if if this is the
 

2689
01:03:25,579 --> 01:03:31,680
at the same time so if if this is the
scenario what's going to happen and why

2690
01:03:31,680 --> 01:03:31,690

 

2691
01:03:31,690 --> 01:03:34,640

you

2692
01:03:34,640 --> 01:03:34,650

 

2693
01:03:34,650 --> 01:03:37,860

they like to raise their hand and hazard

2694
01:03:37,860 --> 01:03:37,870
they like to raise their hand and hazard
 

2695
01:03:37,870 --> 01:03:48,410
they like to raise their hand and hazard
a guess

2696
01:03:48,410 --> 01:03:48,420

 

2697
01:03:48,420 --> 01:03:50,340

well that's really good field to be

2698
01:03:50,340 --> 01:03:50,350
well that's really good field to be
 

2699
01:03:50,350 --> 01:03:52,470
well that's really good field to be
since that's a one-sided read can't

2700
01:03:52,470 --> 01:03:52,480
since that's a one-sided read can't
 

2701
01:03:52,480 --> 01:03:55,620
since that's a one-sided read can't
possibly fail they're both gonna send in

2702
01:03:55,620 --> 01:03:55,630
possibly fail they're both gonna send in
 

2703
01:03:55,630 --> 01:03:59,910
possibly fail they're both gonna send in
fact identical walk messages to whatever

2704
01:03:59,910 --> 01:03:59,920
fact identical walk messages to whatever
 

2705
01:03:59,920 --> 01:04:04,260
fact identical walk messages to whatever
primary holds object X and I both send

2706
01:04:04,260 --> 01:04:04,270
primary holds object X and I both send
 

2707
01:04:04,270 --> 01:04:06,120
primary holds object X and I both send
the same version number but a version

2708
01:04:06,120 --> 01:04:06,130
the same version number but a version
 

2709
01:04:06,130 --> 01:04:08,610
the same version number but a version
number they read and the same value so

2710
01:04:08,610 --> 01:04:08,620
number they read and the same value so
 

2711
01:04:08,620 --> 01:04:10,850
number they read and the same value so
the primaries gonna see to log meant to

2712
01:04:10,850 --> 01:04:10,860
the primaries gonna see to log meant to
 

2713
01:04:10,860 --> 01:04:14,790
the primaries gonna see to log meant to
log messages in two different incoming

2714
01:04:14,790 --> 01:04:14,800
log messages in two different incoming
 

2715
01:04:14,800 --> 01:04:16,920
log messages in two different incoming
logs assuming these are running on

2716
01:04:16,920 --> 01:04:16,930
logs assuming these are running on
 

2717
01:04:16,930 --> 01:04:23,670
logs assuming these are running on
different clients and exactly what

2718
01:04:23,670 --> 01:04:23,680
different clients and exactly what
 

2719
01:04:23,680 --> 01:04:25,650
different clients and exactly what
happens now is slightly left up to our

2720
01:04:25,650 --> 01:04:25,660
happens now is slightly left up to our
 

2721
01:04:25,660 --> 01:04:28,380
happens now is slightly left up to our
imagination by the paper but I think the

2722
01:04:28,380 --> 01:04:28,390
imagination by the paper but I think the
 

2723
01:04:28,390 --> 01:04:29,910
imagination by the paper but I think the
two incoming log messages could be

2724
01:04:29,910 --> 01:04:29,920
two incoming log messages could be
 

2725
01:04:29,920 --> 01:04:31,950
two incoming log messages could be
processed in parallel on different cores

2726
01:04:31,950 --> 01:04:31,960
processed in parallel on different cores
 

2727
01:04:31,960 --> 01:04:35,400
processed in parallel on different cores
on the primary but the critical

2728
01:04:35,400 --> 01:04:35,410
on the primary but the critical
 

2729
01:04:35,410 --> 01:04:37,620
on the primary but the critical
instruction of the primary is the atomic

2730
01:04:37,620 --> 01:04:37,630
instruction of the primary is the atomic
 

2731
01:04:37,630 --> 01:04:41,540
instruction of the primary is the atomic
test and set or compare and swap exactly

2732
01:04:41,540 --> 01:04:41,550
test and set or compare and swap exactly
 

2733
01:04:41,550 --> 01:04:44,190
test and set or compare and swap exactly
somebody's volunteer the answer that one

2734
01:04:44,190 --> 01:04:44,200
somebody's volunteer the answer that one
 

2735
01:04:44,200 --> 01:04:46,560
somebody's volunteer the answer that one
of them will get to the compare and swap

2736
01:04:46,560 --> 01:04:46,570
of them will get to the compare and swap
 

2737
01:04:46,570 --> 01:04:51,780
of them will get to the compare and swap
instruction first and whichever core I

2738
01:04:51,780 --> 01:04:51,790
instruction first and whichever core I
 

2739
01:04:51,790 --> 01:04:53,790
instruction first and whichever core I
guess the compare and swap instruction

2740
01:04:53,790 --> 01:04:53,800
guess the compare and swap instruction
 

2741
01:04:53,800 --> 01:04:58,460
guess the compare and swap instruction
first it'll set the lock bit on that

2742
01:04:58,460 --> 01:04:58,470
first it'll set the lock bit on that
 

2743
01:04:58,470 --> 01:05:00,630
first it'll set the lock bit on that
objects version and will observe the

2744
01:05:00,630 --> 01:05:00,640
objects version and will observe the
 

2745
01:05:00,640 --> 01:05:03,120
objects version and will observe the
lock a bit wasn't previously set which

2746
01:05:03,120 --> 01:05:03,130
lock a bit wasn't previously set which
 

2747
01:05:03,130 --> 01:05:04,980
lock a bit wasn't previously set which
everyone executes the atomic

2748
01:05:04,980 --> 01:05:04,990
everyone executes the atomic
 

2749
01:05:04,990 --> 01:05:06,870
everyone executes the atomic
compare-and-swap second will observe the

2750
01:05:06,870 --> 01:05:06,880
compare-and-swap second will observe the
 

2751
01:05:06,880 --> 01:05:08,880
compare-and-swap second will observe the
lock that's already set I mean he's the

2752
01:05:08,880 --> 01:05:08,890
lock that's already set I mean he's the
 

2753
01:05:08,890 --> 01:05:11,010
lock that's already set I mean he's the
one of the two will return yes and the

2754
01:05:11,010 --> 01:05:11,020
one of the two will return yes and the
 

2755
01:05:11,020 --> 01:05:13,890
one of the two will return yes and the
other two will fail the lock observe the

2756
01:05:13,890 --> 01:05:13,900
other two will fail the lock observe the
 

2757
01:05:13,900 --> 01:05:17,310
other two will fail the lock observe the
lock is already set immature no and you

2758
01:05:17,310 --> 01:05:17,320
lock is already set immature no and you
 

2759
01:05:17,320 --> 01:05:19,440
lock is already set immature no and you
know it for symmetry I'm just going to

2760
01:05:19,440 --> 01:05:19,450
know it for symmetry I'm just going to
 

2761
01:05:19,450 --> 01:05:24,060
know it for symmetry I'm just going to
imagine that transaction to the primary

2762
01:05:24,060 --> 01:05:24,070
imagine that transaction to the primary
 

2763
01:05:24,070 --> 01:05:25,890
imagine that transaction to the primary
sends back a no so the transaction to

2764
01:05:25,890 --> 01:05:25,900
sends back a no so the transaction to
 

2765
01:05:25,900 --> 01:05:29,510
sends back a no so the transaction to
use client code will abort transaction 1

2766
01:05:29,510 --> 01:05:29,520
use client code will abort transaction 1
 

2767
01:05:29,520 --> 01:05:32,100
use client code will abort transaction 1
I've got the lock got a yes back and it

2768
01:05:32,100 --> 01:05:32,110
I've got the lock got a yes back and it
 

2769
01:05:32,110 --> 01:05:35,190
I've got the lock got a yes back and it
will actually commit when it come

2770
01:05:35,190 --> 01:05:35,200
will actually commit when it come
 

2771
01:05:35,200 --> 01:05:38,099
will actually commit when it come
it's when the primary actually gets the

2772
01:05:38,099 --> 01:05:38,109
it's when the primary actually gets the
 

2773
01:05:38,109 --> 01:05:40,440
it's when the primary actually gets the
commit message it'll install the updated

2774
01:05:40,440 --> 01:05:40,450
commit message it'll install the updated
 

2775
01:05:40,450 --> 01:05:41,099
commit message it'll install the updated
object

2776
01:05:41,099 --> 01:05:41,109
object
 

2777
01:05:41,109 --> 01:05:43,740
object
you know increments to to clear the lock

2778
01:05:43,740 --> 01:05:43,750
you know increments to to clear the lock
 

2779
01:05:43,750 --> 01:05:46,109
you know increments to to clear the lock
bit increment the version and return

2780
01:05:46,109 --> 01:05:46,119
bit increment the version and return
 

2781
01:05:46,119 --> 01:05:51,660
bit increment the version and return
true this is gonna say true because the

2782
01:05:51,660 --> 01:05:51,670
true this is gonna say true because the
 

2783
01:05:51,670 --> 01:05:55,740
true this is gonna say true because the
other primary sent back I know that

2784
01:05:55,740 --> 01:05:55,750
other primary sent back I know that
 

2785
01:05:55,750 --> 01:05:57,480
other primary sent back I know that
means that TX commits gonna return false

2786
01:05:57,480 --> 01:05:57,490
means that TX commits gonna return false
 

2787
01:05:57,490 --> 01:06:00,750
means that TX commits gonna return false
here and the final value would be x

2788
01:06:00,750 --> 01:06:00,760
here and the final value would be x
 

2789
01:06:00,760 --> 01:06:03,270
here and the final value would be x
equals one that was one of our allowed

2790
01:06:03,270 --> 01:06:03,280
equals one that was one of our allowed
 

2791
01:06:03,280 --> 01:06:06,390
equals one that was one of our allowed
outcomes but of course it's not the only

2792
01:06:06,390 --> 01:06:06,400
outcomes but of course it's not the only
 

2793
01:06:06,400 --> 01:06:12,060
outcomes but of course it's not the only
in are leaving any questions about how

2794
01:06:12,060 --> 01:06:12,070
in are leaving any questions about how
 

2795
01:06:12,070 --> 01:06:16,050
in are leaving any questions about how
this played out or wide executed the way

2796
01:06:16,050 --> 01:06:16,060
this played out or wide executed the way
 

2797
01:06:16,060 --> 01:06:19,880
this played out or wide executed the way
it did

2798
01:06:19,880 --> 01:06:19,890

 

2799
01:06:19,890 --> 01:06:21,750

okay so there's other possible

2800
01:06:21,750 --> 01:06:21,760
okay so there's other possible
 

2801
01:06:21,760 --> 01:06:25,920
okay so there's other possible
interleavings so how about how about

2802
01:06:25,920 --> 01:06:25,930
interleavings so how about how about
 

2803
01:06:25,930 --> 01:06:30,870
interleavings so how about how about
this one let's imagine that transaction

2804
01:06:30,870 --> 01:06:30,880
this one let's imagine that transaction
 

2805
01:06:30,880 --> 01:06:33,770
this one let's imagine that transaction
2 does the beat first

2806
01:06:33,770 --> 01:06:33,780
2 does the beat first
 

2807
01:06:33,780 --> 01:06:37,620
2 does the beat first
she doesn't really matter what the reads

2808
01:06:37,620 --> 01:06:37,630
she doesn't really matter what the reads
 

2809
01:06:37,630 --> 01:06:39,420
she doesn't really matter what the reads
are concurrent or not then transaction

2810
01:06:39,420 --> 01:06:39,430
are concurrent or not then transaction
 

2811
01:06:39,430 --> 01:06:41,070
are concurrent or not then transaction
one doesn't read and then transaction

2812
01:06:41,070 --> 01:06:41,080
one doesn't read and then transaction
 

2813
01:06:41,080 --> 01:06:43,080
one doesn't read and then transaction
went a little bit faster and it gets its

2814
01:06:43,080 --> 01:06:43,090
went a little bit faster and it gets its
 

2815
01:06:43,090 --> 01:06:47,340
went a little bit faster and it gets its
lock message in and a reply and gets a

2816
01:06:47,340 --> 01:06:47,350
lock message in and a reply and gets a
 

2817
01:06:47,350 --> 01:06:50,600
lock message in and a reply and gets a
commit back and then afterwards

2818
01:06:50,600 --> 01:06:50,610
commit back and then afterwards
 

2819
01:06:50,610 --> 01:06:55,550
commit back and then afterwards
transaction two gets going again and

2820
01:06:55,550 --> 01:06:55,560
transaction two gets going again and
 

2821
01:06:55,560 --> 01:06:58,050
transaction two gets going again and
sends a lock message in if it could

2822
01:06:58,050 --> 01:06:58,060
sends a lock message in if it could
 

2823
01:06:58,060 --> 01:07:16,680
sends a lock message in if it could
commit so what happens this time

2824
01:07:16,680 --> 01:07:16,690

 

2825
01:07:16,690 --> 01:07:20,890

well is this law commissioner is gonna

2826
01:07:20,890 --> 01:07:20,900
well is this law commissioner is gonna
 

2827
01:07:20,900 --> 01:07:22,660
well is this law commissioner is gonna
be succeed because there's no reason to

2828
01:07:22,660 --> 01:07:22,670
be succeed because there's no reason to
 

2829
01:07:22,670 --> 01:07:24,520
be succeed because there's no reason to
believe there's a lock bit is set

2830
01:07:24,520 --> 01:07:24,530
believe there's a lock bit is set
 

2831
01:07:24,530 --> 01:07:26,770
believe there's a lock bit is set
because the second lock message hasn't

2832
01:07:26,770 --> 01:07:26,780
because the second lock message hasn't
 

2833
01:07:26,780 --> 01:07:28,960
because the second lock message hasn't
even been sent message we'll set the

2834
01:07:28,960 --> 01:07:28,970
even been sent message we'll set the
 

2835
01:07:28,970 --> 01:07:31,150
even been sent message we'll set the
lock the commit message this commit

2836
01:07:31,150 --> 01:07:31,160
lock the commit message this commit
 

2837
01:07:31,160 --> 01:07:32,349
lock the commit message this commit
primary message should actually clear

2838
01:07:32,349 --> 01:07:32,359
primary message should actually clear
 

2839
01:07:32,359 --> 01:07:35,620
primary message should actually clear
the lock a bit so the lock bit will be

2840
01:07:35,620 --> 01:07:35,630
the lock a bit so the lock bit will be
 

2841
01:07:35,630 --> 01:07:39,910
the lock a bit so the lock bit will be
clear by the time t2 census inserts its

2842
01:07:39,910 --> 01:07:39,920
clear by the time t2 census inserts its
 

2843
01:07:39,920 --> 01:07:49,599
clear by the time t2 census inserts its
lock entry in primaries log so this the

2844
01:07:49,599 --> 01:07:49,609
lock entry in primaries log so this the
 

2845
01:07:49,609 --> 01:07:51,370
lock entry in primaries log so this the
primary won't see the lock a bit set at

2846
01:07:51,370 --> 01:07:51,380
primary won't see the lock a bit set at
 

2847
01:07:51,380 --> 01:07:54,010
primary won't see the lock a bit set at
this point yeah so somebody's

2848
01:07:54,010 --> 01:07:54,020
this point yeah so somebody's
 

2849
01:07:54,020 --> 01:07:57,819
this point yeah so somebody's
volunteered that what this primary will

2850
01:07:57,819 --> 01:07:57,829
volunteered that what this primary will
 

2851
01:07:57,829 --> 01:08:00,130
volunteered that what this primary will
see is that the version number so the

2852
01:08:00,130 --> 01:08:00,140
see is that the version number so the
 

2853
01:08:00,140 --> 01:08:01,930
see is that the version number so the
the lock message contains the version

2854
01:08:01,930 --> 01:08:01,940
the lock message contains the version
 

2855
01:08:01,940 --> 01:08:03,370
the lock message contains the version
number the transaction to originally

2856
01:08:03,370 --> 01:08:03,380
number the transaction to originally
 

2857
01:08:03,380 --> 01:08:05,950
number the transaction to originally
read and so the primary is gonna see

2858
01:08:05,950 --> 01:08:05,960
read and so the primary is gonna see
 

2859
01:08:05,960 --> 01:08:08,650
read and so the primary is gonna see
wait a minute this since commit primary

2860
01:08:08,650 --> 01:08:08,660
wait a minute this since commit primary
 

2861
01:08:08,660 --> 01:08:11,069
wait a minute this since commit primary
increments of version number the the

2862
01:08:11,069 --> 01:08:11,079
increments of version number the the
 

2863
01:08:11,079 --> 01:08:12,970
increments of version number the the
primary is gonna see that the version

2864
01:08:12,970 --> 01:08:12,980
primary is gonna see that the version
 

2865
01:08:12,980 --> 01:08:14,290
primary is gonna see that the version
number is wrong there's numbers now

2866
01:08:14,290 --> 01:08:14,300
number is wrong there's numbers now
 

2867
01:08:14,300 --> 01:08:16,090
number is wrong there's numbers now
higher on the real object and so it's

2868
01:08:16,090 --> 01:08:16,100
higher on the real object and so it's
 

2869
01:08:16,100 --> 01:08:20,140
higher on the real object and so it's
actually gonna send back a a no response

2870
01:08:20,140 --> 01:08:20,150
actually gonna send back a a no response
 

2871
01:08:20,150 --> 01:08:24,340
actually gonna send back a a no response
to the coordinator and the coordinator

2872
01:08:24,340 --> 01:08:24,350
to the coordinator and the coordinator
 

2873
01:08:24,350 --> 01:08:26,590
to the coordinator and the coordinator
is gonna abort this transaction and

2874
01:08:26,590 --> 01:08:26,600
is gonna abort this transaction and
 

2875
01:08:26,600 --> 01:08:29,410
is gonna abort this transaction and
again we're gonna get x equals 1 one of

2876
01:08:29,410 --> 01:08:29,420
again we're gonna get x equals 1 one of
 

2877
01:08:29,420 --> 01:08:31,030
again we're gonna get x equals 1 one of
the transactions return true the other

2878
01:08:31,030 --> 01:08:31,040
the transactions return true the other
 

2879
01:08:31,040 --> 01:08:35,979
the transactions return true the other
returned false which is the same final

2880
01:08:35,979 --> 01:08:35,989
returned false which is the same final
 

2881
01:08:35,989 --> 01:08:40,269
returned false which is the same final
outcome as before and it is allowed any

2882
01:08:40,269 --> 01:08:40,279
outcome as before and it is allowed any
 

2883
01:08:40,279 --> 01:08:44,249
outcome as before and it is allowed any
questions about how this played out a

2884
01:08:44,249 --> 01:08:44,259
questions about how this played out a
 

2885
01:08:44,259 --> 01:08:47,289
questions about how this played out a
slightly different scenario would be as

2886
01:08:47,289 --> 01:08:47,299
slightly different scenario would be as
 

2887
01:08:47,299 --> 01:08:51,370
slightly different scenario would be as
if and actually okay the slightly

2888
01:08:51,370 --> 01:08:51,380
if and actually okay the slightly
 

2889
01:08:51,380 --> 01:08:52,599
if and actually okay the slightly
different scenario I was gonna think of

2890
01:08:52,599 --> 01:08:52,609
different scenario I was gonna think of
 

2891
01:08:52,609 --> 01:08:54,870
different scenario I was gonna think of
think of was one in which the commit

2892
01:08:54,870 --> 01:08:54,880
think of was one in which the commit
 

2893
01:08:54,880 --> 01:08:57,760
think of was one in which the commit
message was stole it happened after this

2894
01:08:57,760 --> 01:08:57,770
message was stole it happened after this
 

2895
01:08:57,770 --> 01:08:59,860
message was stole it happened after this
lock this is essentially the same as the

2896
01:08:59,860 --> 01:08:59,870
lock this is essentially the same as the
 

2897
01:08:59,870 --> 01:09:04,300
lock this is essentially the same as the
first scenario in which this transaction

2898
01:09:04,300 --> 01:09:04,310
first scenario in which this transaction
 

2899
01:09:04,310 --> 01:09:05,740
first scenario in which this transaction
got the lock set in this transaction

2900
01:09:05,740 --> 01:09:05,750
got the lock set in this transaction
 

2901
01:09:05,750 --> 01:09:10,650
got the lock set in this transaction
observed lock okay

2902
01:09:10,650 --> 01:09:10,660
observed lock okay
 

2903
01:09:10,660 --> 01:09:18,479
observed lock okay
everyone one last scenario let's suppose

2904
01:09:18,479 --> 01:09:18,489
everyone one last scenario let's suppose
 

2905
01:09:18,489 --> 01:09:32,170
everyone one last scenario let's suppose
we see this

2906
01:09:32,170 --> 01:09:32,180

 

2907
01:09:32,180 --> 01:09:34,040

what's going to happen this time

2908
01:09:34,040 --> 01:09:34,050
what's going to happen this time
 

2909
01:09:34,050 --> 01:09:47,680
what's going to happen this time
[Music]

2910
01:09:47,680 --> 01:09:47,690

 

2911
01:09:47,690 --> 01:09:51,860

yeah somebody has a right answer at the

2912
01:09:51,860 --> 01:09:51,870
yeah somebody has a right answer at the
 

2913
01:09:51,870 --> 01:09:53,300
yeah somebody has a right answer at the
of course the first transaction will go

2914
01:09:53,300 --> 01:09:53,310
of course the first transaction will go
 

2915
01:09:53,310 --> 01:09:54,800
of course the first transaction will go
through because there's no contention in

2916
01:09:54,800 --> 01:09:54,810
through because there's no contention in
 

2917
01:09:54,810 --> 01:09:56,330
through because there's no contention in
the first transaction the second

2918
01:09:56,330 --> 01:09:56,340
the first transaction the second
 

2919
01:09:56,340 --> 01:09:58,520
the first transaction the second
transaction when it goes to read X will

2920
01:09:58,520 --> 01:09:58,530
transaction when it goes to read X will
 

2921
01:09:58,530 --> 01:10:02,090
transaction when it goes to read X will
actually see the new version number as

2922
01:10:02,090 --> 01:10:02,100
actually see the new version number as
 

2923
01:10:02,100 --> 01:10:04,820
actually see the new version number as
incremented by the commit primary

2924
01:10:04,820 --> 01:10:04,830
incremented by the commit primary
 

2925
01:10:04,830 --> 01:10:07,700
incremented by the commit primary
processing on the primary so it'll see

2926
01:10:07,700 --> 01:10:07,710
processing on the primary so it'll see
 

2927
01:10:07,710 --> 01:10:09,740
processing on the primary so it'll see
the new version number the lock that

2928
01:10:09,740 --> 01:10:09,750
the new version number the lock that
 

2929
01:10:09,750 --> 01:10:11,750
the new version number the lock that
won't be set and so then when it goes to

2930
01:10:11,750 --> 01:10:11,760
won't be set and so then when it goes to
 

2931
01:10:11,760 --> 01:10:16,540
won't be set and so then when it goes to
send its lock log entry to the primary

2932
01:10:16,540 --> 01:10:16,550
send its lock log entry to the primary
 

2933
01:10:16,550 --> 01:10:19,130
send its lock log entry to the primary
lock lock that locked processing code in

2934
01:10:19,130 --> 01:10:19,140
lock lock that locked processing code in
 

2935
01:10:19,140 --> 01:10:21,380
lock lock that locked processing code in
the primary Co the locks not set and the

2936
01:10:21,380 --> 01:10:21,390
the primary Co the locks not set and the
 

2937
01:10:21,390 --> 01:10:23,330
the primary Co the locks not set and the
version is the same hasn't this is the

2938
01:10:23,330 --> 01:10:23,340
version is the same hasn't this is the
 

2939
01:10:23,340 --> 01:10:24,800
version is the same hasn't this is the
latest version and it all I want to

2940
01:10:24,800 --> 01:10:24,810
latest version and it all I want to
 

2941
01:10:24,810 --> 01:10:26,450
latest version and it all I want to
commit and so for this the outcome we're

2942
01:10:26,450 --> 01:10:26,460
commit and so for this the outcome we're
 

2943
01:10:26,460 --> 01:10:29,960
commit and so for this the outcome we're
gonna see is x equals 2 because this

2944
01:10:29,960 --> 01:10:29,970
gonna see is x equals 2 because this
 

2945
01:10:29,970 --> 01:10:31,280
gonna see is x equals 2 because this
read not only read the new version um

2946
01:10:31,280 --> 01:10:31,290
read not only read the new version um
 

2947
01:10:31,290 --> 01:10:32,570
read not only read the new version um
but actually read the new value which

2948
01:10:32,570 --> 01:10:32,580
but actually read the new value which
 

2949
01:10:32,580 --> 01:10:40,480
but actually read the new value which
was one so this is incorrect here and

2950
01:10:40,480 --> 01:10:40,490
was one so this is incorrect here and
 

2951
01:10:40,490 --> 01:10:47,360
was one so this is incorrect here and
both calls to TX commit will be true yes

2952
01:10:47,360 --> 01:10:47,370
both calls to TX commit will be true yes
 

2953
01:10:47,370 --> 01:10:51,070
both calls to TX commit will be true yes
that's right succeed it with x equals 2

2954
01:10:51,070 --> 01:10:51,080
that's right succeed it with x equals 2
 

2955
01:10:51,080 --> 01:10:53,420
that's right succeed it with x equals 2
all right so you know this happened to

2956
01:10:53,420 --> 01:10:53,430
all right so you know this happened to
 

2957
01:10:53,430 --> 01:10:56,960
all right so you know this happened to
work out in these cases the intuition

2958
01:10:56,960 --> 01:10:56,970
work out in these cases the intuition
 

2959
01:10:56,970 --> 01:10:59,720
work out in these cases the intuition
behind why optimistic concurrency

2960
01:10:59,720 --> 01:10:59,730
behind why optimistic concurrency
 

2961
01:10:59,730 --> 01:11:03,170
behind why optimistic concurrency
control provides serializability why it

2962
01:11:03,170 --> 01:11:03,180
control provides serializability why it
 

2963
01:11:03,180 --> 01:11:06,830
control provides serializability why it
why it basically checks that the

2964
01:11:06,830 --> 01:11:06,840
why it basically checks that the
 

2965
01:11:06,840 --> 01:11:09,800
why it basically checks that the
execution that did happen is the same as

2966
01:11:09,800 --> 01:11:09,810
execution that did happen is the same as
 

2967
01:11:09,810 --> 01:11:13,820
execution that did happen is the same as
a one at a time execution essentially

2968
01:11:13,820 --> 01:11:13,830
a one at a time execution essentially
 

2969
01:11:13,830 --> 01:11:15,680
a one at a time execution essentially
the intuition is that if there was no

2970
01:11:15,680 --> 01:11:15,690
the intuition is that if there was no
 

2971
01:11:15,690 --> 01:11:17,870
the intuition is that if there was no
conflicting transaction then the version

2972
01:11:17,870 --> 01:11:17,880
conflicting transaction then the version
 

2973
01:11:17,880 --> 01:11:19,100
conflicting transaction then the version
numbers and the lock bits won't have

2974
01:11:19,100 --> 01:11:19,110
numbers and the lock bits won't have
 

2975
01:11:19,110 --> 01:11:20,600
numbers and the lock bits won't have
changed if nobody else is messing with

2976
01:11:20,600 --> 01:11:20,610
changed if nobody else is messing with
 

2977
01:11:20,610 --> 01:11:23,750
changed if nobody else is messing with
these objects you know I'll see the same

2978
01:11:23,750 --> 01:11:23,760
these objects you know I'll see the same
 

2979
01:11:23,760 --> 01:11:25,010
these objects you know I'll see the same
version numbers at the end of the

2980
01:11:25,010 --> 01:11:25,020
version numbers at the end of the
 

2981
01:11:25,020 --> 01:11:27,680
version numbers at the end of the
transaction as we did when we first read

2982
01:11:27,680 --> 01:11:27,690
transaction as we did when we first read
 

2983
01:11:27,690 --> 01:11:30,410
transaction as we did when we first read
the object whereas if there is a

2984
01:11:30,410 --> 01:11:30,420
the object whereas if there is a
 

2985
01:11:30,420 --> 01:11:32,180
the object whereas if there is a
conflicting transaction between when we

2986
01:11:32,180 --> 01:11:32,190
conflicting transaction between when we
 

2987
01:11:32,190 --> 01:11:33,740
conflicting transaction between when we
read the object and when we try to

2988
01:11:33,740 --> 01:11:33,750
read the object and when we try to
 

2989
01:11:33,750 --> 01:11:37,770
read the object and when we try to
commit a change and that conflicting

2990
01:11:37,770 --> 01:11:37,780
commit a change and that conflicting
 

2991
01:11:37,780 --> 01:11:42,060
commit a change and that conflicting
modified something then if it actually

2992
01:11:42,060 --> 01:11:42,070
modified something then if it actually
 

2993
01:11:42,070 --> 01:11:43,800
modified something then if it actually
started to commit we will see a new

2994
01:11:43,800 --> 01:11:43,810
started to commit we will see a new
 

2995
01:11:43,810 --> 01:11:47,310
started to commit we will see a new
version number or a lock a bit set so

2996
01:11:47,310 --> 01:11:47,320
version number or a lock a bit set so
 

2997
01:11:47,320 --> 01:11:48,840
version number or a lock a bit set so
the comparison of the version numbers

2998
01:11:48,840 --> 01:11:48,850
the comparison of the version numbers
 

2999
01:11:48,850 --> 01:11:49,860
the comparison of the version numbers
and lock bits between when you first

3000
01:11:49,860 --> 01:11:49,870
and lock bits between when you first
 

3001
01:11:49,870 --> 01:11:51,180
and lock bits between when you first
read the object and when you finally

3002
01:11:51,180 --> 01:11:51,190
read the object and when you finally
 

3003
01:11:51,190 --> 01:11:53,820
read the object and when you finally
commit it kind of tells you whether some

3004
01:11:53,820 --> 01:11:53,830
commit it kind of tells you whether some
 

3005
01:11:53,830 --> 01:11:56,360
commit it kind of tells you whether some
other commits to the objects snuck in

3006
01:11:56,360 --> 01:11:56,370
other commits to the objects snuck in
 

3007
01:11:56,370 --> 01:12:02,490
other commits to the objects snuck in
while you were using them all right and

3008
01:12:02,490 --> 01:12:02,500
while you were using them all right and
 

3009
01:12:02,500 --> 01:12:03,930
while you were using them all right and
you know the cool thing to remember here

3010
01:12:03,930 --> 01:12:03,940
you know the cool thing to remember here
 

3011
01:12:03,940 --> 01:12:08,390
you know the cool thing to remember here
is that this allowed us to do the reads

3012
01:12:08,390 --> 01:12:08,400
is that this allowed us to do the reads
 

3013
01:12:08,400 --> 01:12:11,130
is that this allowed us to do the reads
the use of this optimistic schema which

3014
01:12:11,130 --> 01:12:11,140
the use of this optimistic schema which
 

3015
01:12:11,140 --> 01:12:13,290
the use of this optimistic schema which
we don't actually check the locks only

3016
01:12:13,290 --> 01:12:13,300
we don't actually check the locks only
 

3017
01:12:13,300 --> 01:12:15,300
we don't actually check the locks only
when we first use the data allowed us to

3018
01:12:15,300 --> 01:12:15,310
when we first use the data allowed us to
 

3019
01:12:15,310 --> 01:12:17,280
when we first use the data allowed us to
use this extremely fast one sided

3020
01:12:17,280 --> 01:12:17,290
use this extremely fast one sided
 

3021
01:12:17,290 --> 01:12:20,460
use this extremely fast one sided
already ma reads to read the data and

3022
01:12:20,460 --> 01:12:20,470
already ma reads to read the data and
 

3023
01:12:20,470 --> 01:12:24,780
already ma reads to read the data and
get high performance ok so the way I've

3024
01:12:24,780 --> 01:12:24,790
get high performance ok so the way I've
 

3025
01:12:24,790 --> 01:12:28,200
get high performance ok so the way I've
explained it so far without validate and

3026
01:12:28,200 --> 01:12:28,210
explained it so far without validate and
 

3027
01:12:28,210 --> 01:12:29,970
explained it so far without validate and
without commit back up is the way the

3028
01:12:29,970 --> 01:12:29,980
without commit back up is the way the
 

3029
01:12:29,980 --> 01:12:34,590
without commit back up is the way the
system works but as I see validate is

3030
01:12:34,590 --> 01:12:34,600
system works but as I see validate is
 

3031
01:12:34,600 --> 01:12:38,250
system works but as I see validate is
sort of an optimization for just reading

3032
01:12:38,250 --> 01:12:38,260
sort of an optimization for just reading
 

3033
01:12:38,260 --> 01:12:41,550
sort of an optimization for just reading
an object but not writing it and commit

3034
01:12:41,550 --> 01:12:41,560
an object but not writing it and commit
 

3035
01:12:41,560 --> 01:12:43,740
an object but not writing it and commit
back up as part of the scheme for fault

3036
01:12:43,740 --> 01:12:43,750
back up as part of the scheme for fault
 

3037
01:12:43,750 --> 01:12:46,170
back up as part of the scheme for fault
tolerance I think I'm gonna a few

3038
01:12:46,170 --> 01:12:46,180
tolerance I think I'm gonna a few
 

3039
01:12:46,180 --> 01:12:47,220
tolerance I think I'm gonna a few
minutes we have left I want to talk

3040
01:12:47,220 --> 01:12:47,230
minutes we have left I want to talk
 

3041
01:12:47,230 --> 01:12:52,890
minutes we have left I want to talk
about validate so the validate stage is

3042
01:12:52,890 --> 01:12:52,900
about validate so the validate stage is
 

3043
01:12:52,900 --> 01:12:56,190
about validate so the validate stage is
it's an optimization for to treat

3044
01:12:56,190 --> 01:12:56,200
it's an optimization for to treat
 

3045
01:12:56,200 --> 01:12:57,600
it's an optimization for to treat
objects that we're only read by the

3046
01:12:57,600 --> 01:12:57,610
objects that we're only read by the
 

3047
01:12:57,610 --> 01:12:59,520
objects that we're only read by the
transaction and I'm not written and it's

3048
01:12:59,520 --> 01:12:59,530
transaction and I'm not written and it's
 

3049
01:12:59,530 --> 01:13:00,870
transaction and I'm not written and it's
going to be particularly interesting if

3050
01:13:00,870 --> 01:13:00,880
going to be particularly interesting if
 

3051
01:13:00,880 --> 01:13:03,030
going to be particularly interesting if
it's a straight read-only transaction

3052
01:13:03,030 --> 01:13:03,040
it's a straight read-only transaction
 

3053
01:13:03,040 --> 01:13:05,910
it's a straight read-only transaction
that modified nothing and you know the

3054
01:13:05,910 --> 01:13:05,920
that modified nothing and you know the
 

3055
01:13:05,920 --> 01:13:08,730
that modified nothing and you know the
optimization is that it's going to be

3056
01:13:08,730 --> 01:13:08,740
optimization is that it's going to be
 

3057
01:13:08,740 --> 01:13:11,280
optimization is that it's going to be
that the transaction coordinator can

3058
01:13:11,280 --> 01:13:11,290
that the transaction coordinator can
 

3059
01:13:11,290 --> 01:13:12,990
that the transaction coordinator can
execute the validate with a one-sided

3060
01:13:12,990 --> 01:13:13,000
execute the validate with a one-sided
 

3061
01:13:13,000 --> 01:13:15,450
execute the validate with a one-sided
read that's extremely fast rather than

3062
01:13:15,450 --> 01:13:15,460
read that's extremely fast rather than
 

3063
01:13:15,460 --> 01:13:17,370
read that's extremely fast rather than
having to put something on a log and

3064
01:13:17,370 --> 01:13:17,380
having to put something on a log and
 

3065
01:13:17,380 --> 01:13:20,130
having to put something on a log and
wait for the primary to see our log

3066
01:13:20,130 --> 01:13:20,140
wait for the primary to see our log
 

3067
01:13:20,140 --> 01:13:22,850
wait for the primary to see our log
entry and think about it so this

3068
01:13:22,850 --> 01:13:22,860
entry and think about it so this
 

3069
01:13:22,860 --> 01:13:24,690
entry and think about it so this
validates one-sided B is going to be

3070
01:13:24,690 --> 01:13:24,700
validates one-sided B is going to be
 

3071
01:13:24,700 --> 01:13:26,730
validates one-sided B is going to be
much much faster it's gonna essentially

3072
01:13:26,730 --> 01:13:26,740
much much faster it's gonna essentially
 

3073
01:13:26,740 --> 01:13:28,980
much much faster it's gonna essentially
replace lock for objects that would only

3074
01:13:28,980 --> 01:13:28,990
replace lock for objects that would only
 

3075
01:13:28,990 --> 01:13:35,200
replace lock for objects that would only
read it's gonna be much faster

3076
01:13:35,200 --> 01:13:35,210

 

3077
01:13:35,210 --> 01:13:36,820

basically what's going on here is that

3078
01:13:36,820 --> 01:13:36,830
basically what's going on here is that
 

3079
01:13:36,830 --> 01:13:41,890
basically what's going on here is that
the what what the validate does is the

3080
01:13:41,890 --> 01:13:41,900
the what what the validate does is the
 

3081
01:13:41,900 --> 01:13:44,860
the what what the validate does is the
transaction coordinator refetch is the

3082
01:13:44,860 --> 01:13:44,870
transaction coordinator refetch is the
 

3083
01:13:44,870 --> 01:13:46,600
transaction coordinator refetch is the
object header so you know it would have

3084
01:13:46,600 --> 01:13:46,610
object header so you know it would have
 

3085
01:13:46,610 --> 01:13:49,030
object header so you know it would have
read an object say this object in the

3086
01:13:49,030 --> 01:13:49,040
read an object say this object in the
 

3087
01:13:49,040 --> 01:13:51,370
read an object say this object in the
execute phase when it's committing it

3088
01:13:51,370 --> 01:13:51,380
execute phase when it's committing it
 

3089
01:13:51,380 --> 01:13:54,130
execute phase when it's committing it
instead of sending a lock message it be

3090
01:13:54,130 --> 01:13:54,140
instead of sending a lock message it be
 

3091
01:13:54,140 --> 01:13:56,890
instead of sending a lock message it be
fetches the object hit header and checks

3092
01:13:56,890 --> 01:13:56,900
fetches the object hit header and checks
 

3093
01:13:56,900 --> 01:13:59,650
fetches the object hit header and checks
whether the version number now is the

3094
01:13:59,650 --> 01:13:59,660
whether the version number now is the
 

3095
01:13:59,660 --> 01:14:01,930
whether the version number now is the
same as the version number when it first

3096
01:14:01,930 --> 01:14:01,940
same as the version number when it first
 

3097
01:14:01,940 --> 01:14:03,850
same as the version number when it first
read the object and it also checks if

3098
01:14:03,850 --> 01:14:03,860
read the object and it also checks if
 

3099
01:14:03,860 --> 01:14:10,060
read the object and it also checks if
the lock of it is clear so so that's how

3100
01:14:10,060 --> 01:14:10,070
the lock of it is clear so so that's how
 

3101
01:14:10,070 --> 01:14:10,660
the lock of it is clear so so that's how
it works

3102
01:14:10,660 --> 01:14:10,670
it works
 

3103
01:14:10,670 --> 01:14:12,100
it works
so instead of setting a lock message

3104
01:14:12,100 --> 01:14:12,110
so instead of setting a lock message
 

3105
01:14:12,110 --> 01:14:13,630
so instead of setting a lock message
send this validate message should be

3106
01:14:13,630 --> 01:14:13,640
send this validate message should be
 

3107
01:14:13,640 --> 01:14:17,980
send this validate message should be
much faster for a read-only operation so

3108
01:14:17,980 --> 01:14:17,990
much faster for a read-only operation so
 

3109
01:14:17,990 --> 01:14:21,300
much faster for a read-only operation so
let me put up another transaction

3110
01:14:21,300 --> 01:14:21,310
let me put up another transaction
 

3111
01:14:21,310 --> 01:14:23,650
let me put up another transaction
example and run through it how it works

3112
01:14:23,650 --> 01:14:23,660
example and run through it how it works
 

3113
01:14:23,660 --> 01:14:26,470
example and run through it how it works
let's suppose x and y are initially 0 we

3114
01:14:26,470 --> 01:14:26,480
let's suppose x and y are initially 0 we
 

3115
01:14:26,480 --> 01:14:32,620
let's suppose x and y are initially 0 we
have two transactions t1 if X is equal

3116
01:14:32,620 --> 01:14:32,630
have two transactions t1 if X is equal
 

3117
01:14:32,630 --> 01:14:40,050
have two transactions t1 if X is equal
to zero set y equal one and T two says

3118
01:14:40,050 --> 01:14:40,060
to zero set y equal one and T two says
 

3119
01:14:40,060 --> 01:14:44,660
to zero set y equal one and T two says
if Y is zero

3120
01:14:44,660 --> 01:14:44,670

 

3121
01:14:44,670 --> 01:14:47,669

said x equals one but this is a

3122
01:14:47,669 --> 01:14:47,679
said x equals one but this is a
 

3123
01:14:47,679 --> 01:14:51,569
said x equals one but this is a
absolutely classic test for strong

3124
01:14:51,569 --> 01:14:51,579
absolutely classic test for strong
 

3125
01:14:51,579 --> 01:14:56,790
absolutely classic test for strong
consistency if the execution is

3126
01:14:56,790 --> 01:14:56,800
consistency if the execution is
 

3127
01:14:56,800 --> 01:15:00,810
consistency if the execution is
serializable it's going to be either t1

3128
01:15:00,810 --> 01:15:00,820
serializable it's going to be either t1
 

3129
01:15:00,820 --> 01:15:05,129
serializable it's going to be either t1
then t2 or t2 and t1 it's got to get to

3130
01:15:05,129 --> 01:15:05,139
then t2 or t2 and t1 it's got to get to
 

3131
01:15:05,139 --> 01:15:07,020
then t2 or t2 and t1 it's got to get to
see any you know corrected

3132
01:15:07,020 --> 01:15:07,030
see any you know corrected
 

3133
01:15:07,030 --> 01:15:08,700
see any you know corrected
implementation has to get the same

3134
01:15:08,700 --> 01:15:08,710
implementation has to get the same
 

3135
01:15:08,710 --> 01:15:10,890
implementation has to get the same
results it's running them one at a time

3136
01:15:10,890 --> 01:15:10,900
results it's running them one at a time
 

3137
01:15:10,900 --> 01:15:13,709
results it's running them one at a time
if you run T 1 and then t2 you're gonna

3138
01:15:13,709 --> 01:15:13,719
if you run T 1 and then t2 you're gonna
 

3139
01:15:13,719 --> 01:15:18,899
if you run T 1 and then t2 you're gonna
get y equals 1 and x equals 0 because

3140
01:15:18,899 --> 01:15:18,909
get y equals 1 and x equals 0 because
 

3141
01:15:18,909 --> 01:15:21,270
get y equals 1 and x equals 0 because
the second if statement Y is already 1

3142
01:15:21,270 --> 01:15:21,280
the second if statement Y is already 1
 

3143
01:15:21,280 --> 01:15:22,319
the second if statement Y is already 1
the second if statement won't do

3144
01:15:22,319 --> 01:15:22,329
the second if statement won't do
 

3145
01:15:22,329 --> 01:15:26,459
the second if statement won't do
anything and symmetrically this will

3146
01:15:26,459 --> 01:15:26,469
anything and symmetrically this will
 

3147
01:15:26,469 --> 01:15:31,040
anything and symmetrically this will
give you x equals 1 and y equals 0 and

3148
01:15:31,040 --> 01:15:31,050
give you x equals 1 and y equals 0 and
 

3149
01:15:31,050 --> 01:15:33,509
give you x equals 1 and y equals 0 and
it turns out that if you if they both

3150
01:15:33,509 --> 01:15:33,519
it turns out that if you if they both
 

3151
01:15:33,519 --> 01:15:36,479
it turns out that if you if they both
abort you can get x equals 0 y equals 0

3152
01:15:36,479 --> 01:15:36,489
abort you can get x equals 0 y equals 0
 

3153
01:15:36,489 --> 01:15:38,399
abort you can get x equals 0 y equals 0
but what you are absolutely not allowed

3154
01:15:38,399 --> 01:15:38,409
but what you are absolutely not allowed
 

3155
01:15:38,409 --> 01:15:45,000
but what you are absolutely not allowed
to get is x equals 1 y equals 1 that's

3156
01:15:45,000 --> 01:15:45,010
to get is x equals 1 y equals 1 that's
 

3157
01:15:45,010 --> 01:15:48,259
to get is x equals 1 y equals 1 that's
not allowed

3158
01:15:48,259 --> 01:15:48,269

 

3159
01:15:48,269 --> 01:15:53,910

ok so we're looking for how I'm going to

3160
01:15:53,910 --> 01:15:53,920
ok so we're looking for how I'm going to
 

3161
01:15:53,920 --> 01:15:56,399
ok so we're looking for how I'm going to
use this as a test see what happens with

3162
01:15:56,399 --> 01:15:56,409
use this as a test see what happens with
 

3163
01:15:56,409 --> 01:15:58,609
use this as a test see what happens with
validate and again we're gonna suppose

3164
01:15:58,609 --> 01:15:58,619
validate and again we're gonna suppose
 

3165
01:15:58,619 --> 01:16:04,979
validate and again we're gonna suppose
these two transactions execute most so

3166
01:16:04,979 --> 01:16:04,989
these two transactions execute most so
 

3167
01:16:04,989 --> 01:16:06,899
these two transactions execute most so
obvious cases they execute it absolutely

3168
01:16:06,899 --> 01:16:06,909
obvious cases they execute it absolutely
 

3169
01:16:06,909 --> 01:16:11,520
obvious cases they execute it absolutely
at the same time and it eat that's the

3170
01:16:11,520 --> 01:16:11,530
at the same time and it eat that's the
 

3171
01:16:11,530 --> 01:16:17,250
at the same time and it eat that's the
that's the hardest case okay so as we

3172
01:16:17,250 --> 01:16:17,260
that's the hardest case okay so as we
 

3173
01:16:17,260 --> 01:16:27,709
that's the hardest case okay so as we
have read of X meet Y

3174
01:16:27,709 --> 01:16:27,719

 

3175
01:16:27,719 --> 01:16:29,240

why because we wrote it and lock why

3176
01:16:29,240 --> 01:16:29,250
why because we wrote it and lock why
 

3177
01:16:29,250 --> 01:16:35,240
why because we wrote it and lock why
here I sort of lock X here but since now

3178
01:16:35,240 --> 01:16:35,250
here I sort of lock X here but since now
 

3179
01:16:35,250 --> 01:16:37,430
here I sort of lock X here but since now
we're using this read-only a validation

3180
01:16:37,430 --> 01:16:37,440
we're using this read-only a validation
 

3181
01:16:37,440 --> 01:16:38,990
we're using this read-only a validation
optimization that means this one has to

3182
01:16:38,990 --> 01:16:39,000
optimization that means this one has to
 

3183
01:16:39,000 --> 01:16:41,570
optimization that means this one has to
validate why this one has to validate X

3184
01:16:41,570 --> 01:16:41,580
validate why this one has to validate X
 

3185
01:16:41,580 --> 01:16:43,550
validate why this one has to validate X
you know it's a red X but didn't write

3186
01:16:43,550 --> 01:16:43,560
you know it's a red X but didn't write
 

3187
01:16:43,560 --> 01:16:45,080
you know it's a red X but didn't write
it so it's going to validate it much

3188
01:16:45,080 --> 01:16:45,090
it so it's going to validate it much
 

3189
01:16:45,090 --> 01:16:47,000
it so it's going to validate it much
quicker and maybe it's going to commit

3190
01:16:47,000 --> 01:16:47,010
quicker and maybe it's going to commit
 

3191
01:16:47,010 --> 01:16:50,360
quicker and maybe it's going to commit
and maybe it's and so the question is if

3192
01:16:50,360 --> 01:16:50,370
and maybe it's and so the question is if
 

3193
01:16:50,370 --> 01:16:53,150
and maybe it's and so the question is if
we use this validate as I described it

3194
01:16:53,150 --> 01:16:53,160
we use this validate as I described it
 

3195
01:16:53,160 --> 01:16:54,709
we use this validate as I described it
that just checks the version number and

3196
01:16:54,709 --> 01:16:54,719
that just checks the version number and
 

3197
01:16:54,719 --> 01:16:56,600
that just checks the version number and
lock but haven't the version number

3198
01:16:56,600 --> 01:16:56,610
lock but haven't the version number
 

3199
01:16:56,610 --> 01:16:58,600
lock but haven't the version number
hasn't changed in the lock but isn't set

3200
01:16:58,600 --> 01:16:58,610
hasn't changed in the lock but isn't set
 

3201
01:16:58,610 --> 01:17:22,589
hasn't changed in the lock but isn't set
will we get a a correct answer

3202
01:17:22,589 --> 01:17:22,599

 

3203
01:17:22,599 --> 01:17:25,770

and no actually both the validation is

3204
01:17:25,770 --> 01:17:25,780
and no actually both the validation is
 

3205
01:17:25,780 --> 01:17:29,459
and no actually both the validation is
gonna fail for both because when these

3206
01:17:29,459 --> 01:17:29,469
gonna fail for both because when these
 

3207
01:17:29,469 --> 01:17:31,589
gonna fail for both because when these
LOC messages were processed by the

3208
01:17:31,589 --> 01:17:31,599
LOC messages were processed by the
 

3209
01:17:31,599 --> 01:17:33,479
LOC messages were processed by the
relevant primaries they cause the LOC a

3210
01:17:33,479 --> 01:17:33,489
relevant primaries they cause the LOC a
 

3211
01:17:33,489 --> 01:17:36,899
relevant primaries they cause the LOC a
bit just to be set initially presumably

3212
01:17:36,899 --> 01:17:36,909
bit just to be set initially presumably
 

3213
01:17:36,909 --> 01:17:38,700
bit just to be set initially presumably
the the reason okay did a cleared lock

3214
01:17:38,700 --> 01:17:38,710
the the reason okay did a cleared lock
 

3215
01:17:38,710 --> 01:17:42,479
the the reason okay did a cleared lock
bin but when we come to validate even

3216
01:17:42,479 --> 01:17:42,489
bin but when we come to validate even
 

3217
01:17:42,489 --> 01:17:44,939
bin but when we come to validate even
though the client is doing the one-sided

3218
01:17:44,939 --> 01:17:44,949
though the client is doing the one-sided
 

3219
01:17:44,949 --> 01:17:48,810
though the client is doing the one-sided
read of the object header for X&Y it's

3220
01:17:48,810 --> 01:17:48,820
read of the object header for X&Y it's
 

3221
01:17:48,820 --> 01:17:50,850
read of the object header for X&Y it's
gonna see the lock bit that was set by

3222
01:17:50,850 --> 01:17:50,860
gonna see the lock bit that was set by
 

3223
01:17:50,860 --> 01:17:55,310
gonna see the lock bit that was set by
the processing of these lock requests

3224
01:17:55,310 --> 01:17:55,320

 

3225
01:17:55,320 --> 01:17:57,299

and so they're both gonna see the lock

3226
01:17:57,299 --> 01:17:57,309
and so they're both gonna see the lock
 

3227
01:17:57,309 --> 01:17:59,790
and so they're both gonna see the lock
bits set on the object that they merely

3228
01:17:59,790 --> 01:17:59,800
bits set on the object that they merely
 

3229
01:17:59,800 --> 01:18:04,520
bits set on the object that they merely
read and they're both going to abort and

3230
01:18:04,520 --> 01:18:04,530
read and they're both going to abort and
 

3231
01:18:04,530 --> 01:18:08,279
read and they're both going to abort and
neither X nor Y will be modified and so

3232
01:18:08,279 --> 01:18:08,289
neither X nor Y will be modified and so
 

3233
01:18:08,289 --> 01:18:10,100
neither X nor Y will be modified and so
that was one of the legal outcomes

3234
01:18:10,100 --> 01:18:10,110
that was one of the legal outcomes
 

3235
01:18:10,110 --> 01:18:12,419
that was one of the legal outcomes
that's right somebody somebody notice

3236
01:18:12,419 --> 01:18:12,429
that's right somebody somebody notice
 

3237
01:18:12,429 --> 01:18:16,459
that's right somebody somebody notice
this indeed both validates will fail

3238
01:18:16,459 --> 01:18:16,469
this indeed both validates will fail
 

3239
01:18:16,469 --> 01:18:19,560
this indeed both validates will fail
another of course sometimes that a

3240
01:18:19,560 --> 01:18:19,570
another of course sometimes that a
 

3241
01:18:19,570 --> 01:18:21,509
another of course sometimes that a
transaction can go through and here's a

3242
01:18:21,509 --> 01:18:21,519
transaction can go through and here's a
 

3243
01:18:21,519 --> 01:18:27,509
transaction can go through and here's a
scenario in which it does work out

3244
01:18:27,509 --> 01:18:27,519
scenario in which it does work out
 

3245
01:18:27,519 --> 01:18:30,029
scenario in which it does work out
this was transaction one is a little

3246
01:18:30,029 --> 01:18:30,039
this was transaction one is a little
 

3247
01:18:30,039 --> 01:18:43,820
this was transaction one is a little
faster validates

3248
01:18:43,820 --> 01:18:43,830

 

3249
01:18:43,830 --> 01:18:45,660

all right so what's going to happen a

3250
01:18:45,660 --> 01:18:45,670
all right so what's going to happen a
 

3251
01:18:45,670 --> 01:18:50,670
all right so what's going to happen a
transaction one is a little bit faster

3252
01:18:50,670 --> 01:18:50,680
transaction one is a little bit faster
 

3253
01:18:50,680 --> 01:19:05,070
transaction one is a little bit faster
so this time it's validates gonna

3254
01:19:05,070 --> 01:19:05,080
so this time it's validates gonna
 

3255
01:19:05,080 --> 01:19:07,110
so this time it's validates gonna
succeed because nothing has happened to

3256
01:19:07,110 --> 01:19:07,120
succeed because nothing has happened to
 

3257
01:19:07,120 --> 01:19:09,630
succeed because nothing has happened to
X between when transaction 1 read it and

3258
01:19:09,630 --> 01:19:09,640
X between when transaction 1 read it and
 

3259
01:19:09,640 --> 01:19:12,660
X between when transaction 1 read it and
when it validated so presumably the lock

3260
01:19:12,660 --> 01:19:12,670
when it validated so presumably the lock
 

3261
01:19:12,670 --> 01:19:14,130
when it validated so presumably the lock
also went through without any trouble

3262
01:19:14,130 --> 01:19:14,140
also went through without any trouble
 

3263
01:19:14,140 --> 01:19:15,780
also went through without any trouble
because nobody's modified Y here either

3264
01:19:15,780 --> 01:19:15,790
because nobody's modified Y here either
 

3265
01:19:15,790 --> 01:19:18,890
because nobody's modified Y here either
so the primary answered yes for this the

3266
01:19:18,890 --> 01:19:18,900
so the primary answered yes for this the
 

3267
01:19:18,900 --> 01:19:21,510
so the primary answered yes for this the
one-sided read revealed an unchanged

3268
01:19:21,510 --> 01:19:21,520
one-sided read revealed an unchanged
 

3269
01:19:21,520 --> 01:19:24,510
one-sided read revealed an unchanged
version number and lock bit here and so

3270
01:19:24,510 --> 01:19:24,520
version number and lock bit here and so
 

3271
01:19:24,520 --> 01:19:26,880
version number and lock bit here and so
transaction one can commit and it will

3272
01:19:26,880 --> 01:19:26,890
transaction one can commit and it will
 

3273
01:19:26,890 --> 01:19:29,580
transaction one can commit and it will
have incremented Y but by this point if

3274
01:19:29,580 --> 01:19:29,590
have incremented Y but by this point if
 

3275
01:19:29,590 --> 01:19:32,430
have incremented Y but by this point if
this is the order when the primary

3276
01:19:32,430 --> 01:19:32,440
this is the order when the primary
 

3277
01:19:32,440 --> 01:19:37,350
this is the order when the primary
process is this actually when the

3278
01:19:37,350 --> 01:19:37,360
process is this actually when the
 

3279
01:19:37,360 --> 01:19:38,730
process is this actually when the
primary process is lock of X this will

3280
01:19:38,730 --> 01:19:38,740
primary process is lock of X this will
 

3281
01:19:38,740 --> 01:19:39,990
primary process is lock of X this will
also go through with no problem because

3282
01:19:39,990 --> 01:19:40,000
also go through with no problem because
 

3283
01:19:40,000 --> 01:19:43,830
also go through with no problem because
nobody's modified X when the primary for

3284
01:19:43,830 --> 01:19:43,840
nobody's modified X when the primary for
 

3285
01:19:43,840 --> 01:19:47,570
nobody's modified X when the primary for
Y processes the validate for Y though

3286
01:19:47,570 --> 01:19:47,580
Y processes the validate for Y though
 

3287
01:19:47,580 --> 01:19:51,450
Y processes the validate for Y though
it's I'm sorry when the client running

3288
01:19:51,450 --> 01:19:51,460
it's I'm sorry when the client running
 

3289
01:19:51,460 --> 01:19:54,900
it's I'm sorry when the client running
transaction two refetch is the version

3290
01:19:54,900 --> 01:19:54,910
transaction two refetch is the version
 

3291
01:19:54,910 --> 01:19:57,390
transaction two refetch is the version
number unlocked it for y it's either

3292
01:19:57,390 --> 01:19:57,400
number unlocked it for y it's either
 

3293
01:19:57,400 --> 01:19:59,820
number unlocked it for y it's either
gonna see this really depends on whether

3294
01:19:59,820 --> 01:19:59,830
gonna see this really depends on whether
 

3295
01:19:59,830 --> 01:20:02,040
gonna see this really depends on whether
the committee's happen if the commit

3296
01:20:02,040 --> 01:20:02,050
the committee's happen if the commit
 

3297
01:20:02,050 --> 01:20:03,810
the committee's happen if the commit
hasn't happened yet this valid a will

3298
01:20:03,810 --> 01:20:03,820
hasn't happened yet this valid a will
 

3299
01:20:03,820 --> 01:20:05,310
hasn't happened yet this valid a will
see that the lock bit is set because it

3300
01:20:05,310 --> 01:20:05,320
see that the lock bit is set because it
 

3301
01:20:05,320 --> 01:20:07,140
see that the lock bit is set because it
was set back here if the commit has

3302
01:20:07,140 --> 01:20:07,150
was set back here if the commit has
 

3303
01:20:07,150 --> 01:20:09,630
was set back here if the commit has
happened already then the lock bit of

3304
01:20:09,630 --> 01:20:09,640
happened already then the lock bit of
 

3305
01:20:09,640 --> 01:20:11,450
happened already then the lock bit of
will be clear but this validate

3306
01:20:11,450 --> 01:20:11,460
will be clear but this validate
 

3307
01:20:11,460 --> 01:20:13,260
will be clear but this validate
one-sided reader will see a different

3308
01:20:13,260 --> 01:20:13,270
one-sided reader will see a different
 

3309
01:20:13,270 --> 01:20:17,010
one-sided reader will see a different
version number than was originally seen

3310
01:20:17,010 --> 01:20:17,020
version number than was originally seen
 

3311
01:20:17,020 --> 01:20:18,900
version number than was originally seen
and it needs somebody it's just this

3312
01:20:18,900 --> 01:20:18,910
and it needs somebody it's just this
 

3313
01:20:18,910 --> 01:20:20,880
and it needs somebody it's just this
answer so one will commit so that

3314
01:20:20,880 --> 01:20:20,890
answer so one will commit so that
 

3315
01:20:20,890 --> 01:20:23,270
answer so one will commit so that
transaction one will commit and

3316
01:20:23,270 --> 01:20:23,280
transaction one will commit and
 

3317
01:20:23,280 --> 01:20:25,400
transaction one will commit and
transaction to will abort

3318
01:20:25,400 --> 01:20:25,410
transaction to will abort
 

3319
01:20:25,410 --> 01:20:27,450
transaction to will abort
and although I don't have time to talk

3320
01:20:27,450 --> 01:20:27,460
and although I don't have time to talk
 

3321
01:20:27,460 --> 01:20:29,400
and although I don't have time to talk
about it here if there's a straight

3322
01:20:29,400 --> 01:20:29,410
about it here if there's a straight
 

3323
01:20:29,410 --> 01:20:31,290
about it here if there's a straight
read-only transaction then there doesn't

3324
01:20:31,290 --> 01:20:31,300
read-only transaction then there doesn't
 

3325
01:20:31,300 --> 01:20:33,390
read-only transaction then there doesn't
need to be a locking phase and there

3326
01:20:33,390 --> 01:20:33,400
need to be a locking phase and there
 

3327
01:20:33,400 --> 01:20:35,280
need to be a locking phase and there
doesn't need to be a commit phase pure

3328
01:20:35,280 --> 01:20:35,290
doesn't need to be a commit phase pure
 

3329
01:20:35,290 --> 01:20:36,870
doesn't need to be a commit phase pure
read-only transactions can be done with

3330
01:20:36,870 --> 01:20:36,880
read-only transactions can be done with
 

3331
01:20:36,880 --> 01:20:39,660
read-only transactions can be done with
just just reading blind reads for the

3332
01:20:39,660 --> 01:20:39,670
just just reading blind reads for the
 

3333
01:20:39,670 --> 01:20:40,140
just just reading blind reads for the
reads

3334
01:20:40,140 --> 01:20:40,150
reads
 

3335
01:20:40,150 --> 01:20:42,350
reads
sorry one-sided RDMA reads for the reads

3336
01:20:42,350 --> 01:20:42,360
sorry one-sided RDMA reads for the reads
 

3337
01:20:42,360 --> 01:20:44,340
sorry one-sided RDMA reads for the reads
one-sided already me reads for the

3338
01:20:44,340 --> 01:20:44,350
one-sided already me reads for the
 

3339
01:20:44,350 --> 01:20:46,230
one-sided already me reads for the
validates and so they're extremely fast

3340
01:20:46,230 --> 01:20:46,240
validates and so they're extremely fast
 

3341
01:20:46,240 --> 01:20:48,690
validates and so they're extremely fast
read-only transactions are and don't

3342
01:20:48,690 --> 01:20:48,700
read-only transactions are and don't
 

3343
01:20:48,700 --> 01:20:52,290
read-only transactions are and don't
require any work any attention by the

3344
01:20:52,290 --> 01:20:52,300
require any work any attention by the
 

3345
01:20:52,300 --> 01:20:54,050
require any work any attention by the
server

3346
01:20:54,050 --> 01:20:54,060
server
 

3347
01:20:54,060 --> 01:20:58,070
server
so and this is at the heart you know

3348
01:20:58,070 --> 01:20:58,080
so and this is at the heart you know
 

3349
01:20:58,080 --> 01:21:00,350
so and this is at the heart you know
trends these reads and indeed though

3350
01:21:00,350 --> 01:21:00,360
trends these reads and indeed though
 

3351
01:21:00,360 --> 01:21:04,060
trends these reads and indeed though
everything about farm is very

3352
01:21:04,060 --> 01:21:04,070
everything about farm is very
 

3353
01:21:04,070 --> 01:21:06,440
everything about farm is very
streamlined - partially due to our DMA

3354
01:21:06,440 --> 01:21:06,450
streamlined - partially due to our DMA
 

3355
01:21:06,450 --> 01:21:09,620
streamlined - partially due to our DMA
and it uses OCC because it's basically

3356
01:21:09,620 --> 01:21:09,630
and it uses OCC because it's basically
 

3357
01:21:09,630 --> 01:21:12,620
and it uses OCC because it's basically
forced to in order to be able to do

3358
01:21:12,620 --> 01:21:12,630
forced to in order to be able to do
 

3359
01:21:12,630 --> 01:21:15,710
forced to in order to be able to do
reads without checking locks there are a

3360
01:21:15,710 --> 01:21:15,720
reads without checking locks there are a
 

3361
01:21:15,720 --> 01:21:17,360
reads without checking locks there are a
few brown downsides though it turns out

3362
01:21:17,360 --> 01:21:17,370
few brown downsides though it turns out
 

3363
01:21:17,370 --> 01:21:18,920
few brown downsides though it turns out
optimistic concurrency control really

3364
01:21:18,920 --> 01:21:18,930
optimistic concurrency control really
 

3365
01:21:18,930 --> 01:21:20,780
optimistic concurrency control really
works best if there's relatively few

3366
01:21:20,780 --> 01:21:20,790
works best if there's relatively few
 

3367
01:21:20,790 --> 01:21:23,060
works best if there's relatively few
conflicts if there's conflicts all the

3368
01:21:23,060 --> 01:21:23,070
conflicts if there's conflicts all the
 

3369
01:21:23,070 --> 01:21:26,180
conflicts if there's conflicts all the
time then transactions will have to

3370
01:21:26,180 --> 01:21:26,190
time then transactions will have to
 

3371
01:21:26,190 --> 01:21:27,560
time then transactions will have to
board and there's a you know a bunch of

3372
01:21:27,560 --> 01:21:27,570
board and there's a you know a bunch of
 

3373
01:21:27,570 --> 01:21:29,330
board and there's a you know a bunch of
other restrictions I already mentioned

3374
01:21:29,330 --> 01:21:29,340
other restrictions I already mentioned
 

3375
01:21:29,340 --> 01:21:31,940
other restrictions I already mentioned
like on farm like the data must all fit

3376
01:21:31,940 --> 01:21:31,950
like on farm like the data must all fit
 

3377
01:21:31,950 --> 01:21:33,980
like on farm like the data must all fit
in the RAM and all the computers must

3378
01:21:33,980 --> 01:21:33,990
in the RAM and all the computers must
 

3379
01:21:33,990 --> 01:21:35,180
in the RAM and all the computers must
mean that the same data center

3380
01:21:35,180 --> 01:21:35,190
mean that the same data center
 

3381
01:21:35,190 --> 01:21:38,990
mean that the same data center
nevertheless this was viewed at the time

3382
01:21:38,990 --> 01:21:39,000
nevertheless this was viewed at the time
 

3383
01:21:39,000 --> 01:21:41,660
nevertheless this was viewed at the time
and still as just a very surprisingly

3384
01:21:41,660 --> 01:21:41,670
and still as just a very surprisingly
 

3385
01:21:41,670 --> 01:21:44,990
and still as just a very surprisingly
high-speed implementation of distributed

3386
01:21:44,990 --> 01:21:45,000
high-speed implementation of distributed
 

3387
01:21:45,000 --> 01:21:48,050
high-speed implementation of distributed
transactions like just much faster than

3388
01:21:48,050 --> 01:21:48,060
transactions like just much faster than
 

3389
01:21:48,060 --> 01:21:52,850
transactions like just much faster than
any system in sort of in production use

3390
01:21:52,850 --> 01:21:52,860
any system in sort of in production use
 

3391
01:21:52,860 --> 01:21:54,620
any system in sort of in production use
and it's true that Hardware involves a

3392
01:21:54,620 --> 01:21:54,630
and it's true that Hardware involves a
 

3393
01:21:54,630 --> 01:21:56,300
and it's true that Hardware involves a
little bit exotic and really depends on

3394
01:21:56,300 --> 01:21:56,310
little bit exotic and really depends on
 

3395
01:21:56,310 --> 01:21:58,010
little bit exotic and really depends on
this non-volatile Ram scheme and it

3396
01:21:58,010 --> 01:21:58,020
this non-volatile Ram scheme and it
 

3397
01:21:58,020 --> 01:22:01,640
this non-volatile Ram scheme and it
depends on these special RDMA NICs and

3398
01:22:01,640 --> 01:22:01,650
depends on these special RDMA NICs and
 

3399
01:22:01,650 --> 01:22:04,450
depends on these special RDMA NICs and
those are not particularly pervasive now

3400
01:22:04,450 --> 01:22:04,460
those are not particularly pervasive now
 

3401
01:22:04,460 --> 01:22:08,180
those are not particularly pervasive now
but you do but you can get them and with

3402
01:22:08,180 --> 01:22:08,190
but you do but you can get them and with
 

3403
01:22:08,190 --> 01:22:09,530
but you do but you can get them and with
performance like this it seems likely

3404
01:22:09,530 --> 01:22:09,540
performance like this it seems likely
 

3405
01:22:09,540 --> 01:22:11,960
performance like this it seems likely
that they'll both in viewing and already

3406
01:22:11,960 --> 01:22:11,970
that they'll both in viewing and already
 

3407
01:22:11,970 --> 01:22:14,510
that they'll both in viewing and already
me will eventually be pretty pervasive

3408
01:22:14,510 --> 01:22:14,520
me will eventually be pretty pervasive
 

3409
01:22:14,520 --> 01:22:16,850
me will eventually be pretty pervasive
in data centers so that people can play

3410
01:22:16,850 --> 01:22:16,860
in data centers so that people can play
 

3411
01:22:16,860 --> 01:22:19,700
in data centers so that people can play
these kind of games and that's all I

3412
01:22:19,700 --> 01:22:19,710
these kind of games and that's all I
 

3413
01:22:19,710 --> 01:22:23,570
these kind of games and that's all I
have to say about farm happy to take any

3414
01:22:23,570 --> 01:22:23,580
have to say about farm happy to take any
 

3415
01:22:23,580 --> 01:22:26,260
have to say about farm happy to take any
questions if anybody has some and if not

3416
01:22:26,260 --> 01:22:26,270
questions if anybody has some and if not
 

3417
01:22:26,270 --> 01:22:29,390
questions if anybody has some and if not
I'll see you next week with a spark

3418
01:22:29,390 --> 01:22:29,400
I'll see you next week with a spark
 

3419
01:22:29,400 --> 01:22:31,310
I'll see you next week with a spark
which is you may be happy to know

3420
01:22:31,310 --> 01:22:31,320
which is you may be happy to know
 

3421
01:22:31,320 --> 01:22:33,790
which is you may be happy to know
absolutely not about transactions I

3422
01:22:33,790 --> 01:22:33,800
absolutely not about transactions I
 

3423
01:22:33,800 --> 01:22:35,610
absolutely not about transactions I
heard everyone bye-bye

3424
01:22:35,610 --> 01:22:35,620
heard everyone bye-bye
 

3425
01:22:35,620 --> 01:22:38,500
heard everyone bye-bye
[Music]

